<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS系列</title>
    <link href="/2024/03/05/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/TS%E7%B3%BB%E5%88%97/"/>
    <url>/2024/03/05/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/TS%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-TS-系列"><a href="#🍭-TS-系列" class="headerlink" title="🍭 TS 系列"></a>🍭 TS 系列</h1><h2 id="1-说说你对-TypeScript-的理解？与-JavaScript-的区别？"><a href="#1-说说你对-TypeScript-的理解？与-JavaScript-的区别？" class="headerlink" title="1. 说说你对 TypeScript 的理解？与 JavaScript 的区别？"></a>1. 说说你对 TypeScript 的理解？与 JavaScript 的区别？</h2><blockquote><p>TypeScript 是 JavaScript 的类型的超集，支持 ES6 语法，支持面向对象编程的概念，如类、接口、继承、泛型等</p></blockquote><h3 id="TypeScript-特性"><a href="#TypeScript-特性" class="headerlink" title="TypeScript 特性"></a>TypeScript 特性</h3><ol><li>类型批注和编译时类型检查 ：在编译时批注变量类型</li><li>类型推断：ts 中没有批注变量类型会自动推断变量的类型</li><li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li><li>接口：ts 中用接口来定义对象类型</li><li>枚举：用于取值被限定在一定范围内的场景</li><li>Mixin：可以接受任意类型的值</li><li>泛型编程：写代码时使用一些以后才指定的类型</li><li>名字空间：名字只在该区域内有效，其他区域可重复使用该名字而不冲突</li><li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li></ol><h3 id="TypeScript-与-JavaScript-区别"><a href="#TypeScript-与-JavaScript-区别" class="headerlink" title="TypeScript 与 JavaScript 区别"></a>TypeScript 与 JavaScript 区别</h3><ol><li>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法</li><li>TS:面向对象的强类型语言，JS:弱类型的脚本语言</li></ol><h2 id="2-TS-数据类型"><a href="#2-TS-数据类型" class="headerlink" title="2. TS 数据类型"></a>2. TS 数据类型</h2><ul><li>boolean（布尔类型）</li><li>number（数字类型）</li><li>string（字符串类型）</li><li>null 和 undefined 类型</li><li>symbol 类型</li><li>object 对象类型</li><li>array（数组类型）</li><li>tuple（元组类型）<blockquote><p>允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p></blockquote></li><li>enum（枚举类型）</li><li>any（任意类型）</li><li>void 类型</li><li>never 类型<blockquote><p>never 是其他类型 （包括 null 和 undefined）的子类型，可以赋值给任何类型，代表从不会出现的值<br>但是没有类型是 never 的子类型</p></blockquote></li></ul><h2 id="3-TS-枚举类型"><a href="#3-TS-枚举类型" class="headerlink" title="3. TS 枚举类型"></a>3. TS 枚举类型</h2><blockquote><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型<br>通俗来说，枚举就是一个对象的所有可能取值的集合</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li><p>数字枚举</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span>, <span class="hljs-comment">// 值默认为 0</span><br>  <span class="hljs-title class_">Down</span>, <span class="hljs-comment">// 值默认为 1</span><br>  <span class="hljs-title class_">Left</span>, <span class="hljs-comment">// 值默认为 2</span><br>  <span class="hljs-title class_">Right</span>, <span class="hljs-comment">// 值默认为 3</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>字符串枚举</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span> = <span class="hljs-string">&#x27;UP&#x27;</span>,<br>  <span class="hljs-title class_">Down</span> = <span class="hljs-string">&#x27;DOWN&#x27;</span>,<br>  <span class="hljs-title class_">Left</span> = <span class="hljs-string">&#x27;LEFT&#x27;</span>,<br>  <span class="hljs-title class_">Right</span> = <span class="hljs-string">&#x27;RIGHT&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>异构枚举</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BooleanLikeHeterogeneousEnum</span> &#123;<br>  <span class="hljs-title class_">No</span> = <span class="hljs-number">0</span>,<br>  <span class="hljs-title class_">Yes</span> = <span class="hljs-string">&#x27;YES&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><blockquote><p>枚举类型是一个对象，它包含了一组常量，通过编译后，枚举类型会被编译成一个对象，对象的属性名是枚举成员的名字，属性值是枚举成员的值</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>  <span class="hljs-title class_">Up</span>,<br>  <span class="hljs-title class_">Down</span>,<br>  <span class="hljs-title class_">Left</span>,<br>  <span class="hljs-title class_">Right</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>通过编译后，javascript 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Direction</span><br>;(<span class="hljs-keyword">function</span> (<span class="hljs-params">Direction</span>) &#123;<br>  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&#x27;Up&#x27;</span>] = <span class="hljs-number">0</span>)] = <span class="hljs-string">&#x27;Up&#x27;</span><br>  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&#x27;Down&#x27;</span>] = <span class="hljs-number">1</span>)] = <span class="hljs-string">&#x27;Down&#x27;</span><br>  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&#x27;Left&#x27;</span>] = <span class="hljs-number">2</span>)] = <span class="hljs-string">&#x27;Left&#x27;</span><br>  <span class="hljs-title class_">Direction</span>[(<span class="hljs-title class_">Direction</span>[<span class="hljs-string">&#x27;Right&#x27;</span>] = <span class="hljs-number">3</span>)] = <span class="hljs-string">&#x27;Right&#x27;</span><br>&#125;)(<span class="hljs-title class_">Direction</span> || (<span class="hljs-title class_">Direction</span> = &#123;&#125;))<br><br><span class="hljs-comment">//Direction[&quot;Up&quot;] = 0</span><br><span class="hljs-comment">// Direction[0] = &quot;Up&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TS系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git系列</title>
    <link href="/2024/03/05/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/git%E7%B3%BB%E5%88%97/"/>
    <url>/2024/03/05/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/git%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-git系列"><a href="#🍭-git系列" class="headerlink" title="🍭 git系列"></a>🍭 git系列</h1><h2 id="1-git-理解"><a href="#1-git-理解" class="headerlink" title="1. git 理解"></a>1. git 理解</h2><blockquote><p>git，是一个分布式版本控制软件</p></blockquote><ol><li>当我们通过<code>git init</code>创建或者<code>git clone</code>一个项目的时候，项目目录会<code>隐藏一个.git子目录</code>，其作用是用来<code>跟踪管理版本库</code>的</li><li>Git 中所有数据在存储前都<code>计算校验和</code>,然后<code>以校验和来引用</code>,Git 用以计算校验和的机制叫做 <code>SHA-1 散列</code>由 40 个十六进制字符（0-9 和 a-f）组成字符串</li><li>Git 有三种状态，<code>已提交（committed）</code>、<code>已修改（modified）</code>和<code>已暂存（staged）</code></li><li>文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域，主要分成了四部分：<ol><li>工作区：相当于本地写代码的区域，如 git clone 一个项目到本地，相当于本地克隆了远程仓库项目的一个副本</li><li>暂存区：暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中</li><li>本地仓库：提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库</li><li>远程仓库：远程的仓库，如 github</li></ol></li></ol><h2 id="2-说说-Git-中-fork-clone-branch-这三个概念，有什么区别"><a href="#2-说说-Git-中-fork-clone-branch-这三个概念，有什么区别" class="headerlink" title="2. 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?"></a>2. 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?</h2><ol><li><p>fork: fork 是指<code>复制一个项目到自己仓库</code>，fork 后的项目是<code>独立的</code>，对自己的仓库中进行修改，<code>不会影响原有项目</code>; 但是<code>fork后的项目</code>是<code>与原有项目有关联的</code>，可以通过<code>pull request</code>向原有项目提交修改.</p></li><li><p>clone: clone 是指<code>将远程仓库克隆到本地</code>，克隆后的项目是<code>独立的</code>，对本地仓库进行修改，<code>不会影响远程仓库</code>; 但是<code>clone后的项目</code>是<code>与远程仓库有关联的</code>，可以通过<code>push</code>向远程仓库提交修改.</p></li><li><p>branch: branch 是指<code>分支</code>，在<code>同一个仓库</code>中，可以<code>创建多个分支</code>，每个分支可以<code>独立开发</code>，<code>不会影响其他分支</code>，最后可以通过<code>合并分支</code>的方式将分支合并到主分支.</p></li></ol><h2 id="3-说说-Git-常用的命令有哪些？"><a href="#3-说说-Git-常用的命令有哪些？" class="headerlink" title="3. 说说 Git 常用的命令有哪些？"></a>3. 说说 Git 常用的命令有哪些？</h2><ol><li><p>配置：Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;yourname&quot; # 设置用户名<br>git config --global user.email &quot;youremail&quot; # 设置邮箱<br></code></pre></td></tr></table></figure></li><li><p>创建仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建或在当前目录初始化一个git代码库</span><br>git init [project-name]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载一个项目和它的整个代码历史</span><br>git clone url<br></code></pre></td></tr></table></figure></li><li><p>日常操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add .         # 提交全部文件修改到缓存区<br>git add           # &lt;具体某个文件路径+全名&gt; 提交某些文件到缓存区<br>git diff          # 查看当前代码 add后，会 add 哪些内容<br>git diff --staged # 查看现在 commit 提交后，会提交哪些内容<br>git status        # 查看当前分支状态<br>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;            # 拉取远程仓库的分支与本地当前分支合并<br>git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; # 拉取远程仓库的分支与本地某个分支合并<br>git commit -m &quot;&lt;注释&gt;&quot;                     # 提交代码到本地仓库，并写提交注释<br>git commit -v     # 提交时显示所有diff信息<br>git commit --amend [file1] [file2]        # 重做上一次commit，并包括指定文件的新变化<br></code></pre></td></tr></table></figure></li><li><p>分支操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch      # 查看本地所有分支<br>git branch -r   # 查看远程所有分支<br>git branch -a   # 查看本地和远程所有分支<br>git merge &lt;分支名&gt; # 合并分支<br>git merge --abort # 合并分支出现冲突时，取消合并，一切回到合并前的状态<br>git branch &lt;新分支名&gt;             # 基于当前分支，新建一个分支<br>git checkout --orphan &lt;新分支名&gt;  # 新建一个空分支（会保留之前分支的所有文件）b<br>git branch -D &lt;分支名&gt;            # 删除本地某个分支<br>git push &lt;远程库名&gt; :&lt;分支名&gt;      # 删除远程某个分支<br>git branch &lt;新分支名称&gt; &lt;提交ID&gt;   # 从提交历史恢复某个删掉的某个分支<br>git branch -m &lt;原分支名&gt; &lt;新分支名&gt; # 分支更名<br>git checkout &lt;分支名&gt;             # 切换到本地某个分支<br>git checkout &lt;远程库名&gt;/&lt;分支名&gt;   # 切换到线上某个分支<br>git checkout -b &lt;新分支名&gt;        # 把基于当前分支新建分支，并切换为这个分支<br>git merge &lt;分支名&gt;                # 合并某个分支到当前分支<br>git rebase &lt;分支名&gt;               # 变基操作，将当前分支变基到某个分支<br></code></pre></td></tr></table></figure></li><li><p>远程操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git fetch [remote]         # 下载远程仓库的所有变动<br>git remote -v              # 显示所有远程仓库<br>git pull [remote] [branch] # 拉取远程仓库的分支与本地当前分支合并<br>git fetch                  # 获取线上最新版信息记录，不合并<br>git push [remote] [branch] # 上传本地指定分支到远程仓库<br>git push [remote] --force  # 强行推送当前分支到远程仓库，即使有冲突<br>git push [remote] --all    # 推送所有分支到远程仓库<br></code></pre></td></tr></table></figure></li><li><p>撤销</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout [file] #恢复暂存区的指定文件到工作区<br>git checkout [commit] [file] #恢复某个commit的指定文件到暂存区和工作区<br>git checkout . #恢复暂存区的所有文件到工作区<br>git reset [commit] #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>git reset --hard #重置暂存区与工作区，与上一次commit保持一致<br>git reset [file] #重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>git revert [commit] #后者的所有变化都将被前者抵消，并且应用到当前分支<br></code></pre></td></tr></table></figure></li><li><p>存储操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">git stash #暂时将未提交的变化移除<br>git stash pop #取出储藏中最后存入的工作状态进行恢复，会删除储藏<br>git stash list #查看所有储藏中的工作<br>git stash apply &lt;储藏的名称&gt; #取出储藏中对应的工作状态进行恢复，不会删除储藏<br>git stash clear #清空所有储藏中的工作<br>git stash drop &lt;储藏的名称&gt; #删除对应的某个储藏<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-说说对-git-pull-和-git-fetch-的理解？有什么区别？"><a href="#4-说说对-git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="4. 说说对 git pull 和 git fetch 的理解？有什么区别？"></a>4. 说说对 git pull 和 git fetch 的理解？有什么区别？</h2><ol><li>git fetch 是将<code>远程主机的最新内容拉到本地</code>，用户在检查了以后决定<code>是否合并</code>到工作本机分支中</li><li>git pull 则是将<code>远程主机的最新内容拉下来后直接合并</code>，即：<code>git pull = git fetch + git merge</code>，这样可能会产生冲突，需要手动解决</li></ol><h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><blockquote><p>使用 git fetch 更新代码，本地的库中 master 的 commitID 不变<br>但是与 git 上面关联的那个 orign&#x2F;master 的 commit ID 发生改变</p></blockquote><p>这时候我们本地相当于存储了两个代码的版本号，我们还要通过 merge 去合并这两个不同的代码版本</p><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><blockquote><p>使用 git pull 更新代码，本地的库中 master 的 commitID 发生改变<br>与 git 上面关联的那个 orign&#x2F;master 的 commit ID 也发生改变</p></blockquote><h2 id="5-说说-Git-中的-rebase-和-merge-的区别？"><a href="#5-说说-Git-中的-rebase-和-merge-的区别？" class="headerlink" title="5. 说说 Git 中的 rebase 和 merge 的区别？"></a>5. 说说 Git 中的 rebase 和 merge 的区别？</h2><blockquote><p>git merge 将当前分支合并到指定分支，命令用法如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge xxx<br></code></pre></td></tr></table></figure><p>#git rebase 将当前分支移植到指定分支或指定 commit 之上，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git rebase -i &lt;commit&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见的参数有--<span class="hljs-built_in">continue</span>，用于解决冲突之后，继续执行rebase</span><br>git rebase --continue<br></code></pre></td></tr></table></figure><ol><li><p>git merge会在分支中产生一个新的merge commit，然后将两个分支的history联系在一起。</p></li><li><p>git rebase 是将一个分支的提交序列“拉直”，并且将其与另一个分支合并。这意味着，提交历史看起来好像是一条直线，没有分叉，因此整个提交历史看起来<code>更加整洁</code>，历史记录保持相对简单。</p></li><li><p>git merge<br>优点：不会破坏原分支的提交记录。<br>缺点：会产生额外的提交记录，并进行两条分支线的合并。(这导致了 Git 历史记录中出现<code>多个分支合并点</code>的情况，从而使<code>历史记录更加复杂</code>)</p></li><li><p>git rebase<br>优点：无需新增提交记录到目标分支，reabse后可以直接将对象分支的提交历史加到目标分支上，形成线性提交历史记录，更加直观。<br>缺点：不能在一个共享分支上进行reabse操作，会带来分支安全问题。(安全：git rebase的原理是撤销提交并重新应用每个提交，这样可能会导致您在本地进行的更改丢失。)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React系列</title>
    <link href="/2024/02/29/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/React%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/29/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/React%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-React-系列"><a href="#🍭-React-系列" class="headerlink" title="🍭 React 系列"></a>🍭 React 系列</h1><h2 id="1-说说你对-React-的理解？优缺点？应用场景？"><a href="#1-说说你对-React-的理解？优缺点？应用场景？" class="headerlink" title="1. 说说你对 React 的理解？优缺点？应用场景？"></a>1. 说说你对 React 的理解？优缺点？应用场景？</h2><blockquote><p>React，用于构建用户界面的 JavaScript 库，只提供了 UI 层面的解决方案<br>React 特性有很多，如：</p></blockquote><ul><li>JSX 语法</li><li>单向数据绑定</li><li>虚拟 DOM</li><li>声明式编程<blockquote><p>声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做<br>它表达逻辑而不显式地定义步骤。这意味着我们需要根据逻辑的计算来声明要显示的组件</p></blockquote></li><li>Component<blockquote><p>在 React 中，一切皆为组件。通常将应用程序的整个逻辑分解为小的单个部分。 我们将每个单独的部分称为组件</p></blockquote></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>优点：</li></ol><ul><li>高效灵活<br>—  声明式的设计，简单使用<br>—  组件式开发，提高代码复用率<br>—  单向响应的数据流会比双向绑定的更安全，速度更快</li></ul><h2 id="2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？"><a href="#2-说说-Real-DOM-和-Virtual-DOM-的区别？优缺点？" class="headerlink" title="2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？"></a>2. 说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h2><blockquote><p>Real DOM，真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM 结构，如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello world<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Virtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li><li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li></ol><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>真实 DOM</li></ol><ul><li>优点：易用</li><li>缺点：效率低、性能差</li></ul><ol start="2"><li>虚拟 DOM</li></ol><ul><li>优点：性能高、效率高、简单方便、跨平台</li><li>缺点：需要额外的内存空间、复杂度高</li></ul><h2 id="3-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？"><a href="#3-说说-React-生命周期有哪些不同阶段？每个阶段对应的方法是？" class="headerlink" title="3. 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？"></a>3. 说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？</h2><blockquote><p>react16.4 之后的生命周期，可以分成三个阶段：</p></blockquote><ol><li>创建阶段</li><li>更新阶段</li><li>卸载阶段</li></ol><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><ol><li>constructor<blockquote><p>实例过程中自动调用的方法，在方法内部通过 super 关键字获取来自父组件的 props<br>在该方法中，通常的操作为初始化 state 状态或者在 this 上挂载方法</p></blockquote></li><li>getDerivedStateFromProps<blockquote><p>该方法是新增的生命周期方法，是一个静态的方法，因此不能访问到组件的实例<br>执行时机：组件创建和更新阶段，不论是 props 变化还是 state 变化，也会调用<br>可以比较 props 和 state 来加一些限制条件，防止无用的 state 更新</p></blockquote></li><li>render<blockquote><p>类组件必须实现的方法，用于渲染 DOM 结构，可以访问组件 state 与 prop 属性</p></blockquote></li><li>componentDidMount<blockquote><p>组件挂载到真实 DOM 节点后执行，其在 render 方法之后执行<br>此方法多用于执行一些数据获取，事件监听等操作</p></blockquote></li></ol><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><ol><li>getDerivedStateFromProps</li><li>shouldComponentUpdate<blockquote><p>用于告知组件本身基于当前的 props 和 state 是否需要重新渲染组件，默认情况返回 true</p></blockquote></li><li>render</li><li>getSnapshotBeforeUpdate<blockquote><p>该周期函数在 render 后执行，执行之时 DOM 元素还没有被更新<br>该方法返回的一个 Snapshot 值，作为 componentDidUpdate 第三个参数传入<br>此方法的目的在于获取组件更新前的一些信息</p></blockquote></li><li>componentDidUpdate<blockquote><p>执行时机：组件更新结束后触发</p></blockquote></li></ol><h3 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h3><ol><li>componentWillUnmount<br>此方法用于组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等</li></ol><h2 id="4-state-和-props-有什么区别？"><a href="#4-state-和-props-有什么区别？" class="headerlink" title="4. state 和 props 有什么区别？"></a>4. state 和 props 有什么区别？</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><ul><li>state 是组件内部的状态，是可变的<br>当需要修改里面的值的状态需要通过调用 setState 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 render 方法，如下面的例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote><p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是 props，所以可以把 props 理解为从外部传入组件内部的数据</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol><li>相同点：</li></ol><ul><li>两者都是 JavaScript 对象</li><li>两者都是用于保存信息</li><li>props 和 state 都能触发渲染更新</li></ul><ol start="2"><li>区别：</li></ol><ul><li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li><li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li><li>state 是多变的、可以修改</li></ul><h2 id="5-说说-React-的事件机制？"><a href="#5-说说-React-的事件机制？" class="headerlink" title="5. 说说 React 的事件机制？"></a>5. 说说 React 的事件机制？</h2><blockquote><p>React 基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等<br>在 React 中这套事件机制被称之为合成事件</p></blockquote><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><blockquote><p>合成事件是 React 模拟原生 DOM 事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器<br>根据 W3C 规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原生事件绑定方式</span><br>;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;handleClick()&quot;</span>&gt;</span>按钮命名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><br><span class="hljs-comment">// React 合成事件绑定方式</span><br><span class="hljs-keyword">const</span> button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>按钮命名<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol><li>React 所有事件都挂载在 document 对象上</li><li>当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件</li><li>所以会先执行原生事件，然后处理 React 事件</li><li>最后真正执行 document 上挂载的事件</li></ol><h2 id="6-React-事件绑定的方式有哪些？区别？"><a href="#6-React-事件绑定的方式有哪些？区别？" class="headerlink" title="6. React 事件绑定的方式有哪些？区别？"></a>6. React 事件绑定的方式有哪些？区别？</h2><ol><li>render 方法中使用 bind<br><code>&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;test&lt;/div&gt;</code></li><li>render 方法中使用箭头函数<br><code>&lt;div onClick=&#123;e =&gt; this.handleClick(e)&#125;&gt;test&lt;/div&gt;</code></li><li>constructor 中 bind</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">handleClick ()&#123;...&#125;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-variable language_">super</span>(props);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleClick</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>定义阶段使用箭头函数绑定</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">handleClick = <span class="hljs-function">() =&gt;</span> &#123;...&#125;<br>;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ol><li>编写方面：方式一、方式二写法简单，方式三的编写过于冗杂</li><li>性能方面：方式一和方式二在每次组件 render 的时候都会生成新的方法实例，性能问题欠缺。若该函数作为属性值传给子组件的时候，都会导致额外的渲染。而方式三、方式四只会生成一个方法实例</li><li>综合上述，方式四是最优的事件绑定方式</li></ol><h2 id="7-React-构建组件的方式有哪些？区别？"><a href="#7-React-构建组件的方式有哪些？区别？" class="headerlink" title="7. React 构建组件的方式有哪些？区别？"></a>7. React 构建组件的方式有哪些？区别？</h2><ol><li>函数式创建</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">HelloComponent</span>(<span class="hljs-params">props <span class="hljs-comment">/* context */</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>通过 React.createClass 方法创建</li><li>继承 React.Component 创建</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-React-中组件之间如何通信？"><a href="#8-React-中组件之间如何通信？" class="headerlink" title="8. React 中组件之间如何通信？"></a>8. React 中组件之间如何通信？</h2><h3 id="父组件向子组件传递"><a href="#父组件向子组件传递" class="headerlink" title="父组件向子组件传递"></a>父组件向子组件传递</h3><ol><li>父组件通过 props 向子组件传递数据</li></ol><h3 id="子组件向父组件传递"><a href="#子组件向父组件传递" class="headerlink" title="子组件向父组件传递"></a>子组件向父组件传递</h3><ol><li>子组件向父组件通信的基本思路是，父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父组件</span><br>&lt;<span class="hljs-title class_">Child</span> getPrice=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">getItemPrice</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)&#125; /&gt;<br><br><span class="hljs-comment">// 子组件</span><br><span class="hljs-title function_">clickGoods</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 在此函数中传入值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-title function_">getPrice</span>(e);<br>&#125;<br>&lt;button onClick=&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">clickGoods</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-number">100</span>)&#125;&gt;获取价格&lt;/button&gt;<br></code></pre></td></tr></table></figure><h3 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h3><ol><li>如果是兄弟组件之间的传递，则父组件作为中间层来实现数据的互通，通过使用父组件传递</li></ol><h3 id="父组件向后代组件传递"><a href="#父组件向后代组件传递" class="headerlink" title="父组件向后代组件传递"></a>父组件向后代组件传递</h3><ol><li>通过使用 React.createContext 创建一个 context 对象，然后通过 Provider 和 Consumer 来进行数据的传递</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">PriceContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>(<span class="hljs-string">&#x27;price&#x27;</span>)<br><br><span class="hljs-comment">//Provider组件通过value属性用于给后代组件传递数据：</span><br>&lt;<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Provider</span> value=&#123;<span class="hljs-number">100</span>&#125;&gt;<br>&lt;/<span class="hljs-title class_">PriceContext</span>.<span class="hljs-property">Provider</span>&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PriceContext.Consumer</span>&gt;</span></span><br><span class="language-xml">    &#123; /*这里是一个函数*/ &#125;</span><br><span class="language-xml">    &#123;</span><br><span class="language-xml">        price =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>price：&#123;price&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    &#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">PriceContext.Consumer</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="非关系组件传递"><a href="#非关系组件传递" class="headerlink" title="非关系组件传递"></a>非关系组件传递</h3><ol><li>如果组件之间关系类型比较复杂的情况，建议将数据进行一个全局资源管理，从而实现通信，例如 redux。关于 redux 的使用后续再详细介绍</li></ol><h2 id="9-说说-React-中的-key-的作用？"><a href="#9-说说-React-中的-key-的作用？" class="headerlink" title="9. 说说 React 中的 key 的作用？"></a>9. 说说 React 中的 key 的作用？</h2><ol><li>跟 Vue 一样，React 也存在 Diff 算法，而元素 key 属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染</li><li>因此 key 的值需要为每一个元素赋予一个确定的标识</li></ol><h2 id="10-说说对-React-refs-的理解？应用场景？"><a href="#10-说说对-React-refs-的理解？应用场景？" class="headerlink" title="10. 说说对 React refs 的理解？应用场景？"></a>10. 说说对 React refs 的理解？应用场景？</h2><blockquote><p>React 中的 Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素<br>本质为 ReactDOM.render()返回的组件实例，如果是渲染组件则返回的是组件实例，如果渲染 dom 则返回的是具体的 dom 节点</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>传入字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myref&quot;</span> /&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>传入对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>传入函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(element)</span> =&gt;</span> (this.myref = element)&#125; /&gt;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>传入 hook</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">const</span> myref = <span class="hljs-title function_">useRef</span>()<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;myref&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-说说对-React-中类组件和函数组件的理解？有什么区别？"><a href="#11-说说对-React-中类组件和函数组件的理解？有什么区别？" class="headerlink" title="11. 说说对 React 中类组件和函数组件的理解？有什么区别？"></a>11. 说说对 React 中类组件和函数组件的理解？有什么区别？</h2><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><blockquote><p>类组件，顾名思义，也就是通过使用 ES6 类的编写形式去编写组件，该类必须继承 React.Component</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props)<br>  &#125;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><blockquote><p>函数组件，顾名思义，就是通过函数编写的形式去实现一个 React 组件，是 React 中定义组件最简单的方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h3><blockquote><p>针对两种 React 组件，其区别主要分成以下几大方向：</p></blockquote><ol><li>编写形式</li><li>状态管理<blockquote><p>类组件可以使用 setState 状态，而函数组件使用 useState 状态</p></blockquote></li><li>生命周期<blockquote><p>在函数组件中，并不存在生命周期，这是因为这些生命周期钩子都来自于继承的 React.Component<br>但是函数组件使用 useEffect 也能够完成替代生命周期的作用，这里给出一个简单的例子：</p></blockquote></li><li>调用方式<blockquote><p>如果是一个函数组件，调用则是执行函数即可：<br>如果是一个类组件，则需要将组件进行实例化，然后调用实例对象的 render 方法：</p></blockquote></li><li>获取渲染的值<blockquote><p>类组件:this.props<br>函数组件:props</p></blockquote></li></ol><h2 id="12-说说对受控组件和非受控组件的理解？应用场景？"><a href="#12-说说对受控组件和非受控组件的理解？应用场景？" class="headerlink" title="12. 说说对受控组件和非受控组件的理解？应用场景？"></a>12. 说说对受控组件和非受控组件的理解？应用场景？</h2><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><blockquote><p>受控组件，简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据</p></blockquote><ol><li>如果想要解除被控制，可以为 input 标签设置 onChange 事件，输入的时候触发事件函数，在函数内部实现 state 的更新，从而导致 input 框的内容页发现改变</li><li>因此，受控组件我们一般需要初始状态和一个状态更新事件函数</li></ol><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><blockquote><p>非受控组件，简单来讲，就是不受我们控制的组件，组件的状态不受外部数据的影响</p></blockquote><ol><li>当需要时，可以使用 ref 查询 DOM 并查找其当前值</li></ol><h2 id="13-说说对高阶组件的理解？应用场景"><a href="#13-说说对高阶组件的理解？应用场景" class="headerlink" title="13. 说说对高阶组件的理解？应用场景?"></a>13. 说说对高阶组件的理解？应用场景?</h2><blockquote><p>高阶函数（Higher-order function），至少满足下列一个条件的函数</p></blockquote><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><blockquote><p>在 React 中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-title class_">WrappedComponent</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> /&gt;</span></span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-说说对-React-Hooks-的理解？解决了什么问题？"><a href="#14-说说对-React-Hooks-的理解？解决了什么问题？" class="headerlink" title="14. 说说对 React Hooks 的理解？解决了什么问题？"></a>14. 说说对 React Hooks 的理解？解决了什么问题？</h2><blockquote><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性<br>上面讲到，Hooks 让我们的函数组件拥有了类组件的特性，例如组件内的状态、生命周期</p></blockquote><h3 id="最常见的-hooks-有如下："><a href="#最常见的-hooks-有如下：" class="headerlink" title="最常见的 hooks 有如下："></a>最常见的 hooks 有如下：</h3><ol><li>useState<blockquote><p>在函数组件中通过 useState 实现函数内部维护 state，参数为 state 默认的值，返回值是一个数组，第一个值为当前的 state，第二个值为更新 state 的函数</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 声明一个叫 &quot;count&quot; 的 state 变量</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>useEffect<blockquote><p>useEffect 可以让我们在函数组件中进行一些带有副作用的操作</p></blockquote></li></ol><ol><li>useEffect第一个参数接受一个回调函数，默认情况下，useEffect会在第一次渲染和更新之后都会执行</li><li>传入第二个参数后，如果 count 的值是 5，而且我们的组件重渲染的时候 count 还是等于 5，React 将对前一次渲染的 [5] 和后一次渲染的 [5] 进行比较，如果是相等则跳过effects执行</li></ol><p>回调函数中可以返回一个清除函数，这是effect可选的清除机制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;Click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>其他<br>useReducer<br>useCallback<br>useMemo<br>useRef</li></ol><h2 id="15-说说react中引入css的方式有哪几种？区别？"><a href="#15-说说react中引入css的方式有哪几种？区别？" class="headerlink" title="15. 说说react中引入css的方式有哪几种？区别？"></a>15. 说说react中引入css的方式有哪几种？区别？</h2><ol><li>在组件内直接使用</li></ol><ul><li>优点：内联样式, 样式之间不会有冲突，可以动态获取当前state中的状态</li><li>缺点：性能不好，代码混乱，某些样式无法编写(比如伪类&#x2F;伪元素)<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> div1 = &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-string">&quot;300px&quot;</span>,<br>  <span class="hljs-attr">margin</span>: <span class="hljs-string">&quot;30px auto&quot;</span>,<br>  <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&quot;#44014C&quot;</span>,  <span class="hljs-comment">//驼峰法</span><br>  <span class="hljs-attr">minHeight</span>: <span class="hljs-string">&quot;200px&quot;</span>,<br>  <span class="hljs-attr">boxSizing</span>: <span class="hljs-string">&quot;border-box&quot;</span><br>&#125;;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;div1&#125;</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>组件中引入 .css 文件<blockquote><p>将css单独写在一个css文件中，然后在组件中直接引入</p></blockquote></li></ol><ul><li>缺点：样式之间会互相影响</li></ul><ol start="3"><li>组件中引入 .module.css 文件<blockquote><p>将css文件作为一个模块引入，这个模块中的所有css，只作用于当前组件。不会影响当前组件的后代组件</p></blockquote></li><li>CSS in JS<blockquote><p>使用第三方库styled-components，将css写在js文件中</p></blockquote></li></ol><h2 id="16-在react中组件间过渡动画如何实现？"><a href="#16-在react中组件间过渡动画如何实现？" class="headerlink" title="16. 在react中组件间过渡动画如何实现？"></a>16. 在react中组件间过渡动画如何实现？</h2><blockquote><p>在react中，react-transition-group是一种很好的解决方案，其为元素添加enter，enter-active，exit，exit-active这一系列勾子可以帮助我们方便的实现组件的入场和离场动画</p></blockquote><h3 id="其主要提供了三个主要的组件："><a href="#其主要提供了三个主要的组件：" class="headerlink" title="其主要提供了三个主要的组件："></a>其主要提供了三个主要的组件：</h3><ol><li>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</li><li>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</li><li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li></ol><h2 id="17-说说你对Redux的理解？其工作原理？"><a href="#17-说说你对Redux的理解？其工作原理？" class="headerlink" title="17. 说说你对Redux的理解？其工作原理？"></a>17. 说说你对Redux的理解？其工作原理？</h2><blockquote><p>redux就是一个实现上述集中管理的容器，遵循三大基本原则：</p></blockquote><ol><li>单一数据源</li><li>state 是只读的</li><li>使用纯函数来执行修改</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>React系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJs系列</title>
    <link href="/2024/02/29/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/29/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/NodeJs%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-NodeJs-系列"><a href="#🍭-NodeJs-系列" class="headerlink" title="🍭 NodeJs 系列"></a>🍭 NodeJs 系列</h1><h2 id="1-说说你对-Node-js-的理解？优缺点？应用场景？"><a href="#1-说说你对-Node-js-的理解？优缺点？应用场景？" class="headerlink" title="1. 说说你对 Node.js 的理解？优缺点？应用场景？"></a>1. 说说你对 Node.js 的理解？优缺点？应用场景？</h2><blockquote><p>Node.js 是一个开源与跨平台的 JavaScript 运行时环境<br>可以理解为 Node.js 就是一个服务器端的、非阻塞式 I&#x2F;O 的、事件驱动的 JavaScript 运行环境</p></blockquote><h3 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h3><blockquote><p>在 Nodejs 中，所有的 I&#x2F;O 操作都是异步的，也就是说，Nodejs 在执行 I&#x2F;O 操作时，不会等待 I&#x2F;O 操作的结果返回，而是直接转而执行后面的代码</p></blockquote><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><blockquote><p>事件驱动就是当进来一个新的请求的时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>优点：</li></ol><ul><li>处理高并发场景性能更佳</li><li>适合 I&#x2F;O 密集型应用，值的是应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I&#x2F;O 硬盘内存读写操作</li></ul><ol start="2"><li>因为 Nodejs 是单线程，带来的缺点有：</li></ol><ul><li>不适合 CPU 密集型应用</li><li>只支持单核 CPU，不能充分利用 CPU</li><li>可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li></ul><h2 id="2-说说-Node-js-有哪些全局对象？"><a href="#2-说说-Node-js-有哪些全局对象？" class="headerlink" title="2. 说说 Node. js 有哪些全局对象？"></a>2. 说说 Node. js 有哪些全局对象？</h2><blockquote><p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Nodejs 中的全局对象是 global</p></blockquote><h3 id="将全局对象分成两类："><a href="#将全局对象分成两类：" class="headerlink" title="将全局对象分成两类："></a>将全局对象分成两类：</h3><ol><li>真正的全局对象</li></ol><ul><li><p>Class:Buffer</p><blockquote><p>可以处理二进制以及非 Unicode 编码的数据</p></blockquote></li><li><p>process</p><blockquote><p>进程对象，提供有关当前进程的信息和控制</p></blockquote></li><li><p>console</p></li><li><p>clearInterval、setInterval</p></li><li><p>clearTimeout、setTimeout</p></li><li><p>global</p><blockquote><p>全局命名空间对象，process、console、setTimeout 等都有放到 global 中</p></blockquote></li></ul><ol start="2"><li>模块级别的全局变量</li></ol><ul><li>__dirname<blockquote><p>获取当前文件所在的路径，不包括后面的文件名</p></blockquote></li><li>__filename<blockquote><p>获取当前文件所在的路径和文件名称，包括后面的文件名称</p></blockquote></li><li>exports<blockquote><p>module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容</p></blockquote></li><li>module<blockquote><p>对当前模块的引用，通过 module.exports 用于指定一个模块所导出的内容，即可以通过 require() 访问的内容</p></blockquote></li><li>require<blockquote><p>用于引入模块、 JSON、或本地文件。 可以从 node_modules 引入模块。</p></blockquote></li></ul><h2 id="3-而在-NodeJS-中，事件循环是基于-libuv-实现，libuv-是一个多平台的专注于异步-IO-的库，如下图最右侧所示："><a href="#3-而在-NodeJS-中，事件循环是基于-libuv-实现，libuv-是一个多平台的专注于异步-IO-的库，如下图最右侧所示：" class="headerlink" title="3. 而在 NodeJS 中，事件循环是基于 libuv 实现，libuv 是一个多平台的专注于异步 IO 的库，如下图最右侧所示："></a>3. 而在 NodeJS 中，事件循环是基于 libuv 实现，libuv 是一个多平台的专注于异步 IO 的库，如下图最右侧所示：</h2><blockquote><p>在 Node 中，同样存在宏任务和微任务，与浏览器中的事件循环相似</p></blockquote><ol><li>微任务对应有：<br>next tick queue：process.nextTick<br>other queue：Promise 的 then 回调、queueMicrotask</li><li>宏任务对应有：<br>timer queue：setTimeout、setInterval<br>poll queue：IO 事件<br>check queue：setImmediate<br>close queue：close 事件</li><li>其执行顺序为：<br>next tick microtask queue<br>other microtask queue<br>timer queue<br>poll queue<br>check queue<br>close queue</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>NodeJs系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试常问题目汇总</title>
    <link href="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <url>/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试常问题目汇总"><a href="#🍭-面试常问题目汇总" class="headerlink" title="🍭 面试常问题目汇总"></a>🍭 面试常问题目汇总</h1><h1 id="0-项目介绍"><a href="#0-项目介绍" class="headerlink" title="0. 项目介绍"></a>0. 项目介绍</h1><h2 id="1-星禾"><a href="#1-星禾" class="headerlink" title="1. 星禾"></a>1. 星禾</h2><p>·项⽬描述：星⽲传媒是⼀款基于 Vue3+Three.js+Echarts 技术的少数⺠族⽂化的展览平台。功能包含⺠族⽂化展⽰、3D ⺠族服饰定制、⺠族信息的可视化⼤屏和 3D 地图等。<br>·前端技术栈：Vue3、Nuxt3、Pinia、javaScript、Scss、Three.js、WebGL、ElementUI、Echarts、axios<br>·项⽬技术：</p><ol><li>参与前端界⾯设计，从 0 到 1 完成项⽬的搭建、配置和部署。</li><li>基于 Three.js 实现 3D 模型渲染，展⽰三维⺠族服饰；使⽤ WebGL 技术实现 3D 模型⾃定义颜⾊和贴图，实现 3D 服饰定制。</li><li>使⽤ Echarts 绘制可视化⼤屏，展⽰⺠族信息，使⽤ Echarts-gl 实现数据可视化 3D 地图的展⽰。</li><li>性能优化：使⽤模型压缩⼯具 Draco 和模型动态加载；使⽤ SSR、懒加载、gzip 压缩优化⾸屏加载。</li></ol><h3 id="0-项⽬的搭建、配置和部署"><a href="#0-项⽬的搭建、配置和部署" class="headerlink" title="0.项⽬的搭建、配置和部署"></a>0.项⽬的搭建、配置和部署</h3><ol><li><p>Vite 3 - 构建工具（就是快！）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm create vite@latest  [project name] [-- -- temaplate vue]<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//vite.config.js</span><br>css<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  preprocessorOptions<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    scss<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      additionalData<span class="hljs-punctuation">:</span> `@import <span class="hljs-string">&quot;@/assets/scss/variable.scss&quot;</span>;`<br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>resolve<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  alias<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    &#x27;@&#x27;<span class="hljs-punctuation">:</span> resolve(__dirname<span class="hljs-punctuation">,</span> &#x27;./src&#x27;) <span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>server<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-comment">/** 端口号 */</span><br>  port<span class="hljs-punctuation">:</span> <span class="hljs-number">3333</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">/** 跨域设置允许 */</span><br>  cors<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-comment">/** 接口代理 */</span><br>  proxy<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;/api/v1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      target<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://www.fastmock.site/mock/761e2dda2b8890ab86c928a74e8f6538&quot;</span><span class="hljs-punctuation">,</span><br>      ws<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">/** 是否允许跨域 */</span><br>      changeOrigin<span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>build<span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>pligin<span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>Vue 3 - 渐进式 JavaScript 框架</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── dist/<br>└── <span class="hljs-attribute">src</span>/<br>    ├── api/                       <span class="hljs-comment">// 接口请求目录</span><br>    ├── assets/                    <span class="hljs-comment">// 静态资源目录</span><br>    ├── common/                    <span class="hljs-comment">// 通用类库目录</span><br>    ├── components/                <span class="hljs-comment">// 公共组件目录</span><br>    ├── router/                    <span class="hljs-comment">// 路由配置目录</span><br>    ├── store/                     <span class="hljs-comment">// 状态管理目录</span><br>    ├── style/                     <span class="hljs-comment">// 通用样式目录</span><br>    ├── utils/                     <span class="hljs-comment">// 工具函数目录</span><br>    ├── views/                     <span class="hljs-comment">// 页面组件目录</span><br>    ├── App<span class="hljs-selector-class">.vue</span><br>    ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span><br>├── tests/                         <span class="hljs-comment">// 单元测试目录</span><br>├── index<span class="hljs-selector-class">.html</span><br>├── jsconfig<span class="hljs-selector-class">.json</span>                  <span class="hljs-comment">// JavaScript 配置文件</span><br>├── vite<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>                 <span class="hljs-comment">// Vite 配置文件</span><br>└── package.json<br></code></pre></td></tr></table></figure></li><li><p>Vue Router - 官方路由管理器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i vue-router<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-keyword">const</span> routes = []<br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure></li><li><p>Pinia - 值得你喜欢的 Vue Store</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i pinia<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createPinia</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store<br><br><span class="hljs-comment">//modules</span><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;counter&#x27;</span>, &#123;&#125;)<br></code></pre></td></tr></table></figure></li><li><p>Scss - CSS 预处理器</p></li><li><p>Axios - 一个基于 promise 的网络请求库，可以用于浏览器和 node.js</p></li><li><p>EditorConfig + ESLint + Prettier + Stylelint - 代码规范</p></li><li><p>GitHub Actions - 自动部署</p></li></ol><h3 id="1-渲染-3D-模型的步骤"><a href="#1-渲染-3D-模型的步骤" class="headerlink" title="1. 渲染 3D 模型的步骤"></a>1. 渲染 3D 模型的步骤</h3><ol><li><p>创建场景(设置背景颜色)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>()<br>scene.<span class="hljs-property">background</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(<span class="hljs-number">0xf6f6f6</span>)<br></code></pre></td></tr></table></figure></li><li><p>创建相机()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> camera = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PerspectiveCamera</span>(<br>  <span class="hljs-number">20</span>, <span class="hljs-comment">//视野角度</span><br>  <span class="hljs-title class_">Width</span> / <span class="hljs-title class_">Height</span>, <span class="hljs-comment">//长宽比</span><br>  <span class="hljs-number">1</span>, <span class="hljs-comment">//近截面</span><br>  <span class="hljs-number">1000</span> <span class="hljs-comment">//远截面</span><br>)<br><span class="hljs-comment">// 设置相机位置</span><br>camera.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">35</span>) <span class="hljs-comment">//x:右侧为正，y:上侧为正，z:屏幕内为正</span><br>camera.<span class="hljs-title function_">lookAt</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">//相机焦点位置</span><br></code></pre></td></tr></table></figure></li><li><p>创建渲染器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//实例化一个WebGL渲染器对象。</span><br><span class="hljs-keyword">let</span> renderer = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">WebGLRenderer</span>(&#123; <span class="hljs-attr">alpha</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">antialias</span>: <span class="hljs-literal">true</span> &#125;) <span class="hljs-comment">//antialias:抗锯齿</span><br>renderer.<span class="hljs-title function_">setSize</span>(<span class="hljs-title class_">Width</span>, <span class="hljs-title class_">Height</span>) <span class="hljs-comment">//设置Canvas画布尺寸</span><br></code></pre></td></tr></table></figure></li><li><p>加载模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入gltf模型加载库GLTFLoader.js</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GLTFLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/loaders/GLTFLoader.js&#x27;</span><br><span class="hljs-comment">// loader 实例化加载器</span><br><span class="hljs-keyword">let</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>()<br><span class="hljs-comment">// 加载gltf模型</span><br>loader.<span class="hljs-title function_">load</span>(<br>  <span class="hljs-string">&#x27;模型地址&#x27;</span>,<br>  <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// gltf.scene是gltf模型的场景对象</span><br>    scene.<span class="hljs-title function_">add</span>(gltf.<span class="hljs-property">scene</span>)<br>  &#125;,<br>  进度计算,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure></li><li><p>加载场景控制插件</p><blockquote><p>OrbitControls 本质上就是改变相机的参数，比如相机的位置属性，</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">OrbitControls</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/controls/OrbitControls.js&#x27;</span><br><span class="hljs-keyword">let</span> controls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrbitControls</span>(camera, renderer.<span class="hljs-property">domElement</span>) <span class="hljs-comment">//</span><br><span class="hljs-title class_">Setcontrols</span>(controls) <span class="hljs-comment">// 设置控制器</span><br><span class="hljs-comment">// 设置控制器</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Setcontrols</span> = (<span class="hljs-params">controls</span>) =&gt; &#123;<br>  controls.<span class="hljs-property">enableDamping</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//是否开启惯性</span><br>  controls.<span class="hljs-property">dampingFactor</span> = <span class="hljs-number">0.05</span> <span class="hljs-comment">//惯性阻尼系数(灵敏度)</span><br>  controls.<span class="hljs-property">enableZoom</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//是否可以缩放</span><br>  controls.<span class="hljs-property">autoRotate</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//是否自动旋转</span><br>  controls.<span class="hljs-property">autoRotateSpeed</span> = <span class="hljs-number">3</span> <span class="hljs-comment">//自动旋转速度</span><br>  controls.<span class="hljs-property">enablePan</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//是否开启右键拖拽</span><br>  controls.<span class="hljs-property">enableKeys</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//是否开启键盘控制</span><br>  controls.<span class="hljs-property">keyPanSpeed</span> = <span class="hljs-number">7</span> <span class="hljs-comment">//键盘移动速度</span><br>  controls.<span class="hljs-property">minDistance</span> = <span class="hljs-number">15</span> <span class="hljs-comment">//最小缩放值</span><br>  controls.<span class="hljs-property">maxDistance</span> = <span class="hljs-number">35</span> <span class="hljs-comment">//最大缩放值</span><br>  <span class="hljs-comment">// 键盘控制</span><br>  controls.<span class="hljs-property">keys</span> = &#123;<br>    <span class="hljs-attr">LEFT</span>: <span class="hljs-number">37</span>, <span class="hljs-comment">//左键</span><br>    <span class="hljs-attr">UP</span>: <span class="hljs-number">38</span>, <span class="hljs-comment">//上键</span><br>    <span class="hljs-attr">RIGHT</span>: <span class="hljs-number">39</span>, <span class="hljs-comment">//右键</span><br>    <span class="hljs-attr">BOTTOM</span>: <span class="hljs-number">40</span>, <span class="hljs-comment">//下键</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加光源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加平行光</span><br><span class="hljs-keyword">const</span> directionalLight1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-number">0xf6f6f6</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">//颜色，强度</span><br>directionalLight1.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">//位置</span><br></code></pre></td></tr></table></figure></li><li><p>渲染场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 渲染场景</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">requestAnimationFrame</span>(animate) <span class="hljs-comment">//请求动画帧</span><br>  renderer.<span class="hljs-title function_">render</span>(scene, camera)<br>&#125;<br><span class="hljs-title function_">animate</span>()<br></code></pre></td></tr></table></figure></li><li><p>渲染器输出的 canvas 对象添加到 dom 元素中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;webgl&#x27;</span>)<br>app.<span class="hljs-title function_">appendChild</span>(renderer.<span class="hljs-property">domElement</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-纹理贴图"><a href="#2-纹理贴图" class="headerlink" title="2. 纹理贴图"></a>2. 纹理贴图</h3><ol><li><p>创建纹理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 纹理贴图</span><br><span class="hljs-keyword">let</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>()<br><span class="hljs-keyword">let</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/img/background.png&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>创建材质</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加子模块材质到渲染队列</span><br>obj.<span class="hljs-property">scene</span>.<span class="hljs-title function_">traverse</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) &#123;<br>  <span class="hljs-keyword">if</span> (child.<span class="hljs-property">isMesh</span> &amp;&amp; (child.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;����11&#x27;</span> || child.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;球体&#x27;</span>)) &#123;<br>    meshChildrenName.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>([<br>      child.<span class="hljs-property">name</span> === <span class="hljs-string">&#x27;球体&#x27;</span> ? <span class="hljs-string">&#x27;饰品&#x27;</span> : <span class="hljs-string">&#x27;上衣&#x27;</span>,<br>      child.<span class="hljs-property">material</span>,<br>    ])<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>渲染纹理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置纹理</span><br>value.<span class="hljs-property">value</span>[<span class="hljs-number">1</span>].<span class="hljs-property">map</span> = texture<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-Echarts-x2F-Echarts-gl"><a href="#3-Echarts-x2F-Echarts-gl" class="headerlink" title="3. Echarts&#x2F;Echarts-gl"></a>3. Echarts&#x2F;Echarts-gl</h3><ol><li><p>引入 Echarts</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> chartDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;main&#x27;</span>)<br><span class="hljs-keyword">var</span> myChart = echarts.<span class="hljs-title function_">init</span>(chartDom)<br><span class="hljs-keyword">var</span> option=&#123;<br>  <span class="hljs-attr">title</span>:&#123;&#125;<span class="hljs-comment">//标题组件</span><br>  <span class="hljs-attr">tooltip</span>:&#123;&#125;<span class="hljs-comment">//提示框组件</span><br>  <span class="hljs-attr">legend</span>:&#123;&#125;<span class="hljs-comment">//图例组件</span><br>  <span class="hljs-attr">grid</span>:&#123;&#125;<span class="hljs-comment">//直角坐标系内绘图网格</span><br>  <span class="hljs-attr">xAxis</span>:&#123;&#125;<span class="hljs-comment">//直角坐标系中的横轴</span><br>  <span class="hljs-attr">yAxis</span>:&#123;&#125;<span class="hljs-comment">//直角坐标系中的纵轴</span><br>  <span class="hljs-attr">series</span>:&#123;<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//系列类型</span><br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-comment">//系列名称</span><br>    <span class="hljs-attr">label</span>:&#123;&#125;<span class="hljs-comment">//图形上的文本标签</span><br>    <span class="hljs-attr">data</span>:[]<span class="hljs-comment">//系列中的数据内容数组</span><br>  &#125;<span class="hljs-comment">//系列列表</span><br>&#125;<br>option &amp;&amp; myChart.<span class="hljs-title function_">setOption</span>(option)<br></code></pre></td></tr></table></figure></li><li><p>引入 Echarts-gl</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> chartDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;mainGeo&#x27;</span>)<br><span class="hljs-keyword">var</span> myChart = echarts.<span class="hljs-title function_">init</span>(chartDom)<br>echarts.<span class="hljs-title function_">registerMap</span>(<span class="hljs-string">&#x27;HangZhou&#x27;</span>, mapJson)<br><span class="hljs-keyword">var</span> regions = mapJson.<span class="hljs-property">features</span>.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">feature</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">name</span>: feature.<span class="hljs-property">properties</span>.<span class="hljs-property">name</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">itemStyle</span>: &#123;<br>      <span class="hljs-attr">borderWidth</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-attr">borderColor</span>: <span class="hljs-string">&#x27;#a7bc3a&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">label</span>: &#123;<br>      <span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// Show labels on hover</span><br>      <span class="hljs-attr">formatter</span>: <span class="hljs-string">&#x27;&#123;b&#125;&#x27;</span>, <span class="hljs-comment">// Customize label content</span><br>      <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#1f1f1f&#x27;</span>,<br>    &#125;,<br>  &#125;<br>&#125;)<br><span class="hljs-keyword">var</span> option = &#123;<br>  <span class="hljs-attr">series</span>: [<br>    &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;map3D&#x27;</span>,<br>      <span class="hljs-attr">map</span>: <span class="hljs-string">&#x27;HangZhou&#x27;</span>,<br>      <span class="hljs-attr">data</span>: regions,<br>      <span class="hljs-attr">realisticMaterial</span>: &#123;&#125;, <span class="hljs-comment">//真实感材质</span><br>      <span class="hljs-attr">itemStyle</span>: &#123;&#125;, <span class="hljs-comment">//地图区域的多边形图形样式</span><br>      <span class="hljs-attr">light</span>: &#123;&#125;, <span class="hljs-comment">//光照</span><br>      <span class="hljs-attr">viewControl</span>: &#123;&#125;, <span class="hljs-comment">//地图视角控制</span><br>    &#125;,<br>  ],<br>&#125;<br>option &amp;&amp; myChart.<span class="hljs-title function_">setOption</span>(option)<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-设置解码器-x2F-gzip-压缩"><a href="#4-设置解码器-x2F-gzip-压缩" class="headerlink" title="4. 设置解码器&#x2F;gzip 压缩"></a>4. 设置解码器&#x2F;gzip 压缩</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设置解码器</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">DRACOLoader</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/addons/loaders/DRACOLoader.js&#x27;</span><br><span class="hljs-keyword">const</span> dracoLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DRACOLoader</span>()<br>dracoLoader.<span class="hljs-title function_">setDecoderPath</span>(<span class="hljs-string">&#x27;/js/libs/draco/&#x27;</span>)<br>loader.<span class="hljs-title function_">setDRACOLoader</span>(dracoLoader)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// gzip 压缩</span><br><span class="hljs-comment">// vite.config.js</span><br><span class="hljs-keyword">import</span> viteCompression <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite-plugin-compression&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-title function_">viteCompression</span>()<br>  ]<br>&#125;)<br><br><span class="hljs-comment">//nginx.conf</span><br>http &#123;<br>  gzip on;<br>  gzip_types text/plain application/javascript;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Nuxt3-x2F-SSR"><a href="#5-Nuxt3-x2F-SSR" class="headerlink" title="5. Nuxt3&#x2F;SSR"></a>5. Nuxt3&#x2F;SSR</h3><h4 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h4><blockquote><p>服务器端渲染（Server-Side Rendering）是指由服务端完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p></blockquote><p><strong>优点：</strong></p><ol><li>网页内容在服务器端渲染完成，一次性传输到浏览器，所以 首屏加载速度非常快；</li><li>有利于 SEO，因为服务器返回的是一个完整的 html，在浏览器可以看到完整的 dom，对于爬虫、百度搜索等引擎就比较友好；</li></ol><h4 id="Nuxt3"><a href="#Nuxt3" class="headerlink" title="Nuxt3"></a>Nuxt3</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx nuxi init [project-name]<br></code></pre></td></tr></table></figure><h2 id="2-文献搜索"><a href="#2-文献搜索" class="headerlink" title="2. 文献搜索"></a>2. 文献搜索</h2><p>项⽬描述：基于 uni-app 开发的微信⼩程序。功能包括 pdf ⽂件、图⽚上传，医学⽂献关键词模糊搜索，pdf ⽂件浏览下载。<br>·前端技术栈：微信⼩程序开发、uni-app、uniCloud、Vue3、TypeScript、Scss、vant、axios<br>·项⽬技术：</p><ol><li>对 vant 组件和 uni-ui 组件进⾏封装，提⾼组件的复⽤率并优化⾃定义组件样式和功能。</li><li>⼤⽂件的上传采⽤分⽚上传和断点续传，使⽤ md5 实现⽂件的唯⼀性。</li><li>体验和性能优化：使⽤ Loading 组件，对分包进⾏优化、懒加载、使⽤ uniCloud 的 CDN 进⾏加速。</li></ol><h3 id="1-大文件上传、下载怎么做"><a href="#1-大文件上传、下载怎么做" class="headerlink" title="1. 大文件上传、下载怎么做"></a>1. 大文件上传、下载怎么做</h3><blockquote><p><a href="https://juejin.cn/post/7170977497775865863">https://juejin.cn/post/7170977497775865863</a></p></blockquote><h4 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h4><ol><li>切割文件(通过 slice 方法切割文件,并存放到数组中)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 切割文件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFileChunks</span>(<span class="hljs-params">size</span>) &#123;<br>  <span class="hljs-keyword">const</span> chunks = [] <span class="hljs-comment">//存放切片的数组</span><br>  <span class="hljs-keyword">const</span> chunkCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(size / <span class="hljs-variable constant_">CHUNK_SIZE</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; chunkCount; i++) &#123;<br>    <span class="hljs-comment">// chunks.push(i * CHUNK_SIZE)</span><br>    chunks.<span class="hljs-title function_">push</span>(file.<span class="hljs-title function_">slice</span>((i - <span class="hljs-number">1</span>) * <span class="hljs-variable constant_">CHUNK_SIZE</span>, i * <span class="hljs-variable constant_">CHUNK_SIZE</span>))<br>  &#125;<br>  <span class="hljs-keyword">return</span> chunks<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>md5 计算</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i spark-md5 # 安装spark-md5<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> computedMD5=<span class="hljs-function">(<span class="hljs-params">arr</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SparkMD5</span>.<span class="hljs-title class_">ArrayBuffer</span>()<br>  <span class="hljs-keyword">let</span> currentChunk = <span class="hljs-number">0</span><br>  reader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">e: any</span>) =&gt;</span> &#123;<br>    spark.<span class="hljs-title function_">append</span>(e?.<span class="hljs-property">target</span>?.<span class="hljs-property">result</span>)<br>    currentChunk++<br>    <span class="hljs-keyword">if</span> (currentChunk &lt; chunks.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-title function_">loadNext</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(spark.<span class="hljs-title function_">end</span>())<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr)&#123;<br>    spark.<span class="hljs-title function_">append</span>(i)<br><br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadNext</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> start =<br>      (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(chunks[currentChunk] / <span class="hljs-variable constant_">CHUNK_SIZE</span>) - <span class="hljs-number">1</span>) * <span class="hljs-variable constant_">CHUNK_SIZE</span><br>    <span class="hljs-keyword">const</span> end = chunks[currentChunk]<br>    reader.<span class="hljs-title function_">readAsArrayBuffer</span>(slice.<span class="hljs-title function_">call</span>(file, start, end))<br>  &#125;<br>  <span class="hljs-title function_">loadNext</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-图片异步加载"><a href="#2-图片异步加载" class="headerlink" title="2. 图片异步加载"></a>2. 图片异步加载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oBox = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;box&#x27;</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> oH = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h1&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImageAsync</span>(<span class="hljs-params">url</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript">      image.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">resolve</span>(image)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      image.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Could not load image at &#x27;</span> + url))</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      image.<span class="hljs-property">src</span> = url</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-comment">// 模拟一下异步加载图片</span></span><br><span class="language-javascript">  <span class="hljs-comment">// 用setTimeoutm模拟ajax调用接口，获取接口返回的图片路径，然后传入函数中，函数中已经提前创建好了</span></span><br><span class="language-javascript">  <span class="hljs-comment">// 图片标签。我们在.then的回调函数中自行决定插入div容器中做一些事，比如把缺省图隐藏掉</span></span><br><span class="language-javascript">  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">loadImageAsync</span>(</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;https://img2020.cnblogs.com/blog/2221918/202104/2221918-20210429012928150-1671892053.png&#x27;</span></span><br><span class="language-javascript">    ).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      oH.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span></span><br><span class="language-javascript">      oBox.<span class="hljs-title function_">appendChild</span>(res)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-CDN-加速"><a href="#3-CDN-加速" class="headerlink" title="3. CDN 加速"></a>3. CDN 加速</h3><h2 id="3-⾳乐播放器"><a href="#3-⾳乐播放器" class="headerlink" title="3. ⾳乐播放器"></a>3. ⾳乐播放器</h2><p>项⽬描述：基于 react 开发的⽹⻚端⾳乐播放器。功能包括⽤⼾登录，⼀键更改样式，播放⾳乐，查看和操作⾳乐列表。<br>·前端技术栈：React18、Vite、TypeScript、Styled-Components、Ant Design、Mui、React-Router、Redux、Axios<br>·项⽬技术：</p><ol><li>对 Ant Design 组件进⾏封装，通过 ConfigProvider 配置主题；使⽤ Mui ⾃定义配置⽣成主题，配合 styled 实现⼀键切换主题。</li><li>使⽤ Redux 存储歌词和歌单信息，实现歌词滚动监听，实现歌曲⾃动播放。</li><li>性能优化：函数式组件全部采⽤<code>memo</code>、路由懒加载、函数防抖。</li></ol><h3 id="1-memo"><a href="#1-memo" class="headerlink" title="1. memo"></a>1. memo</h3><blockquote><p>在 react 的一般规则中，只有父组件的某一个状态改变，父组件下面所有的子组件不论是否使用了该状态，都会进行重新渲染。<br>memo 是 react 的一种缓存技术，这个函数可以检测从父组件接收的 props,并且在父组件改变 state 的时候比对这个 state 是否是本组件在使用，如果不是，则拒绝重新渲染。</p></blockquote><h1 id="1-HTML"><a href="#1-HTML" class="headerlink" title="1. HTML"></a>1. HTML</h1><h1 id="2-CSS"><a href="#2-CSS" class="headerlink" title="2. CSS"></a>2. CSS</h1><h2 id="1-实现水平垂直居中的方案"><a href="#1-实现水平垂直居中的方案" class="headerlink" title="1. 实现水平垂直居中的方案"></a>1. 实现水平垂直居中的方案</h2><h3 id="1-flex"><a href="#1-flex" class="headerlink" title="1 flex"></a>1 flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.flex+margin */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.flex */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-绝对定位"><a href="#2-绝对定位" class="headerlink" title="2 绝对定位"></a>2 绝对定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleHeight);<br>  <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleWeight);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-grid"><a href="#3-grid" class="headerlink" title="3 grid"></a>3 grid</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.grid */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-table"><a href="#4-table" class="headerlink" title="4 table"></a>4 table</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-css-优先级"><a href="#2-css-优先级" class="headerlink" title="2. css 优先级"></a>2. css 优先级</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ol><li>基本选择器：<br>&#x2F;ID 选择器(#id)&#x2F;类选择器(.class)&#x2F;属性选择器([attr])&#x2F;标签选择器(div)&#x2F;通配符选择器(*)</li><li>伪选择器：<br>&#x2F;伪类(.class::hover)&#x2F;伪元素(div::before)</li><li>分组选择器</li><li>组合器<br>&#x2F;子选择器(div&gt;p)&#x2F;兄弟选择器(div+p)</li></ol><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol start="0"><li>第一优先级：!important 会覆盖页面内任何位置的元素样式</li><li>内联样式，如 style&#x3D;”color: green”，权值为 1000</li><li>ID 选择器，如#app，权值为 0100</li><li>类、伪类、属性选择器，如.foo, :first-child, div[class&#x3D;”foo”]，权值为 0010</li><li>标签、伪元素选择器，如 div::first-line，权值为 0001</li><li>通配符、子类选择器、兄弟选择器，如*, &gt;, +，权值为 0000</li><li>继承的样式没有权值</li></ol><h2 id="3-flex-布局的常用属性"><a href="#3-flex-布局的常用属性" class="headerlink" title="3. flex 布局的常用属性"></a>3. flex 布局的常用属性</h2><h3 id="容器属性："><a href="#容器属性：" class="headerlink" title="容器属性："></a>容器属性：</h3><pre><code class="hljs">1.flex-direction /2.flex-wrap /3.flex-flow /4.justify-content /5.align-items /6.align-content</code></pre><h4 id="4-1-flex-direction"><a href="#4-1-flex-direction" class="headerlink" title="4.1 flex-direction"></a>4.1 flex-direction</h4><blockquote><p>属性决定主轴方向，默认横向 row</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-flex-wrap"><a href="#4-2-flex-wrap" class="headerlink" title="4.2 flex-wrap"></a>4.2 flex-wrap</h4><blockquote><p>flex 元素单行显示还是多行显示。若允许换行，这个属性允许你控制元素的堆叠方向。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-flex-flow"><a href="#4-3-flex-flow" class="headerlink" title="4.3 flex-flow"></a>4.3 flex-flow</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-justify-content"><a href="#4-4-justify-content" class="headerlink" title="4.4 justify-content"></a>4.4 justify-content</h4><blockquote><p>定义了元素在弹性容器主轴上的对齐方式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around<br>    | space-evenly;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-align-items"><a href="#4-5-align-items" class="headerlink" title="4.5 align-items"></a>4.5 align-items</h4><blockquote><p>元素在弹性容器交叉轴上的对齐方式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">stretch(默认值):如果被排列的项目未设置高度（宽度）或设置为auto，项目将占满整个容器的高度（宽度）</span><br><span class="hljs-comment">baseline：项目的第一行文字的基线对齐</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="4-6-align-content"><a href="#4-6-align-content" class="headerlink" title="4.6 align-content"></a>4.6 align-content</h4><blockquote><p>定义了多跟轴线的对齐方式，如果只有一根轴线则属性不起作用</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | stretch | space-between |<br>    space-around;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">stretch(默认值):如果被排列的项目未设置高度（宽度）或设置为auto，项目将占满整个容器的高度（宽度）</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="容器成员属性"><a href="#容器成员属性" class="headerlink" title="容器成员属性"></a>容器成员属性</h3><pre><code class="hljs">1.order /2.flex-grow /3.flex-shrink /4.flex-basis /5.flex /6.align-self</code></pre><h2 id="4-重排和重绘，如何减少重排"><a href="#4-重排和重绘，如何减少重排" class="headerlink" title="4. 重排和重绘，如何减少重排"></a>4. 重排和重绘，如何减少重排</h2><blockquote><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置<br>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p></blockquote><h3 id="回流触发时机"><a href="#回流触发时机" class="headerlink" title="回流触发时机"></a>回流触发时机</h3><blockquote><p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p></blockquote><ol><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li><li>页面一开始渲染的时候（这避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的</li></ol><h3 id="重绘触发时机"><a href="#重绘触发时机" class="headerlink" title="重绘触发时机"></a>重绘触发时机</h3><blockquote><p>触发回流一定会触发重绘</p></blockquote><ol><li>颜色的修改</li><li>文本方向的修改</li><li>阴影的修改</li></ol><h3 id="减少回流重绘性能消耗"><a href="#减少回流重绘性能消耗" class="headerlink" title="减少回流重绘性能消耗"></a>减少回流重绘性能消耗</h3><ol><li>如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)<br>避免设置多项内联样式</li><li>应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)</li><li>避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算</li><li>对于那些复杂的动画，对其设置 position: fixed&#x2F;absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li><li>使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘</li><li>避免使用 CSS 的 JavaScript 表达式</li></ol><h2 id="5-css-伪类与伪元素的区别"><a href="#5-css-伪类与伪元素的区别" class="headerlink" title="5. css 伪类与伪元素的区别"></a>5. css 伪类与伪元素的区别</h2><blockquote><p>伪类是选择器的一种，它用于选择处于特定状态的元素<br>:hover&#x2F;:active&#x2F;:focus&#x2F;:first-child&#x2F;:last-child&#x2F;:nth-child(n)<br>伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样<br>::before&#x2F;::after&#x2F;::first-letter&#x2F;::first-line</p></blockquote><h2 id="6-position-属性"><a href="#6-position-属性" class="headerlink" title="6. position 属性"></a>6. position 属性</h2><ol><li>static</li><li>relative</li><li>absolute</li><li>fixed</li><li>sticky</li></ol><h2 id="7-清除浮动的方法，为什么要清除浮动"><a href="#7-清除浮动的方法，为什么要清除浮动" class="headerlink" title="7. 清除浮动的方法，为什么要清除浮动"></a>7. 清除浮动的方法，为什么要清除浮动</h2><blockquote><p>浮动其实是指元素从网页的正常流动中移除，即脱离文档流。选择将元素在其容器的左侧或右侧放置其实就是指元素在脱离文档流之后，元素一直向最左边或者右边靠拢，直至碰到父元素或者另一个浮动元素。</p></blockquote><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><blockquote><p>在父盒子未设置高度时，子盒子又设置了浮动，导致父盒子高度塌陷</p></blockquote><h3 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h3><ol><li><p>其实就是在父盒子的浮动子盒子之后加入一个额外的块级盒子，为其设置属性 clear:both</p></li><li><p>after 伪元素清除浮动（推荐）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">parent<span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">background-color</span>: salmon;<br>  <span class="hljs-attribute">clear</span>: both;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>为父级元素添加双伪元素（推荐）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#two</span><span class="hljs-selector-pseudo">::before</span>,<br><span class="hljs-selector-id">#two</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-id">#two</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>bfc</p></li></ol><h2 id="8-BFC"><a href="#8-BFC" class="headerlink" title="8. BFC"></a>8. BFC</h2><blockquote><p>BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：<br>BFC 目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素</p></blockquote><ol><li>内部的盒子会在垂直方向上一个接一个的放置</li><li>对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li><li>BFC 可以包含浮动元素，并防止浮动元素溢出到容器外面。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li></ol><h3 id="触发-BFC-的条件包含不限于："><a href="#触发-BFC-的条件包含不限于：" class="headerlink" title="触发 BFC 的条件包含不限于："></a>触发 BFC 的条件包含不限于：</h3><ol><li>根元素，即 HTML 元素</li><li>浮动元素：float 值为 left、right</li><li>overflow 值不为 visible，为 auto、scroll、hidden</li><li>display 的值为 inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol><li>清除浮动：当一个父容器包含多个浮动元素时，可以将其设置为 BFC，防止浮动元素溢出到外面。</li><li>解决 margin 重叠问题：当两个元素的 margin 发生重叠时，可以将其中之一包裹在一个 BFC 中，使其 margin 与外部元素分离。</li><li>实现多列布局：使用 column-count 和 column-gap 属性可以让文本内容自动分为多列，但这需要在 BFC 中实现。</li></ol><h2 id="9-如何实现单行／多行文本溢出的省略样式？"><a href="#9-如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="9. 如何实现单行／多行文本溢出的省略样式？"></a>9. 如何实现单行／多行文本溢出的省略样式？</h2><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><ol><li>text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本</li><li>white-space：设置文字在一行显示，不能换行</li><li>overflow：文字长度超出限定宽度，则隐藏超出的内容</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h3><ol><li>基于高度截断<blockquote><p>实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 overflow: hidden 隐藏多余文字</p></blockquote></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.demo</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;...&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>基于行数截断</p><ol><li>-webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性）</li><li>display: -webkit-box：和 1 结合使用，将对象作为弹性伸缩盒子模型显示</li><li>-webkit-box-orient: vertical：和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式</li><li>overflow: hidden：文本溢出限定的宽度就隐藏内容</li><li>text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  -webkit-line-clamp: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-box-orient: vertical;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="10-offsetWidth、clientWidth、scrollWidth、offsetHeight、clientHeight、scrollHeight"><a href="#10-offsetWidth、clientWidth、scrollWidth、offsetHeight、clientHeight、scrollHeight" class="headerlink" title="10. offsetWidth、clientWidth、scrollWidth、offsetHeight、clientHeight、scrollHeight"></a>10. offsetWidth、clientWidth、scrollWidth、offsetHeight、clientHeight、scrollHeight</h2><ol><li>offsetWidth&#x2F;offsetHeight：(除了外边距(margin)以外，所有的宽度(高度)之和)元素的宽度&#x2F;高度(content)</li></ol><ul><li>包括元素的边框(border)、内边距和滚动条(padding)，但不包括外边距(margin)</li></ul><ol start="2"><li>clientWidth&#x2F;clientHeight：视口尺寸。只包含本身宽度(width)和内边距(padding)；</li></ol><ul><li>元素的宽度&#x2F;高度(content)，包括内边距(padding)，但不包括边框(border)和滚动条</li></ul><ol start="3"><li>scrollWidth&#x2F;scrollHeight：只包含本身宽度(width)和内边距(padding)， 如果有滚动的溢出视口之外的内容，就加上该距离</li></ol><ul><li>元素的实际内容的宽度&#x2F;高度，包括溢出的部分，不包括边框(border)和滚动条</li></ul><h1 id="2-5-浏览器"><a href="#2-5-浏览器" class="headerlink" title="2.5 浏览器"></a>2.5 浏览器</h1><h2 id="1-深入理解浏览器事件模型的概念和原理"><a href="#1-深入理解浏览器事件模型的概念和原理" class="headerlink" title="1.深入理解浏览器事件模型的概念和原理"></a>1.深入理解浏览器事件模型的概念和原理</h2><blockquote><p>浏览器事件模型是指<code>浏览器处理事件的机制</code>。在 Web 应用中，<code>用户的交互和操作都会触发事件</code>，如点击、滚动、键盘输入等。<code>浏览器需要对这些事件进行捕获、处理和分发</code>，以实现相应的功能和效果。<code>浏览器事件模型</code>定义了<code>事件的流程</code>和<code>机制</code>，包括事件的<code>类型</code>、事件的<code>触发</code>和<code>传递</code>、事件的<code>处理</code>和<code>响应</code>等。</p></blockquote><h3 id="浏览器事件类型"><a href="#浏览器事件类型" class="headerlink" title="浏览器事件类型"></a>浏览器事件类型</h3><ol><li>DOM0 级事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//DOM0级事件模型的缺点是只能为一个元素添加一个事件处理函数，且不能对事件进行捕获和阻止冒泡。</span><br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, DOM0!&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>DOM2 级事件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//DOM2级事件模型的优点是可以为一个元素添加多个事件处理函数，且可以对事件进行捕获和阻止冒泡。</span><br>btn.<span class="hljs-title function_">addEventListener</span>(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, DOM2!&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>)<br></code></pre></td></tr></table></figure><ol start="3"><li>IE 事件模型。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//IE事件模型是IE浏览器独有的事件模型,IE事件模型的缺点是只能为一个元素添加一个事件处理函数，且不能对事件进行捕获和阻止冒泡。</span><br>btn.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Hello, IE!&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="浏览器事件模型的流程"><a href="#浏览器事件模型的流程" class="headerlink" title="浏览器事件模型的流程"></a>浏览器事件模型的流程</h3><blockquote><p>浏览器事件模型的流程可以分为事件捕获、目标阶段和事件冒泡三个阶段。下面结合代码来详细说明浏览器事件模型的流程。<br>addEventListener()方法的第三个参数可以设置为 true 或 false，分别表示在捕获阶段或冒泡阶段执行事件处理函数。默认值为 false，表示在冒泡阶段执行事件处理函数。</p></blockquote><ol><li>事件捕获阶段<br>浏览器从最外层的元素 outer 开始，向内层元素 inner 传递事件，直到目标元素 btn。在这个过程中，浏览器会依次触发 outer 元素和 inner 元素的捕获阶段事件处理函数。</li></ol><p>因为我们在 outer 元素和 inner 元素上都定义了捕获阶段事件处理函数，所以浏览器会先执行 outer 元素的捕获阶段事件处理函数，再执行 inner 元素的捕获阶段事件处理函数。因此，控制台会输出’outer capture’和’inner capture’。</p><ol start="2"><li><p>目标阶段<br>当浏览器到达目标元素 btn 时，会触发 btn 元素的点击事件处理函数。在这个例子中，我们在按钮的点击事件处理函数中调用了 event.stopPropagation()方法，以阻止事件继续传递到下一层元素。因此，控制台只会输出’button click’，而不会输出’inner bubble’和’outer bubble’。</p></li><li><p>事件冒泡阶段<br>当事件处理完成后，浏览器会从目标元素 btn 开始，向外层元素 inner 和 outer 传递事件，直到最外层的元素。在这个过程中，浏览器会依次触发 inner 元素和 outer 元素的冒泡阶段事件处理函数。</p></li></ol><p>因为我们在 inner 元素和 outer 元素上都定义了冒泡阶段事件处理函数，所以浏览器会先执行 inner 元素的冒泡阶段事件处理函数，再执行 outer 元素的冒泡阶段事件处理函数。因此，控制台会输出’inner bubble’和’outer bubble’。</p><p>综上所述，浏览器事件模型的流程包括事件捕获、目标阶段和事件冒泡三个阶段。在实际开发中，我们可以根据具体的需求和场景，选择合适的阶段和处理函数，以实现事件的处理和响应。</p><h3 id="浏览器事件优化"><a href="#浏览器事件优化" class="headerlink" title="浏览器事件优化"></a>浏览器事件优化</h3><ol><li>事件委托</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>)<br>list.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;LI&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 用户点击了列表项</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>防抖和节流</li></ol><h1 id="3-JavaScript"><a href="#3-JavaScript" class="headerlink" title="3. JavaScript"></a>3. JavaScript</h1><h2 id="1-this-了解多少，箭头函数的-this-为什么在定义时就已经确定"><a href="#1-this-了解多少，箭头函数的-this-为什么在定义时就已经确定" class="headerlink" title="1. this 了解多少，箭头函数的 this 为什么在定义时就已经确定"></a>1. this 了解多少，箭头函数的 this 为什么在定义时就已经确定</h2><blockquote><p>声明时绑定的意思是它要确定到其上一层去做一个 this 重定向的处理。运行时确定是指其上一层的 this 是受运行时调用者影响的，那么箭头函数继承至该 this，自然也会受到影响。<br>也就是说：声明时确定继承自谁的 this、运行时真正确定是哪个 this</p></blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><blockquote><p>在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定）<br>this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象<br>同时，this 在函数执行过程中，this 一旦被确定了，就不可以再更改</p></blockquote><h3 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h3><p>new 绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p><ol><li><p>默认绑定</p><blockquote><p>全局对象、普通函数中的 this 指向 window</p></blockquote></li><li><p>隐式绑定</p><blockquote><p>对象中的函数中的 this 指向上一级对象</p></blockquote></li><li><p>new 绑定</p><blockquote><p>构造函数中的 this 指向实例对象</p></blockquote></li><li><p>显示绑定</p><blockquote><p>call&#x2F;apply&#x2F;bind</p></blockquote></li></ol><h2 id="2-js-事件循环"><a href="#2-js-事件循环" class="headerlink" title="2. js 事件循环"></a>2. js 事件循环</h2><blockquote><p>执行全局主线程代码，遇到宏任务时，将其放入宏任务队列中;遇到微任务时，将其放入微任务队列中;主线程代码执行完毕后，先执行所有微任务，直到微任务队列为空为止。取出宏任务队列中的第一个任务，执行它，并重复步骤 2 和步骤 3，直到宏任务队列为空为止。</p></blockquote><h3 id="单线程-JS"><a href="#单线程-JS" class="headerlink" title="单线程 JS"></a>单线程 JS</h3><blockquote><p>首先，JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p></blockquote><p><strong>原因：</strong>作为浏览器脚本语言，JavaScript 的主要用途是与用户互动和操作 DOM。在单线程模式下，同一时间只能做一件事情，这样可以避免复杂性并简化同步问题。例如，如果 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，而另一个线程试图删除这个节点，这将导致浏览器无法确定应该以哪个线程为准，从而可能<code>引起 DOM 渲染的冲突</code>。为了避免这种情况，从 JavaScript 一开始就被设计为单线程语言</p><h3 id="执行栈（Call-Stack）："><a href="#执行栈（Call-Stack）：" class="headerlink" title="执行栈（Call Stack）："></a>执行栈（Call Stack）：</h3><ol><li>JavaScript 是单线程执行的，所有的代码都执行在一个主线程上，这个主线程拥有一个执行栈（Call Stack）来记录执行的上下文。</li><li>函数调用会将执行上下文推入执行栈，函数执行完毕后将其从栈中弹出。</li></ol><h3 id="任务队列（Task-Queue）："><a href="#任务队列（Task-Queue）：" class="headerlink" title="任务队列（Task Queue）："></a>任务队列（Task Queue）：</h3><ol><li>任务队列用于存储异步任务的回调函数。</li><li>当异步任务完成时，其回调函数会被放入任务队列中等待执行。</li></ol><h3 id="在-JavaScript-中，所有的任务都可以分为"><a href="#在-JavaScript-中，所有的任务都可以分为" class="headerlink" title="在 JavaScript 中，所有的任务都可以分为"></a>在 JavaScript 中，所有的任务都可以分为</h3><ol><li><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p></li><li><p>异步任务：异步执行的任务，比如 ajax 网络请求，setTimeout 定时函数等</p><blockquote><p>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中<br>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</p></blockquote><ul><li>微任务：Promise、process.nextTick、MutationObserver</li><li>宏任务：script、setTimeout、setInterval、I&#x2F;O、UI rendering</li></ul></li></ol><h2 id="3-js-的基础类型，堆内存和栈内存-类型判断"><a href="#3-js-的基础类型，堆内存和栈内存-类型判断" class="headerlink" title="3. js 的基础类型，堆内存和栈内存,类型判断"></a>3. js 的基础类型，堆内存和栈内存,类型判断</h2><blockquote><p>两种类型：</p></blockquote><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li>Number</li><li>String</li><li>Boolean</li><li>Undefined</li><li>null</li><li>symbol:符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险</li></ol><h3 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h3><ol><li>Object</li><li>Array</li><li>Function</li></ol><h3 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h3><ul><li>基本数据类型存储在栈中</li><li>引用类型的对象存储于堆中</li></ul><h3 id="类型判读-4-种方法"><a href="#类型判读-4-种方法" class="headerlink" title="类型判读 4 种方法"></a>类型判读 4 种方法</h3><ol><li><p>typeof</p><blockquote><p>可以识别出了 null 的基础数据类型，对引用数据类型除了函数以外，都会显示 object</p></blockquote></li><li><p>instanceof</p><blockquote><p><code>a instanceof b</code> 判断 a 是不是 b 类的实例，只可用来判断引用数据<br>实现思路： b 的原型对象是否是 a 的原型链上的某个对象</p></blockquote></li><li><p>constructor</p><blockquote><p><code>a.constructor === b</code>constructor 指向创建该实例对象的构造函数<br>注意 null 和 undefined 没有 constructor，以及 constructor 可以被改写，不太可靠</p></blockquote></li><li><p>String.prototype.toString.call()</p></li></ol><h2 id="4-垃圾回收机制"><a href="#4-垃圾回收机制" class="headerlink" title="4. 垃圾回收机制"></a>4. 垃圾回收机制</h2><blockquote><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存</p></blockquote><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p><p>通常情况下有两种实现方式：</p><ol><li><p>标记清除</p><blockquote><p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p></blockquote></li><li><p>引用计数</p><blockquote><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放</p></blockquote></li></ol><h2 id="5-介绍浅拷贝和深拷贝的区别"><a href="#5-介绍浅拷贝和深拷贝的区别" class="headerlink" title="5. 介绍浅拷贝和深拷贝的区别"></a>5. 介绍浅拷贝和深拷贝的区别</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p></blockquote><ol><li>如果属性是<code>基本类型</code>，拷贝的就是基本类型的<code>值</code>。如果属性是<code>引用类型</code>，拷贝的就是<code>内存地址</code></li><li>即浅拷贝是<code>拷贝一层</code>，深层次的引用类型则<code>共享内存地址</code></li></ol><h4 id="实现浅拷贝的方法"><a href="#实现浅拷贝的方法" class="headerlink" title="实现浅拷贝的方法"></a>实现浅拷贝的方法</h4><ol><li>Object.assign<br><code>const newObj = Object.assign(&#123;&#125;, obj);</code></li><li>Array.prototype.slice(), Array.prototype.concat()<br><code>const newArr = arr.slice(0)</code> <code>const newArr = arr.concat()</code></li><li>使用拓展运算符实现的复制<br><code>const newArr = [...arr]</code></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝开辟一个<code>新的栈</code>，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p></blockquote><h4 id="实现深拷贝的方法"><a href="#实现深拷贝的方法" class="headerlink" title="实现深拷贝的方法"></a>实现深拷贝的方法</h4><ol><li>_.cloneDeep()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><span class="hljs-keyword">const</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1)<br></code></pre></td></tr></table></figure><ol start="2"><li>jQuery.extend()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>)<br><span class="hljs-keyword">const</span> obj2 = $.<span class="hljs-title function_">extend</span>(<span class="hljs-literal">true</span>, &#123;&#125;, obj1)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>JSON.stringify()</p><blockquote><p>会忽略 undefined、symbol 和函数</p></blockquote><p><code>const obj2=JSON.parse(JSON.stringify(obj1));</code></p></li></ol><p>4 .手写循环递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-介绍一下作用域的概念，有哪些类型的作用域"><a href="#6-介绍一下作用域的概念，有哪些类型的作用域" class="headerlink" title="6. 介绍一下作用域的概念，有哪些类型的作用域"></a>6. 介绍一下作用域的概念，有哪些类型的作用域</h2><blockquote><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合<br>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p></blockquote><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span><br>  <span class="hljs-title function_">foo</span>()<br>&#125;<br><span class="hljs-title function_">bar</span>() <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><p>当在 Javascript 中使用一个变量的时候，首先 Javascript 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域<br>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p></blockquote><h2 id="7-介绍一下-Promise-的状态，应用场景"><a href="#7-介绍一下-Promise-的状态，应用场景" class="headerlink" title="7. 介绍一下 Promise 的状态，应用场景"></a>7. 介绍一下 Promise 的状态，应用场景</h2><blockquote><p>Promise 是异步编程的一种解决方案,解决了回调地狱的问题</p></blockquote><h3 id="Promise-的基本特性"><a href="#Promise-的基本特性" class="headerlink" title="Promise 的基本特性"></a>Promise 的基本特性</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ol><li>pending（进行中）</li><li>fulfilled（已成功）</li><li>rejected（已失败）</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变（从 pending 变为 fulfilled 和从 pending 变为 rejected），就不会再变，任何时候都可以得到这个结果</li></ol><h3 id="Promise-的基本用法"><a href="#Promise-的基本用法" class="headerlink" title="Promise 的基本用法"></a>Promise 的基本用法</h3><p><code>const promise = new Promise(function(resolve, reject) &#123;&#125;);</code></p><blockquote><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject<br>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”<br>reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败</p></blockquote><h4 id="Promise-实例方法"><a href="#Promise-实例方法" class="headerlink" title="Promise 实例方法"></a>Promise 实例方法</h4><ol><li><p>then()<br>then 是实例状态发生改变时的回调函数，第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数</p></li><li><p>catch()<br>catch 是 then(null, rejection)的别名，用于指定发生错误时的回调函数</p></li><li><p>finally()<br>不管 Promise 对象最后状态如何，都会执行的操作</p></li></ol><h4 id="Promise-类-构造函数-方法"><a href="#Promise-类-构造函数-方法" class="headerlink" title="Promise 类(构造函数)方法"></a>Promise 类(构造函数)方法</h4><ol><li>Promise.all()<br>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例<br><code>const p = Promise.all([p1, p2, p3]);</code></li></ol><p>实例 p 的状态由 p1、p2、p3 决定，分为两种：</p><ul><li>只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数</li><li>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数</li></ul><ol start="2"><li>Promise.race()<br>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</li></ol><p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变<br>率先改变的 Promise 实例的返回值则传递给 p 的回调函数</p><ol start="3"><li>allSettled()<blockquote><p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p></blockquote></li></ol><p>只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束</p><ol start="4"><li><p>resolve()</p><blockquote><p>Promise.resolve()方法将现有对象转为 Promise 对象</p></blockquote></li><li><p>reject()</p><blockquote><p>Promise.reject()方法也会返回一个新的 Promise 实例，该实例的状态为 rejected</p></blockquote></li></ol><h2 id="8-xss-攻击-x2F-csrf-攻击"><a href="#8-xss-攻击-x2F-csrf-攻击" class="headerlink" title="8. xss 攻击&#x2F;csrf 攻击"></a>8. xss 攻击&#x2F;csrf 攻击</h2><h3 id="1-XSS-Cross-Site-Scripting-跨站脚本攻击"><a href="#1-XSS-Cross-Site-Scripting-跨站脚本攻击" class="headerlink" title="1. XSS (Cross Site Scripting) 跨站脚本攻击"></a>1. XSS (Cross Site Scripting) 跨站脚本攻击</h3><blockquote><p>XSS，跨站脚本攻击，允许攻击者将<code>恶意代码植入</code>到提供给其它<code>用户使用的页面</code>中</p></blockquote><ul><li>XSS 的攻击目标是为了<code>盗取存储在客户端的cookie</code>或者其他网站用于<code>识别客户端身份的敏感信息</code>。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</li></ul><ol><li><p>存储型</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li><li><p>反射型</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li><li><p>DOM 型</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li></ol><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><ol><li>攻击者提交而恶意代码(过滤掉用户输入的恶劣代码，然后提交给后端)</li><li>使用 HttpOnly 属性保护我们 Cookie</li></ol><h3 id="CSRF（Cross-site-request-forgery）跨站请求伪造"><a href="#CSRF（Cross-site-request-forgery）跨站请求伪造" class="headerlink" title="CSRF（Cross-site request forgery）跨站请求伪造"></a>CSRF（Cross-site request forgery）跨站请求伪造</h3><blockquote><p>CSRF（Cross-site request forgery）<code>跨站请求伪造</code>：攻击者诱导受害者<code>进入第三方网站</code>，在<code>第三方网站中</code>，向被攻击网站<code>发送跨站请求</code><br>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p></blockquote><p><strong>一个典型的 CSRF 攻击有着如下的流程：</strong></p><ol><li>受害者登录 a.com，并保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问了 b.com</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带 a.com 的 Cookie</li><li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li><li>a.com 以受害者的名义执行了 act&#x3D;xx</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作</li></ol><h3 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h3><ol><li>通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项</li><li><code>Referer</code> 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址验证请求的来源站点</li><li>CSRF Token</li></ol><h2 id="9-async-x2F-await"><a href="#9-async-x2F-await" class="headerlink" title="9. async&#x2F;await"></a>9. async&#x2F;await</h2><blockquote><p>一句话，async、await 是 co 库的官方实现。也可以看作自带启动器的 generator 函数的语法糖。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> content1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFileWithPromise</span>(<span class="hljs-string">&#x27;/etc/passwd&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-comment">// const content1 = yield readFileWithPromise(&#x27;/etc/passwd&#x27;, &#x27;utf8&#x27;)</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content1)<br>    <span class="hljs-keyword">const</span> content2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">readFileWithPromise</span>(<span class="hljs-string">&#x27;/etc/profile&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>)<br>    <span class="hljs-comment">// const content2 = yield readFileWithPromise(&#x27;/etc/profile&#x27;, &#x27;utf8&#x27;)</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(content2)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-keyword">throw</span> err<br>  &#125;<br>&#125;<br><span class="hljs-comment">//promise.then</span><br><span class="hljs-title function_">readfile</span>().<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res),<br>  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)<br>)<br></code></pre></td></tr></table></figure><h2 id="10-JavaScript-原型，原型链-有什么特点？"><a href="#10-JavaScript-原型，原型链-有什么特点？" class="headerlink" title="10. JavaScript 原型，原型链 ? 有什么特点？"></a>10. JavaScript 原型，原型链 ? 有什么特点？</h2><h3 id="https-vue3js-cn-interview-JavaScript-prototype-html-E4-BA-8C-E3-80-81-E5-8E-9F-E5-9E-8B-E9-93-BE"><a href="#https-vue3js-cn-interview-JavaScript-prototype-html-E4-BA-8C-E3-80-81-E5-8E-9F-E5-9E-8B-E9-93-BE" class="headerlink" title="https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"></a><a href="https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE">https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE</a></h3><h3 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h3><blockquote><p>JavaScript 每个对象拥有一个原型对象<br>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾<br>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的 prototype 属性上，而非实例对象本身</p></blockquote><ol><li>函数可以有属性。 每个函数都有一个特殊的属性叫作原型 prototype</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br><br><span class="hljs-comment">// 控制台输出</span><br>&#123;<br>    <span class="hljs-attr">constructor</span>: ƒ <span class="hljs-title function_">doSomething</span>(),<br>    <span class="hljs-attr">__proto__</span>: &#123;<br>        <span class="hljs-attr">constructor</span>: ƒ <span class="hljs-title class_">Object</span>(),<br>        <span class="hljs-attr">hasOwnProperty</span>: ƒ <span class="hljs-title function_">hasOwnProperty</span>(),<br>        <span class="hljs-attr">isPrototypeOf</span>: ƒ <span class="hljs-title function_">isPrototypeOf</span>(),<br>        <span class="hljs-attr">propertyIsEnumerable</span>: ƒ <span class="hljs-title function_">propertyIsEnumerable</span>(),<br>        <span class="hljs-attr">toLocaleString</span>: ƒ <span class="hljs-title function_">toLocaleString</span>(),<br>        <span class="hljs-attr">toString</span>: ƒ <span class="hljs-title function_">toString</span>(),<br>        <span class="hljs-attr">valueOf</span>: ƒ <span class="hljs-title function_">valueOf</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>constructor 属性指向函数本身<br>可以看到，原型对象有一个自有属性 constructor，这个属性指向该函数，如下图关系展示</li></ol><h3 id="原型链-prototype-chain"><a href="#原型链-prototype-chain" class="headerlink" title="原型链(prototype chain)"></a>原型链(prototype chain)</h3><blockquote><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法<br>在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><blockquote><p><strong>proto</strong>作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p></blockquote><ol><li>每个对象的<strong>proto</strong>都是指向它的构造函数的原型对象 prototype 的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造函数是一个函数对象，是通过 Function 构造器产生的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>原型对象本身是一个普通对象，而普通对象的构造函数都是 Object</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li>所有的构造器都是函数对象，函数对象都是 Function 构造产生的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>Object 的原型对象也有<code>__proto__</code>属性指向 null，null 是原型链的顶端</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="11-Js-中实现继承的几种方式"><a href="#11-Js-中实现继承的几种方式" class="headerlink" title="11. Js 中实现继承的几种方式"></a>11. Js 中实现继承的几种方式</h2><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1. 原型链继承"></a>1. 原型链继承</h3><blockquote><p>将父类的实例作为子类的原型，通过 prototype 进行继承<code>Child1.prototype = new Parent()</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span><br>&#125;<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>())<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">缺点：父类的实例属性会被所有子类共享,子类互相影响<br></code></pre></td></tr></table></figure><h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2. 构造函数继承"></a>2. 构造函数继承</h3><blockquote><p>通过在<code>子类构造函数</code>中调用<code>父类构造函数</code>来实现继承。借助 call 调用 Parent 函数<code>Parent1.call(this)</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child) <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优化：父类的引用属性不会被共享<br>缺点：只能继承父类的实例属性和方法，不能继承原型属性/方法<br></code></pre></td></tr></table></figure><h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><blockquote><p>将原型链继承和借用构造函数继承结合起来,<code>Parent3.call(this)</code>,<code>Child3.prototype = new Parent3()</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第二次调用 Parent3()</span><br>  <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>()<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>()<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>()<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>) <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">优化：融合了原型链继承和构造函数继承的优点，是 <span class="hljs-keyword">JavaScript </span>中最常用的继承模式<br>缺点：调用了两次父类构造函数<br></code></pre></td></tr></table></figure><h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h3><blockquote><p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br><br><span class="hljs-keyword">var</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title function_">createObject</span>(parent)<br>child.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;child&#x27;</span><br>child.<span class="hljs-title function_">sayName</span>() <span class="hljs-comment">// &#x27;child&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">优点：简单易用<br>这种继承方式的缺点也很明显，因为<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能<br></code></pre></td></tr></table></figure><h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h3><blockquote><p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>  F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">parent</span>) &#123;<br>  <span class="hljs-keyword">var</span> child = <span class="hljs-title function_">createObject</span>(parent)<br>  child.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;child&#x27;</span><br>  child.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> child<br>&#125;<br><br><span class="hljs-keyword">var</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent&#x27;</span>,<br>  <span class="hljs-attr">sayName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> child = <span class="hljs-title function_">createChild</span>(parent)<br>child.<span class="hljs-title function_">sayName</span>() <span class="hljs-comment">// &#x27;child&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：在原型式继承的基础上增强了实例<br>缺点：同样存在篡改的可能<br></code></pre></td></tr></table></figure><h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h3><blockquote><p>寄生组合式继承，借助解决普通对象的继承问题的 Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">parent, child</span>) &#123;<br>  <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span><br>&#125;<br><br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>)<br><br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>&#125;<br><br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6) <span class="hljs-comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// parent6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>()) <span class="hljs-comment">// child5</span><br></code></pre></td></tr></table></figure><h3 id="7-ES6-继承"><a href="#7-ES6-继承" class="headerlink" title="7. ES6 继承"></a>7. ES6 继承</h3><blockquote><p>ES6 中新增了 class 关键字，使得 JavaScript 的面向对象编程变得更加清晰，更加符合传统的面向对象编程</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent7</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  &#125;<br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child7</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent7</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> child7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child7</span>(<span class="hljs-string">&#x27;child7&#x27;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child7) <span class="hljs-comment">// Child7 &#123;name: &quot;child7&quot;, age: 18&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child7.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// child7</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：语法简单，易于理解<br>缺点：无法继承原生构造函数<br></code></pre></td></tr></table></figure><h2 id="12-介绍一下-Js-中的闭包及其使用场景"><a href="#12-介绍一下-Js-中的闭包及其使用场景" class="headerlink" title="12. 介绍一下 Js 中的闭包及其使用场景"></a>12. 介绍一下 Js 中的闭包及其使用场景</h2><blockquote><p>闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。(一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起)<br>闭包让你可以在一个内层函数中访问到其外层函数的作用域</p></blockquote><p><strong>原理：</strong></p><blockquote><p>浏览器在加载页面会把代码放在栈内存（ ECStack ）中执行，函数进栈执行会产生一个私有上下文（ EC ），此上下文能保护里面的使用变量（ AO ）不受外界干扰，并且如果当前执行上下文中的某些内容，被上下文以外的内容占用，当前上下文不会出栈释放，这样可以保存里面的变量和变量值，</p></blockquote><h3 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h3><ol><li>创建私有变量、私有方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    count++<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>()<br><span class="hljs-title function_">counter</span>() <span class="hljs-comment">// 1</span><br><span class="hljs-title function_">counter</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><ol start="2"><li>实现模块化：使用闭包可以实现类似于模块化的功能，将一些相关方法或属性封装在一个作用域内，从而提高代码的复用性和可读性。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> privateVariable = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      privateVariable++<br>      <span class="hljs-title function_">privateMethod</span>()<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVariable)<br>    &#125;,<br>  &#125;<br>&#125;)()<br><br>myModule.<span class="hljs-title function_">publicMethod</span>() <span class="hljs-comment">// 1</span><br>myModule.<span class="hljs-title function_">publicMethod</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><ol start="3"><li>柯里化函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">width</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">height</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> width * height<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> getTenWidthArea = <span class="hljs-title function_">getArea</span>(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span><br><span class="hljs-keyword">const</span> area1 = <span class="hljs-title function_">getTenWidthArea</span>(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h2 id="13-js-的-new-操作符"><a href="#13-js-的-new-操作符" class="headerlink" title="13. js 的 new 操作符"></a>13. js 的 new 操作符</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">1. 创建一个空对象，作为将要返回的对象实例 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2. 将这个空对象的原型，指向构造函数的prototype属性 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3. 将这个空对象赋值给函数内部的this关键字 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4. 开始执行构造函数内部的代码<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5. 返回新对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//1.创建一个空对象</span><br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>()<br>  <span class="hljs-comment">//2.获取构造函数</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-title class_">Constructor</span> = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>)<br>  <span class="hljs-comment">//3.链接到原型</span><br>  obj.<span class="hljs-property">__proto__</span> = <span class="hljs-title class_">Constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-comment">//4.绑定this</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-title class_">Constructor</span>.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>  <span class="hljs-comment">//5.返回新对象</span><br>  <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-cookie-session-token-jwt"><a href="#14-cookie-session-token-jwt" class="headerlink" title="14. cookie,session,token,jwt"></a>14. cookie,session,token,jwt</h2><h3 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1. cookie"></a>1. cookie</h3><ul><li>为什么需要 cookie<ul><li>HTTP 协议是无状态的，每次请求都是独立的，服务器无法知道两个请求是否来自同一个用户</li><li>为了解决这个问题，服务器给每个用户分配一个唯一的标识，这个标识就是 cookie</li></ul></li><li>cookie 的特点<ul><li>小容量（通常限制在 4KB）、每个请求都会携带到服务器。</li></ul></li><li>用途： 用于存储少量的文本数据，例如会话信息、用户偏好设置等。</li><li>生命周期： 可以设置失效时间，如果在浏览器没有设置失效时间，那么 cookie 将会在浏览器关闭时失效。</li><li>属性： domain(cookie 域名)、path(cookie 生效路径)、expires(过期时间)、httpOnly(禁止 js 访问)、secure(只能在 https 下使用)、max-age(设置 cookie 的过期时间)</li></ul><h4 id="1-http-请求什么情况下会携带-cookie"><a href="#1-http-请求什么情况下会携带-cookie" class="headerlink" title="1.http 请求什么情况下会携带 cookie"></a>1.http 请求什么情况下会携带 cookie</h4><ol><li>(二级域名相同)浏览器端某个 Cookie 的 domain（.a.com） 字段等于请求的域名或者是请求的父域名，请求的域名需要是 a.com&#x2F;b.a.com 才可以</li><li>都是 <code>http 或者 https</code>，或者不同的情况下 <code>Secure 属性为 false</code>（即 secure 是 true 的情况下，只有 https 请求才能携带这个 cookie）</li><li>要<code>发送请求的路径</code>，<code>跟浏览器端 Cookie 的 path 属性必须一致</code>，或者是浏览器端 Cookie 的 path 的子目录，比如浏览器端 Cookie 的 path 为 &#x2F;test，那么请求的路径必须为&#x2F;test 或者&#x2F;test&#x2F;xxxx 等子目录才可以</li></ol><h3 id="2-session"><a href="#2-session" class="headerlink" title="2. session"></a>2. session</h3><ul><li><p>session 是另一种记录服务器和客户端会话状态的机制</p></li><li><p>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中<br>流程：</p><ol><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li></ol><p>1.2. Cookie 和 Session 的区别</p><ul><li>安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li><li>存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li><li>有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li><li>存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul></li></ul><h3 id="3-token"><a href="#3-token" class="headerlink" title="3. token"></a>3. token</h3><ul><li><p>流程</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ol></li><li><p>优点</p><ol><li>无状态可以减轻服务器压力，减少频繁查询数据库</li><li>没有同源策略的限制，方便第三方平台或者开发时的接口调用</li><li>安全性较高，token 的解密密钥只有服务端知道，即使客户端暴露出来，别人也无法解密</li></ol></li></ul><h3 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4. JWT"></a>4. JWT</h3><blockquote><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络上以 JSON 格式安全地传输信息。JWT 可以被用于身份验证（Authentication）和信息传递，通常用于通过网络在用户和服务器之间传递信息，以便在系统之间进行身份验证。</p></blockquote><h4 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h4><blockquote><p>JWT 由三部分组成，它们通过点号（.）连接在一起：Header.Payload.Signature</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//JWT编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br>  .<span class="hljs-property">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br>  .<span class="hljs-property">UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q</span><br></code></pre></td></tr></table></figure><h5 id="header-头部"><a href="#header-头部" class="headerlink" title="header(头部)"></a>header(头部)</h5><p>jwt 的头部承载两部分信息：</p><ol><li>声明类型，这里是 jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;typ&#x27;</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,<br>  <span class="hljs-string">&#x27;alg&#x27;</span>: <span class="hljs-string">&#x27;HS256&#x27;</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br></code></pre></td></tr></table></figure><h5 id="playload-载荷"><a href="#playload-载荷" class="headerlink" title="playload(载荷)"></a>playload(载荷)</h5><p>有效信息包含三个部分</p><ol><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9<br></code></pre></td></tr></table></figure><h5 id="signature-签证"><a href="#signature-签证" class="headerlink" title="signature(签证)"></a>signature(签证)</h5><p>签证信息由三部分组成：</p><ol><li>header (base64 后的)</li><li>payload (base64 后的)</li><li>secret</li></ol><p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成的字符串(头部在前)，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> encodedString = <span class="hljs-title function_">base64UrlEncode</span>(header) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-title function_">base64UrlEncode</span>(payload)<br><span class="hljs-keyword">var</span> signature = <span class="hljs-title class_">HMACSHA256</span>(encodedString, <span class="hljs-string">&#x27;secret&#x27;</span>) <span class="hljs-comment">//UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q</span><br></code></pre></td></tr></table></figure><h4 id="JWT-认证流程"><a href="#JWT-认证流程" class="headerlink" title="JWT 认证流程"></a>JWT 认证流程</h4><ol><li>用户身份验证：<br>用户提供身份信息（例如用户名和密码）进行身份验证。<br>服务器验证用户身份，如果验证通过，生成 JWT。</li><li>生成 JWT：<br>服务器使用用户的信息创建一个包含用户标识的 JWT。<br>JWT 的结构为 Header.Payload.Signature。</li><li>返回 JWT：<br>服务器将生成的 JWT 返回给客户端。</li><li>客户端存储 JWT：<br>客户端通常将收到的 JWT 存储在本地，例如在浏览器的 localStorage、sessionStorage 中，或者在移动应用程序的本地存储中。</li><li>在后续请求中携带 JWT：<br>客户端在后续的请求中携带 JWT，通常通过在请求头中添加 Authorization 字段，值为 Bearer <JWT>。</JWT></li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">http<br>Copy code<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...<br></code></pre></td></tr></table></figure><ol><li>服务器验证 JWT：<br>服务器在接收到请求时，从请求头中提取 JWT。<br>服务器使用事先共享的密钥（或公钥，对于使用非对称加密的情况）验证 JWT 的签名，确保令牌的真实性。<br>如果签名验证通过，服务器解析 JWT 中的负载数据，获取用户信息。</li><li>处理请求：<br>服务器根据 JWT 中的用户信息处理请求，进行相应的操作。</li></ol><h1 id="3-5-Node-js"><a href="#3-5-Node-js" class="headerlink" title="3.5 Node.js"></a>3.5 Node.js</h1><h2 id="1-require-和-import-区别"><a href="#1-require-和-import-区别" class="headerlink" title="1. require 和 import 区别"></a>1. require 和 import 区别</h2><blockquote><p>require&#x2F;exports 是 CommonJS 规范<br>import&#x2F;export 是 ES6 规范</p></blockquote><ol><li><p>模块机制不一样<br>require 是运行时加载，import 是编译时输出接口。</p></li><li><p>输出不一样</p></li><li><p>require 输出的是值的拷贝</p></li><li><p>import 输出的是值的引用</p></li><li></li><li><p>CommonJS 模块的 require()是同步加载模块.</p></li><li><p>ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段.</p></li></ol><h2 id="2-ESM-ESModule-和-CJS-CommonJS-的区别"><a href="#2-ESM-ESModule-和-CJS-CommonJS-的区别" class="headerlink" title="2. ESM(ESModule)和 CJS(CommonJS)的区别"></a>2. ESM(ESModule)和 CJS(CommonJS)的区别</h2><blockquote><p>ESM 是 ESModule，是 ECMAScript 自己的模块体系，于 ES6 引入，主要使用如下：export、import<br>CJS 是 CommonJS，是 Node.js 自己的模块体系，主要使用如下：require、module.exports</p></blockquote><ol><li>使用方式不同（以上）；</li><li>ESM 输出的是值的引用，而 CJS 输出的是值的拷贝；</li><li>CJS 的输出是运行时加载，而 ESM 是编译时输出接口；</li><li>CJS 是同步加载，ESM 是异步加载；</li></ol><h2 id="3-ES6-中数组新增了哪些扩展？"><a href="#3-ES6-中数组新增了哪些扩展？" class="headerlink" title="3. ES6 中数组新增了哪些扩展？"></a>3. ES6 中数组新增了哪些扩展？</h2><h3 id="1-扩展运算符的应用"><a href="#1-扩展运算符的应用" class="headerlink" title="1. 扩展运算符的应用"></a>1. 扩展运算符的应用</h3><blockquote><p>ES6 通过扩展元素符<code>...</code>，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>函数调用的时候，将一个数组变为参数序列</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">38</span>]<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>可以将某些数据结构转为数组<code>[...document.querySelectorAll(&#39;div&#39;)]</code></p></li><li><p>能够更简单实现数组复制<code>const [...a2] = a1;</code></p></li><li><p>数组的合并[…arr1, …arr2, …arr3]</p></li></ol><blockquote><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p></blockquote><h3 id="2-数组新增的方法"><a href="#2-数组新增的方法" class="headerlink" title="2. 数组新增的方法"></a>2. 数组新增的方法</h3><ol><li>Array.from()</li></ol><blockquote><p>将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<br>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x)<br><span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Array.of()</li></ol><ul><li>没有参数的时候，返回一个空数组<br><code>Array() // []</code></li><li>当参数只有一个的时候，实际上是指定数组的长度<br><code>Array(3) // [, , ,]</code></li><li>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组<br><code>Array.of(3, 11, 8) // [3,11,8]</code></li></ul><ol start="3"><li>关于数组实例对象新增的方法有如下：</li></ol><p>copyWithin()<br>find()、findIndex()<br>fill()<br>entries()，keys()，values()<br>includes()<br>flat()，flatMap() 4. 数组的空位</p><blockquote><p>数组的空位指，数组的某一个位置没有任何值</p></blockquote><p>ES6 则是明确将空位转为 undefined</p><ol start="5"><li>排序稳定性</li></ol><blockquote><p>将 sort()默认设置为稳定的排序算法</p></blockquote><h3 id="3-模板字符串"><a href="#3-模板字符串" class="headerlink" title="3. 模板字符串"></a>3. 模板字符串</h3><h2 id="4-babel-ES6-转换-ES5-实现原理"><a href="#4-babel-ES6-转换-ES5-实现原理" class="headerlink" title="4. babel ES6 转换 ES5 实现原理"></a>4. babel ES6 转换 ES5 实现原理</h2><ol><li>Parser 解析<br>第一步主要是将 ES6 语法解析为 AST 抽象语法树。简单地说就是将代码打散成颗粒组装的对象。这一步主要是通过 babylon 插件来完成。</li><li>Transformer 转换<br>第二步是将打散的 AST 语法通过配置好的 plugins（babel-traverse 对 AST 进行遍历转译）和 presets （es2015 &#x2F; es2016 &#x2F; es2017 &#x2F; env &#x2F; stage-0 &#x2F; stage-4 其中 es20xx 表示转换成该年份批准的标准，env 是最新标准，stage-0 和 stage-4 是实验版）转换成新的 AST 语法。这一步主要是由 babel-transform 插件完成。plugins 和 presets 通常在 .babelrc 文件中配置。</li><li>Generator 生成<br>第三步是将新的 AST 语法树对象再生成浏览器都可以识别的 ES5 语法。这一步主要是由 babel-generator 插件完成。</li></ol><h1 id="4-Vue"><a href="#4-Vue" class="headerlink" title="4. Vue"></a>4. Vue</h1><h2 id="1-组件通行的方法有哪些方式"><a href="#1-组件通行的方法有哪些方式" class="headerlink" title="1. 组件通行的方法有哪些方式"></a>1. 组件通行的方法有哪些方式</h2><h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><h4 id="props-传递数据"><a href="#props-传递数据" class="headerlink" title="props 传递数据"></a>props 传递数据</h4><blockquote><p>父组件通过 props 向子组件传递数据，子组件通过 props 接收数据</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件vue2</span><br><span class="hljs-attr">props</span>:&#123;<br>    <span class="hljs-comment">// 字符串形式</span><br>   <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">// 接收的类型参数</span><br>   <span class="hljs-comment">// 对象形式</span><br>   <span class="hljs-attr">age</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">Number</span>, <span class="hljs-comment">// 接收的类型为数值</span><br>      <span class="hljs-attr">defaule</span>:<span class="hljs-number">18</span>,  <span class="hljs-comment">// 默认值为18</span><br>      <span class="hljs-attr">require</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// age属性必须传递</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 子组件vue3</span><br><span class="hljs-keyword">import</span> &#123; defineProps, defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">count</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 父组件</span><br>&lt;child :name=<span class="hljs-string">&quot;name&quot;</span> :age=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/child&gt;<br></code></pre></td></tr></table></figure><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><blockquote><p>子组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;父组件绑定监听器获取到子组件传递过来的参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Chilfen.vue vue2</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, good)<br><span class="hljs-comment">//Chilfen.vue vue3</span><br><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>()<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">childAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;add&#x27;</span>, props.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// Father.vue</span><br>&lt;<span class="hljs-title class_">Children</span> @add=<span class="hljs-string">&quot;cartAdd($event)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="ref-获取子组件实例"><a href="#ref-获取子组件实例" class="headerlink" title="ref 获取子组件实例"></a>ref 获取子组件实例</h4><blockquote><p>父组件在使用子组件的时候设置 ref;父组件通过设置子组件 ref 来获取数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;callChildMethod&quot;</span>&gt;</span>Call Child Method<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">callChildMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    childRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">childMethod</span>();</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;</span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">      Child Component</span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">childMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Method called from parent&#x27;</span>);</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  &#125;;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="parent-或-root"><a href="#parent-或-root" class="headerlink" title="$parent 或$root"></a>$parent 或$root</h4><blockquote><p>通过共同祖辈$parent或者$root 搭建通信桥连</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">//<br>&lt;!-- ParentComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import child from &#x27;~/components/dam/child&#x27;<br>export default &#123;<br>  components: &#123;<br>    child,<br>  &#125;,<br>  methods: &#123;<br>    fatherMethod() &#123;<br>      console.log(&#x27;测试&#x27;)<br>    &#125;,<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&#123;/*<br>&lt;!-- ChildComponent.vue --&gt;<br>*/&#125;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;childMethod()&quot;&gt;点击&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  methods: &#123;<br>    childMethod() &#123;<br>      this.$parent.fatherMethod()<br>    &#125;,<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h3><h4 id="EventBus-中央事件总线"><a href="#EventBus-中央事件总线" class="headerlink" title="EventBus 中央事件总线"></a>EventBus 中央事件总线</h4><blockquote><p>创建一个中央事件总线 EventBus;兄弟组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;另一个兄弟组件通过$on 监听自定义事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>() <span class="hljs-comment">// Vue已经实现了Bus的功能</span><br><br><span class="hljs-comment">//Children1.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 触发事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from EventBus!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-comment">// Children2.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听事件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// Output: Hello from EventBus!</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h3 id="祖孙与后代组件之间的通信"><a href="#祖孙与后代组件之间的通信" class="headerlink" title="祖孙与后代组件之间的通信"></a>祖孙与后代组件之间的通信</h3><h4 id="attrs-与-listeners"><a href="#attrs-与-listeners" class="headerlink" title="$attrs 与$listeners"></a>$attrs 与$listeners</h4><p>设置批量向下传属性$attrs和 $listeners<br>包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。<br>可以通过 v-bind&#x3D;”$attrs” 传⼊内部组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// child：并未在props中声明foo</span><br>&lt;p&gt;&#123;&#123;$attrs.<span class="hljs-property">foo</span>&#125;&#125;&lt;/p&gt;<br><br><span class="hljs-comment">// parent</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;foo&quot;</span>/&gt;</span></span><br><span class="hljs-comment">// 给Grandson隔代传值，communication/index.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;lalala&quot;</span> @<span class="hljs-attr">some-event</span>=<span class="hljs-string">&quot;onSomeEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child2</span>&gt;</span></span><br><br><span class="hljs-comment">// Child2做展开</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grandson</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Grandson</span>&gt;</span></span><br><br><span class="hljs-comment">// Grandson使⽤</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span></span><br><span class="language-xml">&#123;&#123;msg&#125;&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><blockquote><p>在祖先组件定义 provide 属性，返回传递的值;在后代组件通过 inject 接收组件传递过来的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 祖先组件</span><br><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">foo</span>:<span class="hljs-string">&#x27;foo&#x27;</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 后代组件</span><br><span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;foo&#x27;</span>] <span class="hljs-comment">// 获取到祖先组件传递过来的值</span><br></code></pre></td></tr></table></figure><h3 id="非关系组件间之间的通信"><a href="#非关系组件间之间的通信" class="headerlink" title="非关系组件间之间的通信"></a>非关系组件间之间的通信</h3><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ol><li>state 用来存放共享变量的地方</li><li>getter，可以增加一个 getter 派生状态，(相当于 store 中的计算属性），用来获得共享变量的值</li><li>mutations 用来存放修改 state 的方法。</li><li>actions 也是用来存放修改 state 的方法，不过 action 是在 mutations 的基础上进行。常用来做一些异步操作</li></ol><h2 id="2-数据响应式的原理"><a href="#2-数据响应式的原理" class="headerlink" title="2. 数据响应式的原理"></a>2. 数据响应式的原理</h2><blockquote><p>MVVM 模式就是可以直接将数据映射到视图上，同样可以自动监控视图的变化，视图变化后可以更新数据</p></blockquote><h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3><blockquote><p>在 vue2 中 1.通过 observe 一个对象进行数据劫持 2.通过 watcher 进行依赖收集 3.通过 dep 进行数据更新<br>vue2 中重写了可以改变愿数组的七种方法 push，shift，unshift，sort，reverse，pop，splice，当调用这些方法的时候，再触发视图更新。</p></blockquote><p>Vue 在实例化时会对 data 上的数据进行递归生成 Observer 实例对象和 Dep 实例对象，并且 observer 这个过程中给每一项对象通过 Object.defineProperty 进行数据劫持。在 Watcher 实例化的时候会进行依赖收集，触发 get 劫持，使得 dep 对象的 subs 数组中存放了对应的 watcher 实例，当数据进行变化时，会触发 set 劫持，dep 会通知 subs 数组中的 watcher 实例进行更新渲染。<br>首先要对数据(data)进行<code>劫持监听</code>，所以我们需要设置一个<code>监听器Observer</code>，用来监听所有属性。如果属性发上变化了，就需要告诉<code>订阅者Watcher</code>看是否需要更新。因为订阅者是有很多个，所以我们需要有一个<code>消息订阅器（发布者）Dep</code>来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p><h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><blockquote><p>而 vue3 使用的 proxy 监听的是对象本身，而不是对象的属性，所以不需要递归监听，也不需要为每个属性创建 dep 实例，这样就减少了内存的开销，提高了性能。而且 proxy 可以监听数组的变化，不需要重写数组的方法，也不需要手动去触发视图更新。<br>vue3 中 effect 方法充当了 Watcher 的角色，用户的更新方法会交给 effect 处理</p></blockquote><h2 id="3-组件的生命周期："><a href="#3-组件的生命周期：" class="headerlink" title="3. 组件的生命周期："></a>3. 组件的生命周期：</h2><table><thead><tr><th align="center">生命周期</th><th align="center">描述</th><th align="right"></th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td><td align="right"></td></tr><tr><td align="center">created</td><td align="center">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td><td align="right"></td></tr><tr><td align="center">beforeMount</td><td align="center">未执行渲染、更新，dom 未创建</td><td align="right"></td></tr><tr><td align="center">mounted</td><td align="center">初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td><td align="right"></td></tr><tr><td align="center">beforeUpdate</td><td align="center">更新前，可用于获取更新前各种状态</td><td align="right"></td></tr><tr><td align="center">updated</td><td align="center">更新后，所有状态已是最新</td><td align="right"></td></tr><tr><td align="center">beforeDestroy</td><td align="center">销毁前，可用于一些定时器或订阅的取消</td><td align="right"></td></tr><tr><td align="center">destroyed</td><td align="center">组件已销毁，作用同上</td><td align="right"></td></tr></tbody></table><blockquote><p>父子组建:</p></blockquote><ol><li>加载渲染过程: 子组件在父组件的 beforeMount 和 Mounted 之间渲染<br>父 breforCreate -&gt; 父 created -&gt; 父 beforeMounte -&gt; 子 breforCreate -&gt; 子 created -&gt; 子 beforeMounte -&gt; 子 mounted -&gt;父 mounted</li><li>子组件的更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li><li>父组件更新过程</li><li>影响到子组件： 父 beforeUpdate -&gt; 子 beforeUpdate-&gt;子 updated -&gt; 父 updted</li><li>不影响子组件： 父 beforeUpdate -&gt; 父 updated</li><li>销毁过程<br>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</li></ol><h2 id="4-v-model-是什么东西"><a href="#4-v-model-是什么东西" class="headerlink" title="4. v-model 是什么东西"></a>4. v-model 是什么东西</h2><blockquote><p>v-model 是 Vue 框架的一种内置的 API 指令，本质是一种语法糖写法。它负责监听用户的输入事件以更新数据,并在表单元素上创建数据双向绑定。</p></blockquote><h3 id="v-model：双向数据绑定，单向数据流"><a href="#v-model：双向数据绑定，单向数据流" class="headerlink" title="v-model：双向数据绑定，单向数据流"></a>v-model：双向数据绑定，单向数据流</h3><blockquote><p>v-model&#x3D;v-bind:value+v-on:input<br>v-bind 绑定 value 属性的值；<br>v-on 绑定 input 事件监听到函数中，函数会获取最新的值，赋值给绑定的属性中；</p></blockquote><ul><li>lazy 仅仅是一个判断触发标签 change 还是 input 事件的标识符，lazy 为 true 时，触发 change</li><li>trim 仅仅是调用了 String.prototype.trim()</li><li>number 这是 vue 的_n 函数，而这个函数其实是一个 StringToNumber 函数，相当简单</li></ul><h2 id="5-nextick-做什么的？怎么实现的"><a href="#5-nextick-做什么的？怎么实现的" class="headerlink" title="5. nextick 做什么的？怎么实现的"></a>5. nextick 做什么的？怎么实现的</h2><blockquote><p>因为 vue 采用的异步更新策略，当监听到数据发生变化的时候不会立即去更新 DOM，<br>而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更;<br>nextTick 接收一个回调函数作为参数，并将这个回调函数延迟到 DOM 更新后才执行；</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h2 id="6-Vue3-和-Vue2-的区别"><a href="#6-Vue3-和-Vue2-的区别" class="headerlink" title="6. Vue3 和 Vue2 的区别"></a>6. Vue3 和 Vue2 的区别</h2><h3 id="1-双向数据绑定原理不同"><a href="#1-双向数据绑定原理不同" class="headerlink" title="1. 双向数据绑定原理不同"></a>1. 双向数据绑定原理不同</h3><blockquote><p>vue2：vue2 的双向数据绑定是利用 ES5 的一个 APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。</p></blockquote><blockquote><p>vue3：vue3 中使用了 ES6 的 Proxy API 对数据代理。相比 vue2.x，使用 proxy 的优势如下：</p></blockquote><ol><li>defineProperty 只能监听某个属性，不能对全对象监听</li><li>可以省去 for in，闭包等内容来提升效率(直接绑定整个对象即可)</li><li>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x 可以检测到数组内部数据的变化。</li></ol><h3 id="2-是否支持碎片-framents"><a href="#2-是否支持碎片-framents" class="headerlink" title="2.是否支持碎片(framents)"></a>2.是否支持碎片(framents)</h3><blockquote><p>vue2 不支持碎片。</p></blockquote><blockquote><p>vue3：vue3 支持碎片（Fragments） ，就是说可以拥有多个根节点。</p></blockquote><h3 id="3-API-类型不同-compositon-Api"><a href="#3-API-类型不同-compositon-Api" class="headerlink" title="3. API 类型不同 (compositon Api)"></a>3. API 类型不同 (compositon Api)</h3><blockquote><p>vue2：vue2 使用选项类型 api，选项型 api 在代码里分割了不同的属性：data,computed,methods 等。</p></blockquote><blockquote><p>vue3：vue3 使用合成型 api，新的合成型 api 能让我们使用方法来分割，相比于旧的 api 使用属性来分组，这样代码会更加简便和整洁。</p></blockquote><h3 id="4-声明周期钩子不同"><a href="#4-声明周期钩子不同" class="headerlink" title="4. 声明周期钩子不同"></a>4. 声明周期钩子不同</h3><table><thead><tr><th align="center">vue2</th><th align="center">vue3</th><th>vue</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center"></td><td></td></tr><tr><td align="center">created</td><td align="center"></td><td></td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td><td></td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td><td></td></tr><tr><td align="center">beforeUpdate</td><td align="center">onBeforeUpdate</td><td></td></tr><tr><td align="center">updated</td><td align="center">onUpdated</td><td></td></tr><tr><td align="center">beforeDestroy</td><td align="center">onBeforeUnmount</td><td></td></tr><tr><td align="center">destroyed</td><td align="center">onUnmounted</td><td></td></tr></tbody></table><h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><blockquote><p>Vue 3 提供了更好的 Tree-shaking 支持\更小的 bundle 大小\更快的更新速度、更好的 TypeScript 支持\更高效的虚拟 DOM 实现和编译优化。</p></blockquote><h3 id="6-异步组件（Suspense）"><a href="#6-异步组件（Suspense）" class="headerlink" title="6. 异步组件（Suspense）"></a>6. 异步组件（Suspense）</h3><p>Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tempalte</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">suspense</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        Loading...      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">suspense</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-Teleport"><a href="#7-Teleport" class="headerlink" title="7.Teleport"></a>7.Teleport</h3><p>Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;dialogVisible = true&quot;</span>&gt;</span>显示弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;dialogVisible&quot;</span>&gt;</span><br>    我是弹窗，我直接移动到了body标签下<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-watch-和-computed-的区别"><a href="#7-watch-和-computed-的区别" class="headerlink" title="7. watch 和 computed 的区别"></a>7. watch 和 computed 的区别</h2><p>watch 和 computed 区别</p><ol><li>功能上：computed 是计算属性，watch 是监听一个值的变化，然后执行对应的回调。</li><li>是否调用缓存：computed 中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而 watch 在每次监听的值发生变化的时候都会执行回调。</li><li>是否调用 return：computed 中的函数必须要用 return 返回，watch 中的函数不是必须要用 return</li><li>computed 第一次加载时就监听；watch 默认第一次加载时不监听。</li><li>watch 擅长处理的场景：一个数据影响多个数据 ——-搜索框。</li><li>computed 擅长处理的场景：一个数据受多个数据影响 – 使用场景：当一个值受多个属性影响的时候——–购物车商品结算</li></ol><h2 id="8-key-的作用和虚拟-DOM-的-diff-算法"><a href="#8-key-的作用和虚拟-DOM-的-diff-算法" class="headerlink" title="8. key 的作用和虚拟 DOM 的 diff 算法"></a>8. key 的作用和虚拟 DOM 的 diff 算法</h2><blockquote><p>key 主要用在 <code>Vue 的虚拟 DOM 的 diff 算法</code>中，是 vnode 的<code>唯一标记</code>，diff 算法中双端两两比较一共有 4 种比较方式，如果以上 4 种比较都没匹配，如果设置了 key，就会<code>用 key 再进行比较</code>。通过这个 key，我们的 <code>diff 操作可以更准确、更快速</code>的达到复用节点，更新视图的目的。复用节点就需要通过移动元素的位置来达到更新的目的。</p></blockquote><blockquote><p>diff 算法是一种通过同层的树节点进行比较的高效算法</p></blockquote><h3 id="其有两个特点："><a href="#其有两个特点：" class="headerlink" title="其有两个特点："></a>其有两个特点：</h3><ol><li>比较只会在同层级进行, 不会跨层级比较</li><li>在 diff 比较的过程中，循环从两边向中间比较</li></ol><h2 id="9-介绍一下-Vue-中-template-模版的编译原理"><a href="#9-介绍一下-Vue-中-template-模版的编译原理" class="headerlink" title="9. 介绍一下 Vue 中 template 模版的编译原理"></a>9. 介绍一下 Vue 中 template 模版的编译原理</h2><blockquote><p>Vue 的模板编译原理主要是将模板(template)转换为抽象语法树(AST)，然后对 AST 进行优化处理，最终生成可执行的渲染函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> createCompiler = <span class="hljs-title function_">createCompilerCreator</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">baseCompile</span>(<span class="hljs-params"></span><br><span class="hljs-params">  template: string,</span><br><span class="hljs-params">  options: CompilerOptions</span><br><span class="hljs-params"></span>): <span class="hljs-title class_">CompiledResult</span> &#123;<br>  <span class="hljs-keyword">const</span> ast = <span class="hljs-title function_">parse</span>(template.<span class="hljs-title function_">trim</span>(), options) <span class="hljs-comment">// 将模板字符串转换成 AST</span><br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">optimize</span> !== <span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-title function_">optimize</span>(ast, options) <span class="hljs-comment">// 优化 AST</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> code = <span class="hljs-title function_">generate</span>(ast, options) <span class="hljs-comment">// 生成代码</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    ast,<br>    <span class="hljs-attr">render</span>: code.<span class="hljs-property">render</span>,<br>    <span class="hljs-attr">staticRenderFns</span>: code.<span class="hljs-property">staticRenderFns</span>,<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="1、解析器-parser-将模板解析成-AST"><a href="#1、解析器-parser-将模板解析成-AST" class="headerlink" title="1、解析器 parser(将模板解析成 AST)"></a>1、解析器 parser(将模板解析成 AST)</h3><blockquote><p>Parse 会用正则等方式解析 template 模版中的指令、class、style 等数据，形成 AST。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">template, options</span>) &#123;<br>  <span class="hljs-keyword">let</span> root<br>  <span class="hljs-title function_">parseHTML</span>(template, &#123;<br>    <span class="hljs-comment">// some options...</span><br>    <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-comment">// 解析到标签位置开始的回调</span><br>    <span class="hljs-title function_">end</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-comment">// 解析到标签位置结束的回调</span><br>    <span class="hljs-title function_">chars</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-comment">// 解析到文本时的回调</span><br>    <span class="hljs-title function_">comment</span>(<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-comment">// 解析到注释时的回调</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、优化器-optimizer-遍历-AST-标记静态节点"><a href="#2、优化器-optimizer-遍历-AST-标记静态节点" class="headerlink" title="2、优化器 optimizer(遍历 AST 标记静态节点)"></a>2、优化器 optimizer(遍历 AST 标记静态节点)</h3><blockquote><p>Optimize 的主要作用是标记 static 静态节点，这时 Vue 在编译过程中的优化，后面当 update 更新界面时，会有一个 patch 的过程，diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">optimize</span>(<span class="hljs-params"></span><br><span class="hljs-params">  root: ASTElement | <span class="hljs-literal">null</span> | <span class="hljs-literal">undefined</span>,</span><br><span class="hljs-params">  options: CompilerOptions</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span><br>  isStaticKey = <span class="hljs-title function_">genStaticKeysCached</span>(options.<span class="hljs-property">staticKeys</span> || <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 生成静态节点的 key</span><br>  isPlatformReservedTag = options.<span class="hljs-property">isReservedTag</span> || no <span class="hljs-comment">// 是否是平台保留标签</span><br>  <span class="hljs-comment">// first pass: mark all non-static nodes.</span><br>  <span class="hljs-title function_">markStatic</span>(root) <span class="hljs-comment">// 标记静态节点</span><br>  <span class="hljs-comment">// second pass: mark static roots.</span><br>  <span class="hljs-title function_">markStaticRoots</span>(root, <span class="hljs-literal">false</span>) <span class="hljs-comment">// 标记静态根节点</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>标记静态节点</li><li>标记静态根节点<ul><li>节点本身必须是静态节点</li><li>必须拥有子节点 children</li><li>子节点不能只是只有一个文本节点</li></ul></li></ol><h3 id="3、代码生成器-generate-使用-AST-生成渲染函数"><a href="#3、代码生成器-generate-使用-AST-生成渲染函数" class="headerlink" title="3、代码生成器 generate(使用 AST 生成渲染函数)"></a>3、代码生成器 generate(使用 AST 生成渲染函数)</h3><blockquote><p>Generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。</p></blockquote><h1 id="4-5-React"><a href="#4-5-React" class="headerlink" title="4.5 React"></a>4.5 React</h1><h1 id="5-Webpack-x2F-Vite"><a href="#5-Webpack-x2F-Vite" class="headerlink" title="5. Webpack&#x2F;Vite"></a>5. Webpack&#x2F;Vite</h1><h2 id="1-webpack-的理解"><a href="#1-webpack-的理解" class="headerlink" title="1. webpack 的理解"></a>1. webpack 的理解</h2><blockquote><p>webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具;Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p></blockquote><h1 id="6-http"><a href="#6-http" class="headerlink" title="6. http"></a>6. http</h1><h2 id="1-HTTP1-0-x2F-1-1-x2F-2-0-x2F-3-0"><a href="#1-HTTP1-0-x2F-1-1-x2F-2-0-x2F-3-0" class="headerlink" title="1. HTTP1.0&#x2F;1.1&#x2F;2.0&#x2F;3.0"></a>1. HTTP1.0&#x2F;1.1&#x2F;2.0&#x2F;3.0</h2><p>说说 HTTP1.0&#x2F;1.1&#x2F;2.0&#x2F;3.0 的区别?</p><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><blockquote><p>HTTP 1.0 浏览器与服务器只<code>保持短暂的连接</code>，每次请求都需要与服务器建立一个 TCP 连接<br>服务器完成请求处理后<code>立即断开TCP连接</code>，服务器不跟踪每个客户也不记录过去的请求</p></blockquote><p><strong>简单来讲，每次与服务器交互，都需要新开一个连接</strong></p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>在 HTTP1.1 中，<code>默认支持长连接</code>（Connection: keep-alive），即在一个 TCP 连接上可以<code>传送多个HTTP请求和响应</code>，减少了建立和关闭连接的消耗和延迟</li><li>HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求</li><li>新增了一些<code>请求方法</code></li><li>新增了一些<code>请求头和响应头</code></li></ol><h4 id="不足："><a href="#不足：" class="headerlink" title="不足："></a>不足：</h4><ol><li>请求 &#x2F; 响应<code>头部（Header）未经压缩</code>就发送，首部信息越多延迟越大。只能压缩 Body 的部分；发送<code>冗长的首部</code>。每次互相发送相同的首部造成的<code>浪费较多</code>；</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<code>队头阻塞</code>；(虽然解决了<code>请求的队头阻塞</code>，但是没有解决<code>响应的队头阻塞</code>)</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ol><p><strong>建立一次连接，多次请求均由这个连接完成</strong></p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><blockquote><p>而 HTTP2.0 在相比之前版本，性能上有很大的提升，如添加了一个特性：</p></blockquote><ol><li>多路复用<blockquote><p>HTTP&#x2F;2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p></blockquote></li><li>二进制分帧<blockquote><p>HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，解析起来更高效</p></blockquote></li><li>首部压缩<blockquote><p>HTTP&#x2F;2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p></blockquote></li><li>服务器推送<blockquote><p>HTTP2 引入服务器推送，允许服务端推送资源给客户端</p></blockquote></li></ol><h4 id="不足：-1"><a href="#不足：-1" class="headerlink" title="不足："></a>不足：</h4><p>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</p><h3 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h3><blockquote><p>在 HTTP&#x2F;3 中，将弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议实现</p></blockquote><ol><li>无队头阻塞<br>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream<br>当某个流发生丢包时，<code>只会阻塞这个流</code>，其他流不会受到影响，因此<code>不存在队头阻塞问题</code></li><li>更快的连接建立<br>HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是 <code>QUIC 内部包含了 TLS</code>，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商</li><li>连接迁移<br>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接<br>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本</li></ol><h2 id="2-协商缓存，强缓存"><a href="#2-协商缓存，强缓存" class="headerlink" title="2. 协商缓存，强缓存"></a>2. 协商缓存，强缓存</h2><h3 id="1-协商缓存过程："><a href="#1-协商缓存过程：" class="headerlink" title="1. 协商缓存过程："></a>1. 协商缓存过程：</h3><blockquote><p>当<code>强缓存</code>时间过期了，才会进入协商缓存阶段，<code>首次请求时</code>服务器会将缓存相关的头字段放入响应报文里，其中也<code>包含协商缓存相关</code>的头字段，如 Last-Modified 和 Etag， 当强缓存失效时，浏览器会<code>携带协商缓存字段</code>If-Modified-Since 和 If-None-Match 向服务器发起请求，If-Modified-Since 的值就是服务器之前返回的 Last-Modified 的值，If-None-Match 的值就是 Etag 的值， 服务器根据此头字段判断文件在上次请求后有没有修改过，如果没有修改过，返回状态码 304，并且响应体为空加快传输速度，如果修改过，返回 200 状态码和新文件内容。</p></blockquote><ol><li>Last-Modified 表示本地文件最后修改日期，浏览器会在 request header 加上 If-Modified-Since（上次返回的 Last-Modified 的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li><li>Etag 就像一个指纹，资源变化都会导致 ETag 变化，跟最后修改时间没有关系，ETag 可以保证每一个资源是唯一的</li><li>If-None-Match 的 header 会将上次返回的 Etag 发送给服务器，询问该资源的 Etag 是否有更新，有变动就会发送新的资源回来</li></ol><h3 id="2-强缓存过程："><a href="#2-强缓存过程：" class="headerlink" title="2. 强缓存过程："></a>2. 强缓存过程：</h3><p>而强制缓存不需要发送请求到服务端，根据请求头 expires 和 cache-control 判断是否命中强缓存</p><ol><li>expires 表示资源的过期时间，浏览器再次加载资源时，会根据 expires 和本地时间比较，如果本地时间小于 expires，直接使用缓存</li><li>cache-control 是服务器返回的响应头，表示资源的缓存策略</li></ol><ul><li>public<br>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有 max-age 指令或 Expires 消息头；2. 该响应对应的请求方法是 POST 。）</li><li>private<br>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。</li><li>no-cache<br>在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)。</li><li>no-store<br>缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。</li><li>max-age&#x3D;<seconds><br>设置缓存存储的最大周期，超过这个时间缓存被认为过期 (单位秒)。与 Expires 相反，时间是相对于请求的时间。</seconds></li></ul><h3 id="3-缓存位置（介绍一下浏览器缓存位置和优先级）"><a href="#3-缓存位置（介绍一下浏览器缓存位置和优先级）" class="headerlink" title="3. 缓存位置（介绍一下浏览器缓存位置和优先级）"></a>3. 缓存位置（介绍一下浏览器缓存位置和优先级）</h3><blockquote><p>优先级（Service Worker -&gt; Memory Cache -&gt; Disk Cache -&gt; Push Cache）依次查找缓存。</p></blockquote><ol><li><p>Service Worker</p><blockquote><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能</p></blockquote></li><li><p>Memory Cache</p><blockquote><p>从内存中读取缓存;关闭进程后，缓存资源也会随之销毁</p></blockquote></li><li><p>Disk Cache</p><blockquote><p>从硬盘中读取缓存</p></blockquote></li><li><p>Push Cache<br>Push Cache 是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用</p></li></ol><h2 id="3-跨域以及解决方案"><a href="#3-跨域以及解决方案" class="headerlink" title="3. 跨域以及解决方案"></a>3. 跨域以及解决方案</h2><blockquote><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互<br>如果两个 URL 的协议、端口（如果有指定的话）和主机都相同的话，则这两个 URL 是同源的</p></blockquote><h3 id="Ajax-为什么不能跨域"><a href="#Ajax-为什么不能跨域" class="headerlink" title="Ajax 为什么不能跨域"></a>Ajax 为什么不能跨域</h3><p>·Ajax 跨域请求，在服务器端不会有任何问题，只是服务端响应数据返回给浏览器的时候，浏览器根据响应头的 Access-Control-Allow-Origin 字段的值来判断是否有权限获取数据。<br>因此，服务端如果没有设置跨域字段设置，跨域是没有权限访问，数据被浏览器给拦截了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>JSONP(JSON with Padding（填充）)</p><blockquote><p>利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Jsonp</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">req</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = req.<span class="hljs-property">url</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackName</span> = req.<span class="hljs-property">callbackName</span><br>  &#125;<br>  <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.url&#125;</span>?callback=<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.callbackName&#125;</span>`</span><br>    script.<span class="hljs-property">src</span> = url<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Jsonp</span>(&#123;<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://127.0.0.1:8000/&#x27;</span>,<br>  <span class="hljs-attr">callbackName</span>: <span class="hljs-string">&#x27;getMsg&#x27;</span>,<br>&#125;).<span class="hljs-title function_">create</span>()<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMsg</span>(<span class="hljs-params">data</span>) &#123;<br>  data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`My name is <span class="hljs-subst">$&#123;data.name&#125;</span>, and <span class="hljs-subst">$&#123;data.age&#125;</span> years old.`</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>CORS”跨域资源共享”(Cross-origin resource sharing)</p><blockquote><p>原理：它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。<br>方法：服务端需要设置响应头中的 Access-Control-Allow-Origin 字段来指定允许的源。</p></blockquote><p>CORS 请求分成两类：简单请求和非简单请求</p><ol><li><p>简单请求：<code>请求方法</code>是以下三种方法之一：<code>HEAD、GET、POST</code>；<code>HTTP 头信息</code>不超出以下几种字段：<code>Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type</code>（只限于三个值：<code>application/x-www-form-urlencoded、multipart/form-data、text/plain</code>）<br>基本流程 对于简单请求，<code>浏览器直接发出CORS请求</code>。具体来说，就是在头信息之中，<code>增加一个Origin字段</code>。服务器根据这个字段，决定是否同意这次请求。如果 Origin 字段是服务器认可的域名，<code>服务器返回的响应</code>，会<code>多出几个头信息字段</code>，其中就包括<code>Access-Control-Allow-Origin</code>字段。浏览器发现这个头信息之后，就知道了，这个请求是被服务器认可的，可以正常通信。</p></li><li><p>非简单请求：非简单请求会在正式通信之前，增加一次 HTTP 查询请求，称为”预检请求”（preflight）。浏览器会先询问服务器，当前网页所在的域名是否在<code>服务器的许可名单</code>之中，以及可以使用<code>哪些 HTTP 动词和头信息字段</code>。也就是说浏览器会发送两次 http 请求。第一次 Request Method: OPTIONS,第二次再请求所需内容。</p></li><li><p>withCredentials 属性<br>CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要<code>发送 Cookie</code>，需要<code>打开 withCredentials 属性</code>。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//xhr</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//axios</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//服务器</span><br>res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>代理 Proxy<br>在同域的服务器上设置一个代理，由代理服务器去请求其他域上的资源，再将结果返回给前端。这样，前端只需要请求同域的资源，就能避免跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//vite</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&#x27;&#x27;</span>),<br>        <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用自动携带 Cookie</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">//webpack</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">export</span> = &#123;<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:3000&#x27;</span>,<br>        <span class="hljs-attr">pathRewrite</span>: &#123; <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-comment">// 携带 Cookie 需要设置 cookieDomainRewrite</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>WebSocket 协议跨域</p><blockquote><p>它实现了浏览器与服务器全双工通信，同时允许跨域通讯<br>没有同源限制，客户端可以与任意服务器通信。协议标识符是 ws（如果加密，则为 wss），服务器网址就是 URL。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8080&#x27;</span>)<br><br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection open ...&#x27;</span>)<br>  socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Hello Server!&#x27;</span>)<br>&#125;)<br><br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Message from server: &#x27;</span>, event.<span class="hljs-property">data</span>)<br>  socket.<span class="hljs-title function_">close</span>()<br>&#125;)<br><br>socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection closed.&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>postMessage</p></li><li><p>nginx 反向代理</p></li><li><p>iframe+document.domain</p></li></ol><h2 id="4-http-x2F-https-和-优化-和-https-握手"><a href="#4-http-x2F-https-和-优化-和-https-握手" class="headerlink" title="4. http&#x2F;https 和 优化 和 https 握手"></a>4. http&#x2F;https 和 优化 和 https 握手</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><blockquote><p>HTTP (HyperText Transfer Protocol)，即<code>超文本运输协议</code>，是<code>实现网络通信的一种规范</code><br>在实际应用中，HTTP 常被用于在浏览器和服务器之间传递信息，以<code>明文方式</code>发送内容，<code>不提供任何方式的数据加密</code></p></blockquote><p><strong>特点如下：</strong></p><ol><li>支持客户&#x2F;服务器模式</li><li><code>简单快速</code>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的<code>程序规模小</code>，因而<code>通信速度很快</code></li><li><code>灵活</code>：HTTP 允许传输<code>任意类型</code>的数据对象。正在传输的类型由 Content-Type 加以标记</li><li><code>无连接</code>：无连接的含义是限制每次连接<code>只处理一个请求</code>。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li><code>无状态</code>：HTTP 协议<code>无法根据之前的状态</code>进行本次的请求处理</li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote><p>HTTPS 出现正是为了<code>解决 HTTP 不安全</code>的特性<br>为了保证这些隐私数据能加密传输，让 HTTP 运行安全的 SSL&#x2F;TLS 协议上，即 <code>HTTPS = HTTP + SSL/TLS</code>，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的<code>通信进行加密</code><br>SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p></blockquote><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程:**"></a>加密过程:**</h4><ol><li>首先客户端通过 URL 访问服务器建立 SSL 连接</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>服务器利用自己的私钥解密出会话密钥</li><li>服务器利用会话密钥加密与客户端之间的通信</li></ol><h4 id="如何解决安全问题："><a href="#如何解决安全问题：" class="headerlink" title="如何解决安全问题："></a>如何解决安全问题：</h4><ol><li><p>混合加密技术<br>HTTPS 采用「混合加密」：</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul></li><li><p>摘要算法 + 数字签名<br>摘要算法（哈希函数）来计算出内容的哈希值，这个哈希值是唯一的。<br>通过「私钥加密，公钥解密」的方式，来确认消息的身份，对内容的哈希值加密。</p><img src="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/SSL.webp" class title="This is an test image"></li><li><p>数字证书<br>数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场<br>设有服务器 S，客户端 C，和第三方信赖机构 CA。<br>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。<br>S 获得 CA 颁发的证书，将该证书传递给 C。<br>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。<br>CA 对公钥的签名认证</p></li></ol><h4 id="HTTPS-如何建立连接"><a href="#HTTPS-如何建立连接" class="headerlink" title="HTTPS 如何建立连接"></a>HTTPS 如何建立连接</h4><h3 id="区别如下："><a href="#区别如下：" class="headerlink" title="区别如下："></a>区别如下：</h3><ol><li>HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL&#x2F;TLS 协议进行了加密处理，相对更安全</li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443</li><li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li><li>HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高</li></ol><h3 id="HTTP-优化"><a href="#HTTP-优化" class="headerlink" title="HTTP 优化"></a>HTTP 优化</h3><ol><li>避免发送 HTTP 请求？</li></ol><ul><li>使用缓存</li></ul><ol start="2"><li>减少 HTTP 请求次数</li></ol><ul><li>合并文件(合并 CSS、JS 文件, 雪碧图)</li><li>使用 CDN 加速</li><li>延迟发送请求（懒加载、预加载）</li></ul><ol start="3"><li>减少请求资源大小</li></ol><ul><li>压缩文件（Gzip、Brotli）</li></ul><h3 id="HTTPS-优化"><a href="#HTTPS-优化" class="headerlink" title="HTTPS 优化"></a>HTTPS 优化</h3><blockquote><p>产生性能消耗的两个环节：<br>第一个环节， TLS 协议握手过程；<br>第二个环节，握手后的对称加密报文传输。</p></blockquote><ol><li>硬件加速<ul><li>HTTPS 协议是计算密集型；可以提高计算性能 CPU<code>支持 AES-NI 特性的 CPU</code></li></ul></li><li>软件加速</li><li>协议优化<ul><li>TLS 1.3<br>TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手(<code>完成 TLS 握手只要 1 RTT</code>)<br>TLS1.3 对密码套件进行“减肥”了， 对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 <code>ECDHE 算法</code></li></ul></li><li>会话复用<ul><li>Session ID：客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识</li><li>Session Ticket：服务器会把会话密钥加密后，发送给客户端，客户端保存在本地，下次握手时，直接使用这个会话密钥</li></ul></li></ol><h3 id="TLS-握手过程"><a href="#TLS-握手过程" class="headerlink" title="TLS 握手过程"></a>TLS 握手过程</h3><blockquote><p>TLS 的「握手阶段」涉及<code>四次通信</code>，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：<code>RSA 算法</code> (opens new window)和 <code>ECDHE 算法</code> (opens new window)。</p></blockquote><ol><li><p>ClientHello 请求</p><blockquote><p>客户端向服务器发起<code>加密通信请求</code>，也就是<code>ClientHello 请求</code>。</p></blockquote><ul><li>客户端支持的 <code>TLS 协议版本</code>，如 TLS 1.2 版本。</li><li>客户端生产的<code>随机数</code>（Client Random），后面用于<code>生成「会话秘钥」条件</code>之一。</li><li>客户端支持的<code>密码套件列表</code>，如 RSA 加密算法。</li></ul></li><li><p>SeverHello 请求</p><blockquote><p>服务器收到客户端请求后，向客户端发出<code>响应</code>，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p></blockquote><ul><li><code>确认 TLS 协议版本</code>，如果浏览器不支持，则关闭加密通信。</li><li><code>服务器生产的随机数</code>（Server Random），也是后面用于生产「会话秘钥」条件之一。</li><li><code>确认的密码套件列表</code>，如 RSA 加密算法。</li><li>服务器的<code>数字证书</code>。</li></ul></li><li><p>客户端回应</p><blockquote><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，<code>确认服务器的数字证书的真实性</code>。<br>如果证书没有问题，客户端会从数字证书中<code>取出服务器的公钥</code>，然后<code>使用它加密报文</code>向服务器发送如下信息：</p></blockquote><ul><li>一个<code>随机数（pre-master key）</code>。该随机数会被服务器<code>公钥加密</code>。</li><li><code>加密通信算法改变通知</code>，表示随后的信息都将用「会话秘钥」加密通信。</li><li><code>客户端握手结束通知</code>，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul></li><li><p>服务器的最后回应</p><blockquote><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。<br>然后，向客户端发送最后的信息：</p></blockquote><ul><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ul></li></ol><h2 id="5-说说地址栏输入-URL-敲下回车后发生了什么"><a href="#5-说说地址栏输入-URL-敲下回车后发生了什么" class="headerlink" title="5. 说说地址栏输入 URL 敲下回车后发生了什么?"></a>5. 说说地址栏输入 URL 敲下回车后发生了什么?</h2><ol><li>URL 解析<blockquote><p>首先会对 URL 进行解析，分析所需要使用的传输<code>协议</code>和请求的资源的<code>路径</code>。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p></blockquote></li><li>DNS 查询<blockquote><p>首先会判断<code>本地</code>是否有该域名的 IP 地址的<code>缓存</code>，如果有则使用，如果没有则向<code>本地 DNS 服务器</code>发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向<code>根域名服务器</code>发起请求，获得负责的<code>顶级域名服务器</code>的地址后，再向<code>顶级域名服务器</code>请求，然后获得负责的<code>权威域名服务器</code>的地址后，再向<code>权威域名服务器</code>发起请求，最终获得<code>域名的 IP 地址</code>后，<code>本地 DNS 服务器</code>再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于<code>递归请求</code>，本地 DNS 服务器向各级域名服务器发起请求属于<code>迭代请求</code>。</p></blockquote></li><li>TCP 连接<ul><li>第一次握手：客户端会<code>随机初始化序号</code>（client_isn），同时把 <code>SYN 标志位置</code>为 1，表示 <code>SYN 报文</code>。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT 状态</code>。</li><li>第二次握手：服务端收到客户端的 SYN 报文后，首先服务端也<code>随机初始化自己的序号</code>（server_isn），其次把 TCP 首部的<code>「确认应答号」ack</code>字段填入 client_isn + 1, 接着把 <code>SYN 和 ACK 标志位置为 1</code>。最后把该报文发给客户端，之后服务端处于 <code>SYN-RCVD 状态</code>。</li><li>第三次握手：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK 标志位置为 1</code> ，其次<code>「确认应答号」ack</code>字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED 状态</code>。<br>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED 状态</code>。</li><li>三次握手的目的是为了确认双方的发送能力和接收能力。在第一次握手中，客户端确认自己的发送功能正常，并等待服务器的确认。在第二次握手中，服务器确认客户端的接收功能正常，并确认自己的发送功能正常。在第三次握手中，客户端确认服务器的接收功能正常，并确认自己的发送功能正常。这样，双方都确认了对方的发送和接收能力，可以开始数据传输。</li></ul></li><li>HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ol><h2 id="6-说说-HTTP-常见的状态码有哪些，适用场景？"><a href="#6-说说-HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="6. 说说 HTTP 常见的状态码有哪些，适用场景？"></a>6. 说说 HTTP 常见的状态码有哪些，适用场景？</h2><blockquote><p>HTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码</p></blockquote><p><strong>状态码第一位数字决定了不同的响应状态，有如下：</strong></p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><blockquote><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p></blockquote><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><blockquote><p>代表请求已成功被服务器接收、理解、并接受</p></blockquote><ul><li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p></blockquote><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><blockquote><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p></blockquote><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul><h3 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景"></a>三、适用场景</h3><ul><li>100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输</li><li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li><li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名</li><li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li><li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>400：参数有误，请求无法被服务器识别</li><li>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回</li><li>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li><li>503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503</li><li>504：网关超时</li></ul><h2 id="7-说一下-GET-和-POST-的区别？"><a href="#7-说一下-GET-和-POST-的区别？" class="headerlink" title="7. 说一下 GET 和 POST 的区别？"></a>7. 说一下 GET 和 POST 的区别？</h2><blockquote><p>GET 用于从服务器获取数据<br>POST 用于向服务器提交数据</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p>数据方面</p><ul><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。<br>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li></ul></li><li><p>安全方面<br>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。<br>POST 参数不会被保存在浏览器历史或 web 服务器日志中。</p></li><li><p>缓存方面<br>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。<br>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。<br>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。<br>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</p></li><li><p>数据包</p><ul><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li><li>对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok<blockquote><p>并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次</p></blockquote></li></ul></li></ol><h2 id="8-WebSocket"><a href="#8-WebSocket" class="headerlink" title="8. WebSocket"></a>8. WebSocket</h2><blockquote><p>WebSocket 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。</p></blockquote><ol><li>WebSocket 协议本质上是<code>应用层的协议</code>，用于弥补 HTTP 协议在<code>持久通信能力</code>上的不足。客户端和服务器仅需<code>一次</code>握手，两者之间就直接可以<code>创建持久性的连接</code>，并进行双向数据传输。</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>它适用于需要服务器和客户端（浏览器）频繁交互的大部分场景</li></ol><h2 id="9-OSI-七层模型-TCP-x2F-IP-4-层模型"><a href="#9-OSI-七层模型-TCP-x2F-IP-4-层模型" class="headerlink" title="9. OSI 七层模型,TCP&#x2F;IP 4 层模型"></a>9. OSI 七层模型,TCP&#x2F;IP 4 层模型</h2><h3 id="1-OSI-七层模型"><a href="#1-OSI-七层模型" class="headerlink" title="1. OSI 七层模型"></a>1. OSI 七层模型</h3><blockquote><p>OSI （Open System Interconnect）模型全称为开放式通信系统互连参考模型，OSI 将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰</p></blockquote><ol><li>应用层<blockquote><p>主要提供两个终端设备上的<code>应用程序之间信息交换</code>的服务，它定义了<code>信息交换的格式</code>，我们把<code>应用层交互的数据单元称为报文</code>。</p></blockquote></li></ol><p><strong>应用层协议定义了网络通信规则:</strong></p><pre><code class="hljs">- HTTP（Hypertext Transfer Protocol，超文本传输协议）- FTP（File Transfer Protocol，文件传输协议）- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）- POP3（Post Office Protocol Version 3，邮局协议第三版）- IMAP（Internet Message Access Protocol，互联网消息访问协议）- DNS（Domain Name System，域名系统）</code></pre><ol start="2"><li><p>表示层</p><blockquote><p>主要负责<code>数据的转换，加密和压缩</code>，确保一个设备的应用层发送的信息可以被另一个设备的应用层读取</p></blockquote></li><li><p>会话层</p><blockquote><p>会话层就是<code>负责建立、管理和终止表示层实体之间的通信会话</code>，确保通信双方能够互相传输数据</p></blockquote></li><li><p>传输层</p><blockquote><p>传输层的主要任务就是<code>负责向两台终端设备进程之间的通信提供通用的数据传输服务</code>。 应用进程利用该服务传送应用层报文<br>主要负责<code>数据的传输</code>，确保数据的可靠传输，传输层的协议有 TCP 和 UDP</p></blockquote></li><li><p>网络层</p><blockquote><p>网络层把传输层产生的报文或用户数据报<code>封装成分组和包</code>，向下传输到数据链路层<br>网络层的还有一个任务就是<code>选择合适的路由</code>，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</p></blockquote></li><li><p>数据链路层</p><blockquote><p>数据链路层的主要任务是将网络层传下来的 IP 数据报<code>封装成帧</code>，然后通过物理层进行传输<br>数据链路层的主要功能是进行<code>差错检测和纠正</code>，确保数据的可靠传输</p></blockquote></li><li><p>物理层</p><blockquote><p>实现计算机节点之间<code>比特流的透明传送</code>;该层主要是和硬件有关，与软件关系不大</p></blockquote></li></ol><h3 id="2-TCP-x2F-IP-4-层模型"><a href="#2-TCP-x2F-IP-4-层模型" class="headerlink" title="2. TCP&#x2F;IP 4 层模型"></a>2. TCP&#x2F;IP 4 层模型</h3><ol><li>应用层<blockquote><p>应用层位于传输层之上，主要提供<code>两个终端设备上的应用程序之间信息交换的服务</code>，它定义了<code>信息交换的格式</code>，消息会交给下一层传输层来传输。<br>应用层的协议有 HTTP、FTP、SMTP、POP3、IMAP、DNS 等</p></blockquote></li><li>传输层<blockquote><p>传输层的主要任务就是负责向<code>两台终端设备进程之间的通信提供通用的数据传输服务</code>。<br>传输层的协议有 TCP 和 UDP</p></blockquote></li><li>网络层<blockquote><p>负责为分组网络中的不同主机提供通信服务，并通过<code>选择合适的路由</code>将数据传递到目标主机;在发送数据时，网络层把运输层产生的<code>报文段或用户数据封装成分组或包</code>进行传送<br>网络层的协议有 IP、ICMP、ARP、RARP、OSPF、BGP、IGMP 等</p></blockquote></li><li>网络接口层<blockquote><p>数据链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。数据链路层的作用是将网络层交下来的 <code>IP 数据报组装成帧</code>，在<code>两个相邻节点间的链路上传送帧</code>。<br>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异<br>数据链路层的协议有 MAC、CSMA&#x2F;CD 等</p></blockquote></li></ol><img src="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/network.png" class title="This is an test image"><h2 id="10-TCP-UDP"><a href="#10-TCP-UDP" class="headerlink" title="10. TCP\UDP"></a>10. TCP\UDP</h2><blockquote><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。(一定是「一对一」才能连接)、(TCP 都可以保证一个报文一定能够到达接收端)、(消息可能会被操作系统「分组」成多个的 TCP 报文)</p></blockquote><h3 id="1-TCP-头格式"><a href="#1-TCP-头格式" class="headerlink" title="1. TCP 头格式"></a>1. TCP 头格式</h3><img src="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/TCP.webp" class title="This is an test image"><blockquote><p>序列号：在建立连接时由计算机生成的<code>随机数</code>作为其<code>初始值</code>，通过 <code>SYN 包</code>传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来<code>解决网络包乱序</code>问题。</p></blockquote><blockquote><p>确认应答号：指下一次「<code>期望」收到的数据的序列号</code>，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来<code>解决丢包的问题</code>。</p></blockquote><blockquote><p>控制位：</p></blockquote><ul><li>ACK：该位为 1 时，<code>「确认应答」的字段变为有效</code>，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</li><li>RST：该位为 1 时，表示 TCP 连接中出现<code>异常必须强制断开连接</code>。</li><li>SYN：该位为 1 时，表示<code>希望建立连接</code>，并在其「序列号」的字段进行<code>序列号初始值</code>的设定。</li><li>FIN：该位为 1 时，表示今后不会再有数据发送，<code>希望断开连接</code>。当通信结束希望断开连接时，通信双方的主机之间就可以<code>相互交换 FIN 位为 1 的 TCP 段</code>。</li></ul><h3 id="2-UDP-头格式"><a href="#2-UDP-头格式" class="headerlink" title="2. UDP 头格式"></a>2. UDP 头格式</h3><img src="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/UDP.webp" class title="This is an test image"><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><h3 id="3-TCP-和-UDP-的区别"><a href="#3-TCP-和-UDP-的区别" class="headerlink" title="3. TCP 和 UDP 的区别"></a>3. TCP 和 UDP 的区别</h3><ol><li><p>TCP（Transmission Control Protocol，传输控制协议）</p><blockquote><p>一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送</p></blockquote><ol><li>TCP 充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。<br>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li></ol></li><li><p>UDP（User Datagram Protocol）</p><blockquote><p>用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层</p></blockquote><ol><li>UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务</li><li>传输途中出现丢包，UDP 也不负责重发</li><li>当包的到达顺序出现乱序时，UDP 没有纠正的功能。</li><li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为</li></ol></li></ol><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>可靠性</td><td>可靠(数据可以无差错、不丢失、不重复、按序到达)</td><td>不可靠(不保证可靠交付数据)</td></tr><tr><td>连接性</td><td>面向连接(传输数据前先要建立连接)</td><td>无连接(不需要连接，即刻传输数据)</td></tr><tr><td>报文</td><td>面向字节流</td><td>面向报文</td></tr><tr><td>效率</td><td>传输效率低</td><td>传输效率高</td></tr><tr><td>双共性</td><td>全双工</td><td>一对一、一对多、多对一、多对多</td></tr><tr><td>流量控制</td><td>滑动窗口</td><td>无</td></tr><tr><td>拥塞控制</td><td>慢开始、拥塞避免、快重传、快恢复</td><td>无</td></tr><tr><td>传输效率</td><td>慢</td><td>快</td></tr></tbody></table><h3 id="4-TCP-如何保证传输的可靠性？"><a href="#4-TCP-如何保证传输的可靠性？" class="headerlink" title="4. TCP 如何保证传输的可靠性？"></a>4. TCP 如何保证传输的可靠性？</h3><ol><li>基于数据块传输<blockquote><p>应用数据被分割成 TCP 认为最适合发送的<code>数据块</code>，再传输给网络层，数据块被称为<code>报文段或段</code>。</p></blockquote></li><li>对失序数据包重新排序以及去重<blockquote><p>TCP 为了保证不发生丢包，就给<code>每个包一个序列号</code>，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</p></blockquote></li><li>校验和<blockquote><p>TCP 将保持它<code>首部和数据的检验和</code>。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p></blockquote></li></ol><h4 id="4-重传机制"><a href="#4-重传机制" class="headerlink" title="4. 重传机制"></a>4. 重传机制</h4><blockquote><p>在数据包<code>丢失或延迟</code>的情况下，<code>重新发送数据包</code>，直到收到对方的<code>确认应答（ACK）</code>。<br><strong>TCP 重传机制主要有：</strong></p></blockquote><ul><li>基于计时器的重传（也就是超时重传）</li><li>快速重传（基于接收端的反馈信息来引发重传）</li><li>SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）</li><li>D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）</li></ul><h4 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h4><blockquote><p>TCP 连接的每一方都有<code>固定大小的缓冲空间</code>，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<code>滑动窗口协议</code>（TCP 利用滑动窗口实现流量控制）。</p></blockquote><p><strong>TCP 如何实现流量控制？</strong></p><blockquote><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p></blockquote><ol><li>为什么需要流量控制？</li></ol><blockquote><p>这是因为双方在通信的时候，<code>发送方的速率与接收方的速率是不一定相等</code>，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在<code>接收缓冲区(Receiving Buffers)</code> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，<code>接收方只能把收到的数据包丢掉</code>。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p></blockquote><ol start="2"><li><p>滑动窗口分类<br>发送方</p><blockquote><p>已发送并确认的、已发送未确认、即将发送、不可发送的</p></blockquote><p>接收方</p><blockquote><p>以接收并确认的、可以接收未确认、不可接收的</p></blockquote></li></ol><h4 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h4><blockquote><p>当网络拥塞时，<code>减少数据的发送</code>。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的<code>接收能力</code>，二是网络的<code>拥塞程度</code>。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</p></blockquote><p><strong>TCP 如何实现拥塞控制？</strong></p><blockquote><p>由于网络中的<code>流量过大</code>超过了网络设备的处理能力，导致数据包<code>无法及时传递或丢失</code>的现象。<br>拥塞控制就是为了<code>防止过多的数据注入</code>到网络中，这样就可以使网络中的路由器或链路<code>不致过载</code>。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个<code>全局性</code>的过程，涉及到<code>所有的主机</code>，<code>所有的路由器</code>，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是<code>点对点通信量的控制</code>，是个<code>端到端</code>的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd)</p></blockquote><ol><li><p>慢开始<br>由小到大逐渐增大发送窗口，<code>也就是由小到大逐渐增大拥塞窗口数值</code>。<code>cwnd 初始值为 1</code>，每经过一个传播轮次，cwnd 加倍。<br>慢启动门限 ssthresh （slow start threshold）状态变量。</p><p>1.5. 慢启动算法。</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢启动算法。</li><li>当 cwnd &gt;&#x3D; ssthresh 时，就会使用「拥塞避免算法」。</li></ul></li><li><p>拥塞避免<br>拥塞避免算法的思路是<code>让拥塞窗口 cwnd 缓慢增大</code>，即每经过一个<code>往返时间 RTT </code>就把发送方的<code> cwnd 加 1</code>.</p><p>2.5. 当收到三个重复的 ACK 时，触发快速恢复算法。</p></li><li><p>快重传、快恢复</p><ol><li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li><li>ssthresh &#x3D; cwnd;<br>然后，进入快速恢复算法如下：</li><li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ol></li></ol><h3 id="5-TCP-三次握手"><a href="#5-TCP-三次握手" class="headerlink" title="5. TCP 三次握手"></a>5. TCP 三次握手</h3><ol><li>第一次握手：客户端会<code>随机初始化序号</code>（client_isn），同时把 <code>SYN 标志位置</code>为 1，表示 <code>SYN 报文</code>。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT 状态</code>。</li><li>第二次握手：服务端收到客户端的 SYN 报文后，首先服务端也<code>随机初始化自己的序号</code>（server_isn），其次把 TCP 首部的<code>「确认应答号」ack</code>字段填入 client_isn + 1, 接着把 <code>SYN 和 ACK 标志位置为 1</code>。最后把该报文发给客户端，之后服务端处于 <code>SYN-RCVD 状态</code>。</li><li>第三次握手：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK 标志位置为 1</code> ，其次<code>「确认应答号」ack</code>字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED 状态</code>。<br>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED 状态</code>。</li></ol><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><ol><li>三次握手才可以阻止重复历史连接的初始化（主要原因）<blockquote><p>三次握手的首要原因是为了防止旧的重复连接初始化造成混乱</p></blockquote><ol><li>一个<code>「旧 SYN 报文」比「最新的 SYN」 报文</code>早到达了服务端，那么此时服务端就会回一个 SYN + ACK 报文给客户端，此报文中的确认号是 91（90+1）。</li><li>客户端收到后，发现自己期望收到的确认号应该是 100 + 1，而不是 90 + 1，于是就会<code>回 RST 报文</code>。</li><li>服务端收到 RST 报文后，就会<code>释放连接</code>。</li><li>后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。</li></ol></li><li>三次握手才可以同步双方的初始序列号<br>四次握手其实也能够可靠的同步双方的初始化序号，但<code>由于第二步和第三步可以优化成一步</code>，所以就成了「三次握手」。<br>而两次握手<code>只保证了一方</code>的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</li><li>确认双方的接收能力<ol><li>服务端在第二次握手时，会把客户端的序列号 + 1 作为确认号，这样就可以确认客户端的接收能力。</li><li>客户端在第三次握手时，会把服务端的序列号 + 1 作为确认号，这样就可以确认服务端的接收能力。</li></ol></li></ol><h4 id="为什么初始化序号要随机？"><a href="#为什么初始化序号要随机？" class="headerlink" title="为什么初始化序号要随机？"></a>为什么初始化序号要随机？</h4><blockquote><p>起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。<br>ISN &#x3D; M(M 是一个计时器，这个计时器每隔 4 微秒加 1) + F(F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值)。</p></blockquote><ol><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）<blockquote><p>如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。</p></blockquote></li><li>为了防止攻击者通过猜测序列号来发起攻击<blockquote><p>如果初始化序号是固定的，那么攻击者可以通过猜测序列号来发起攻击，比如 SYN Flood 攻击。</p></blockquote></li></ol><h3 id="6-TCP-四次挥手"><a href="#6-TCP-四次挥手" class="headerlink" title="6. TCP 四次挥手"></a>6. TCP 四次挥手</h3><ol><li>第一次挥手：客户端<code>发送一个 FIN 报文</code>，报文中会指定一个<code>序列号</code>。此时客户端处于 <code>FIN_WAIT1</code> 状态，停止发送数据，等待服务端的确认</li><li>第二次挥手：服务端<code>收到 FIN </code>之后，会<code>发送 ACK 报文</code>，且把<code>客户端的序列号值 +1 作为 ACK 报文的序列号值</code>，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态</li><li>第三次挥手：如果<code>服务端也想断开连接</code>了，和客户端的第一次挥手一样，发给 <code>FIN 报文</code>，且指定一个<code>序列号</code>。此时服务端处于 <code>LAST_ACK</code> 的状态</li><li>第四次挥手：<code>客户端收到 FIN</code> 之后，一样发送一个 <code>ACK 报文</code>作为应答，且把<code>服务端的序列号值 +1 作为自己 ACK 报文的序列号值</code>，此时客户端处于 <code>TIME_WAIT</code> 状态。需要<code>过一阵子(2MSL)</code>以确保服务端收到自己的 ACK 报文之后才会进入 <code>CLOSED 状态</code>，服务端收到 ACK 报文之后，就处于关闭连接了，处于<code> CLOSED</code> 状态</li></ol><h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><ol><li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。</li></ol><h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><ol><li>为什么需要 TIME_WAIT 状态</li></ol><ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收(2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。)</li><li>保证「被动关闭连接」的一方，能被正确的关闭(等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。)</li></ul><h2 id="11-IP"><a href="#11-IP" class="headerlink" title="11. IP"></a>11. IP</h2><h3 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h3><img src="/2024/02/28/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/IP.webp" class title="This is an test image"><ol><li>A 类地址： 范围：0.0.0.0 - 127.255.255.255 (1 分类，7 位网络号，24 位主机号)</li><li>B 类地址： 范围：128.0.0.0 - 191.255.255.255 (2 分类，14 位网络号，16 位主机号)</li><li>C 类地址： 范围：192.0.0.0 - 223.255.255.255 (3 分类，21 位网络号，8 位主机号)<blockquote><p>C 类地址的最大主机个数是 2^8 - 2 &#x3D; 254 个，因为主机号全 0 和全 1 分别表示网络地址和广播地址。</p></blockquote></li><li>D 类地址： (4 分类，用于多点广播)<blockquote><p>多播用于将包发送给特定组内的所有主机。</p></blockquote></li><li>E 类地址： (4 分类，保留)</li></ol><h3 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h3><blockquote><p>这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。<br>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于网络号(10.100.122.2&#x2F;24，这种地址表示形式就是 CIDR，&#x2F;24 表示前 24 位是网络号，剩余的 8 位是主机号。)</p></blockquote><p>将子网掩码和 IP 地址按位计算 AND，就可得到网络号<br>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址</p><h3 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h3><ol><li><p>DNS</p></li><li><p>ARP</p><blockquote><p>全称 <code>地址解析协议（Address Resolution Protocol）</code>，它解决的是<code>网络层地址和链路层地址</code>之间的<code>转换问题</code>。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了<code> IP 地址转 MAC 地址</code>的一些问题</p></blockquote><p><strong>流程:</strong></p><ol><li>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li><li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li></ol></li><li><p>NAT</p><blockquote><p>网络地址转换 NAT （Network Address Translation）应用于<code>内部网到外部网的地址</code>转换过程中</p></blockquote></li><li><p>ICMP</p><blockquote><p>ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。<br>ICMP 主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p></blockquote></li></ol><h3 id="ping-的工作原理"><a href="#ping-的工作原理" class="headerlink" title="ping 的工作原理"></a>ping 的工作原理</h3><blockquote><p>ping 是基于 ICMP 协议工作的</p></blockquote><h1 id="7-uni-app"><a href="#7-uni-app" class="headerlink" title="7. uni-app"></a>7. uni-app</h1><h1 id="8-算法"><a href="#8-算法" class="headerlink" title="8. 算法"></a>8. 算法</h1><h2 id="dp-动态规划"><a href="#dp-动态规划" class="headerlink" title="dp 动态规划"></a>dp 动态规划</h2><h2 id="wxp-hardman"><a href="#wxp-hardman" class="headerlink" title="wxp:hardman"></a>wxp:hardman</h2><blockquote><p>实现一个 HardMan:</p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">HardMan</span><span class="hljs-params">(<span class="hljs-string">&quot;jack&quot;</span>)</span></span> 输出:<br>I am jack<br><br><span class="hljs-function"><span class="hljs-title">HardMan</span><span class="hljs-params">(<span class="hljs-string">&quot;jack&quot;</span>)</span></span><span class="hljs-selector-class">.rest</span>(<span class="hljs-number">10</span>)<span class="hljs-selector-class">.learn</span>(<span class="hljs-string">&quot;computer&quot;</span>) 输出<br>I am jack<br><span class="hljs-comment">//等待10秒</span><br>Start learning after <span class="hljs-number">10</span> seconds<br>Learning computer<br><br><span class="hljs-function"><span class="hljs-title">HardMan</span><span class="hljs-params">(<span class="hljs-string">&quot;jack&quot;</span>)</span></span><span class="hljs-selector-class">.restFirst</span>(<span class="hljs-number">5</span>)<span class="hljs-selector-class">.learn</span>(<span class="hljs-string">&quot;chinese&quot;</span>) 输出<br><span class="hljs-comment">//等待5秒</span><br>Start learning after <span class="hljs-number">5</span> seconds<br>I am jack<br>Learning chinese<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hardMan</span>(<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = []<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = str<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">next</span>()<br>  &#125;)<br>&#125;<br><br>hardMan.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">rest</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">wait</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Start learning after <span class="hljs-subst">$&#123;wait&#125;</span> seconds`</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">next</span>()<br>    &#125;, wait * <span class="hljs-number">1000</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(func)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;<br><br>hardMan.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">restFirst</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">wait</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Start learning after <span class="hljs-subst">$&#123;wait&#125;</span> seconds`</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">next</span>()<br>    &#125;, wait * <span class="hljs-number">1000</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">unshift</span>(func)<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>&#125;<br><br>hardMan.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">learn</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Learning <span class="hljs-subst">$&#123;str&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(func)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">next</span>()<br>&#125;<br>hardMan.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> func = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>()<br>  <span class="hljs-title function_">func</span>()<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">HardMan</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">hardMan</span>(<span class="hljs-string">&#x27;jack&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="9-操作系统"><a href="#9-操作系统" class="headerlink" title="9. 操作系统"></a>9. 操作系统</h1><h2 id="1-什么是进程和线程"><a href="#1-什么是进程和线程" class="headerlink" title="1. 什么是进程和线程"></a>1. 什么是进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote><p>操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位</p></blockquote><p>进程是一种抽象的概念，从来没有统一的标准定义看，一般由<code>程序</code>、<code>数据集合</code>和<code>进程控制块</code>三部分组成：</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote><p>线程（thread）是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p></blockquote><h1 id="10-场景题"><a href="#10-场景题" class="headerlink" title="10. 场景题"></a>10. 场景题</h1><h2 id="1-在-JS-缓存中有一个数据量很大的列表，不用分页处理，如何保证它加载到页面里不卡顿？"><a href="#1-在-JS-缓存中有一个数据量很大的列表，不用分页处理，如何保证它加载到页面里不卡顿？" class="headerlink" title="1. 在 JS 缓存中有一个数据量很大的列表，不用分页处理，如何保证它加载到页面里不卡顿？"></a>1. 在 JS 缓存中有一个数据量很大的列表，不用分页处理，如何保证它加载到页面里不卡顿？</h2><h3 id="1-分页加载"><a href="#1-分页加载" class="headerlink" title="1. 分页加载"></a>1. 分页加载</h3><h3 id="2-虚拟滚动"><a href="#2-虚拟滚动" class="headerlink" title="2. 虚拟滚动"></a>2. 虚拟滚动</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: containerHeight &#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; transform: `translateY($&#123;translateY&#125;)` &#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in listData&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; height: itemHeight &#125;&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      &#123;&#123; item &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> oriData = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; <span class="hljs-attr">length</span>: <span class="hljs-number">1000</span> &#125;, <span class="hljs-function">(<span class="hljs-params">v, k</span>) =&gt;</span> k)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> itemHeight = <span class="hljs-number">20</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> emptyHeight = itemHeight * oriData.<span class="hljs-property">length</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> containerHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> itemCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(containerHeight / itemHeight)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> container = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> start = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> translateY = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> listData = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> oriData.<span class="hljs-title function_">slice</span>(start.<span class="hljs-property">value</span>, start.<span class="hljs-property">value</span> + itemCount + <span class="hljs-number">1</span>)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    container.<span class="hljs-property">value</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> &#123; scrollTop &#125; = e.<span class="hljs-property">target</span></span><br><span class="language-javascript">      start.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / itemHeight)</span><br><span class="language-javascript">      translateY.<span class="hljs-property">value</span> = scrollTop + <span class="hljs-string">&#x27;px&#x27;</span></span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">    listData,</span><br><span class="language-javascript">    container,</span><br><span class="language-javascript">    translateY,</span><br><span class="language-javascript">    <span class="hljs-attr">containerHeight</span>: containerHeight + <span class="hljs-string">&#x27;px&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">itemHeight</span>: itemHeight + <span class="hljs-string">&#x27;px&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">emptyHeight</span>: emptyHeight + <span class="hljs-string">&#x27;px&#x27;</span>,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-给出虚拟-dom-的数据结构，如何实现简单的虚拟-dom，渲染到目标-dom-树"><a href="#2-给出虚拟-dom-的数据结构，如何实现简单的虚拟-dom，渲染到目标-dom-树" class="headerlink" title="2. 给出虚拟 dom 的数据结构，如何实现简单的虚拟 dom，渲染到目标 dom 树"></a>2. 给出虚拟 dom 的数据结构，如何实现简单的虚拟 dom，渲染到目标 dom 树</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 样例数据</span><br><span class="hljs-keyword">let</span> demoNode = &#123;<br>  <span class="hljs-attr">tagName</span>: <span class="hljs-string">&#x27;ul&#x27;</span>,<br>  <span class="hljs-attr">props</span>: &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;list&#x27;</span> &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">tagName</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;douyin&#x27;</span>] &#125;,<br>    &#123; <span class="hljs-attr">tagName</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: [<span class="hljs-string">&#x27;toutiao&#x27;</span>] &#125;,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Element</span>(<span class="hljs-params">&#123; tagName, props, children &#125;</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Element</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Element</span>(&#123; tagName, props, children &#125;)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagName</span> = tagName<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span> = props || &#123;&#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = children || []<br>&#125;<br><span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">tagName</span>),<br>    props = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>,<br>    propName,<br>    propValue<br>  <span class="hljs-keyword">for</span> (propName <span class="hljs-keyword">in</span> props) &#123;<br>    propValue = props[propName]<br>    el.<span class="hljs-title function_">setAttribute</span>(propName, propValue)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) &#123;<br>    <span class="hljs-keyword">var</span> childEl = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (child <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Element</span>) &#123;<br>      childEl = child.<span class="hljs-title function_">render</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      childEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(child)<br>    &#125;<br>    el.<span class="hljs-title function_">appendChild</span>(childEl)<br>  &#125;)<br>  <span class="hljs-keyword">return</span> el<br>&#125;<br><br><span class="hljs-keyword">var</span> ul = <span class="hljs-title class_">Element</span>(demoNode)<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(ul.<span class="hljs-title function_">render</span>())<br></code></pre></td></tr></table></figure><h2 id="3-图片懒加载"><a href="#3-图片懒加载" class="headerlink" title="3. 图片懒加载"></a>3. 图片懒加载</h2><ol><li><p>lazy 告诉用户代理推迟图片加载直到浏览器认为其需要立即加载时才去加载<br><code>&lt;img src=&quot;deathghost.jpg&quot; loading=&quot;lazy&quot; alt=&quot;新码笔记&quot; /&gt;</code><br>loading 的属性值<br>|值 |描述||<br>|—|—||<br>|eager |默认，图像立即加载。||<br>|lazy |图像延迟加载，只有鼠标滚动到该图片所在位置才会显示。||</p></li><li><p>方式二 offsetTop - scrollTop &lt; &#x3D; innerHeight<br>计算图片是否在可视区域内，如果在则加载图片</p><blockquote><p>offsetTop：元素顶部到包含元素顶部的距离(图片顶部到文档顶部的距离)<br>scrollTop：元素顶部到窗口顶部的距离(滚动条滚动的距离)<br>clientHeight：窗口的高度(可视区域的高度)</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default1.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default2.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default3.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target3.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>); <span class="hljs-comment">// 获取所有图片imgs=[img,img,img]</span><br><span class="hljs-keyword">var</span> num = imgs.<span class="hljs-property">length</span>; <span class="hljs-comment">// 图片的数量</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器</span><br><span class="hljs-title function_">lazyload</span>(); <span class="hljs-comment">// 首次加载别忘了显示图片</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload); <span class="hljs-comment">// 监听滚动事件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">// 可视区域的高度</span><br>    <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>; <span class="hljs-comment">// 滚动条距离顶部的高度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = count; i &lt; num; i++) &#123; <span class="hljs-comment">// 从计数器的值开始，遍历每个图片</span><br>        <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-property">offsetTop</span> &lt; viewHeight + scrollTop) &#123; <span class="hljs-comment">// 图片进入可视区域</span><br>            <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>) !== <span class="hljs-string">&#x27;default.jpg&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果图片已经加载过，则跳过</span><br>            imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>); <span class="hljs-comment">// 设置图片src为data-src(加载图片)</span><br>            count++; <span class="hljs-comment">// 计数器累加</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>方式五 vue-lazyload</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.  安装</span><br><span class="hljs-comment">//npm install vue-lazyload --save</span><br><br><span class="hljs-comment">//2. 引入</span><br><span class="hljs-comment">// main.js 文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">VueLazyload</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br><span class="hljs-comment">// Vue.use(VueLazyload) //无配置项</span><br><span class="hljs-comment">// 配置项</span><br><span class="hljs-keyword">const</span> loadimage = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;assets/img/common/loading.gif&#x27;</span>)<br><span class="hljs-comment">// const errorimage = require(&#x27;assets/img/common/error.gif&#x27;)</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueLazyload</span>, &#123;<br> <span class="hljs-attr">preLoad</span>: <span class="hljs-number">1.3</span>, <span class="hljs-comment">//预加载的宽高比</span><br> <span class="hljs-attr">loading</span>: loadimage, <span class="hljs-comment">//图片加载状态下显示的图片</span><br> <span class="hljs-comment">// error: errorimage, //图片加载失败时显示的图片</span><br> <span class="hljs-attr">attempt</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 加载错误后最大尝试次数</span><br>&#125;)<br><span class="hljs-comment">//3. 使用</span><br><span class="hljs-comment">// img元素上使用v-lazy=&quot;src&quot;;&lt;img v-lazy=&quot;showImage&quot;/&gt;</span><br>&lt;img v-lazy=<span class="hljs-string">&quot;img.thumbnail_pic_s&quot;</span>&gt;<br></code></pre></td></tr></table></figure></li><li><p>getBoundingClientRect</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// DOMRect:&#123;</span><br><span class="hljs-comment">// x: 18, y: 10, width: 240, height: 240, top: 10</span><br><span class="hljs-comment">// right: 258, bottom: 250, left: 18&#125;</span><br><br> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isInViewPort</span>(<span class="hljs-params">element</span>) &#123;<br>    <span class="hljs-keyword">const</span> viewWidth = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>;<br>    <span class="hljs-keyword">const</span> viewHeight = <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>;<br>    <span class="hljs-keyword">const</span> &#123;<br>      top,<br>      right,<br>      bottom,<br>      left,<br>   &#125; = element.<span class="hljs-title function_">getBoundingClientRect</span>();<br>   ​<br>    <span class="hljs-keyword">return</span> (<br>      top &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>      left &gt;= <span class="hljs-number">0</span> &amp;&amp;<br>      right &lt;= viewWidth &amp;&amp;<br>      bottom &lt;= viewHeight<br>   );<br>   &#125;<br><br></code></pre></td></tr></table></figure></li></ol><h2 id="4-倒计时处理-x2F-时间处理"><a href="#4-倒计时处理-x2F-时间处理" class="headerlink" title="4. 倒计时处理&#x2F;时间处理"></a>4. 倒计时处理&#x2F;时间处理</h2><blockquote><p>setTimeOut 和 setInterval 的区别<br>setTimeOut 是在指定的时间后执行一次(<code>js是单线程的</code>。规定的 1000ms 的延迟，其实并不是精准的 1000ms，而是在<code>当前任务结束</code>轮到 setTimeout 执行的时候才进行 1000ms 的事件插入，而<code>等待之前任务运行的那段时间</code>，便是我们主要的误差值。)<br>setInterval 是每隔指定的时间执行一次(当打点的时间段有其他事务正在运行的话，那将占据打点执行的时间，从而导致本次打点事件被略过)</p></blockquote><pre><code class="hljs"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br><span class="hljs-keyword">let</span> [year, month, day, hour, minute, second] = [<br>  date.<span class="hljs-title function_">getFullYear</span>(),<br>  date.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>,<br>  date.<span class="hljs-title function_">getDate</span>(),<br>  date.<span class="hljs-title function_">getHours</span>(),<br>  date.<span class="hljs-title function_">getMinutes</span>(),<br>  date.<span class="hljs-title function_">getSeconds</span>(),<br>]<br></code></pre></td></tr></table></figure></code></pre><ol><li><p>setTimeout 倒计时(不断修改误差)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> t1 = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br><span class="hljs-keyword">let</span> c1 = <span class="hljs-number">0</span> <span class="hljs-comment">// 递归次数</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">timer</span>: any = <span class="hljs-literal">null</span> <span class="hljs-comment">// 计时器</span><br><span class="hljs-keyword">let</span> t = <span class="hljs-number">5</span> <span class="hljs-comment">// 倒计时秒数</span><br><span class="hljs-keyword">let</span> interval = <span class="hljs-number">1000</span> <span class="hljs-comment">// 间隔</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">countDown</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (--t &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 计算误差</span><br>  <span class="hljs-keyword">const</span> offset = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - (t1 + c1 * interval)<br>  <span class="hljs-keyword">const</span> nextTime = interval - offset<br>  c1++<br>  timer = <span class="hljs-built_in">setTimeout</span>(countDown, nextTime)<br>&#125;<br><span class="hljs-title function_">countDown</span>()<br></code></pre></td></tr></table></figure></li><li><p>setInterval 倒计时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> t = <span class="hljs-number">5</span><br><span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (--t &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">clearInterval</span>(timer)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure></li><li><p>requestAnimationFrame 倒计时<br>&#x2F;&#x2F; 1.开始时间，2.结束时间，3.当前时间<br>&#x2F;&#x2F; 4. 剩余时间&#x3D;总时长-已过去时间+误差时间<br>&#x2F;&#x2F; 5. 实际结束时间&#x3D;当前时间+剩余时间<br>&#x2F;&#x2F; 6. 误差时间&#x3D;实际结束时间-预期结束时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countdown</span>(<span class="hljs-params">seconds</span>) &#123;<br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() <span class="hljs-comment">// 记录开始时间</span><br>  <span class="hljs-keyword">let</span> expectedEndTime = startTime + seconds * <span class="hljs-number">1000</span> <span class="hljs-comment">// 预期结束时间</span><br>  <span class="hljs-keyword">let</span> deviation = <span class="hljs-number">0</span> <span class="hljs-comment">// 时间误差</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTimer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> currentTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() <span class="hljs-comment">// 记录当前时间</span><br>    <span class="hljs-keyword">let</span> elapsedTime = (currentTime - startTime) / <span class="hljs-number">1000</span> <span class="hljs-comment">// 计算已经过去的秒数</span><br>    <span class="hljs-keyword">let</span> remainingTime = seconds - elapsedTime + deviation / <span class="hljs-number">1000</span> <span class="hljs-comment">// 计算剩余时间，考虑时间误差</span><br>    <span class="hljs-keyword">if</span> (remainingTime &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(remainingTime)<br>      <span class="hljs-title function_">requestAnimationFrame</span>(updateTimer) <span class="hljs-comment">// 更新计时器</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;倒计时结束&#x27;</span>)<br>      <span class="hljs-title function_">cancelAnimationFrame</span>(requestRef) <span class="hljs-comment">// 清除计时器</span><br>    &#125;<br>    <span class="hljs-comment">// 检查时间误差是否过大，超过1秒则进行修正</span><br>    <span class="hljs-keyword">let</span> actualEndTime = currentTime + remainingTime * <span class="hljs-number">1000</span><br>    deviation = actualEndTime - expectedEndTime<br>  &#125;<br>  <span class="hljs-keyword">let</span> requestRef = <span class="hljs-title function_">requestAnimationFrame</span>(updateTimer) <span class="hljs-comment">// 启动计时器</span><br>&#125;<br><span class="hljs-comment">// 使用示例：倒计时10秒</span><br><span class="hljs-title function_">countdown</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 进行毫秒时间级修正，通过毫秒进行计算</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="5-实现一个简单的发布订阅模式"><a href="#5-实现一个简单的发布订阅模式" class="headerlink" title="5. 实现一个简单的发布订阅模式"></a>5. 实现一个简单的发布订阅模式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 公众号调度中心</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventHub</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 缓存列表，存放 event 及 fn</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = &#123;&#125;<br>  &#125;<br>  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, fn</span>) &#123;<br>    <span class="hljs-comment">// 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[event] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[event] || []<br>    <span class="hljs-comment">// 把 fn 添加到对应 event 的缓存列表里</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[event].<span class="hljs-title function_">push</span>(fn)<br>  &#125;<br>  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) &#123;<br>    <span class="hljs-keyword">const</span> fnList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[event] || []<br>    <span class="hljs-comment">// 如果缓存列表里没有 fn 就return</span><br>    <span class="hljs-keyword">if</span> (!fnList || fnList.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 遍历 event 值对应的缓存列表，依次执行 fn</span><br>    fnList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>, data))<br>  &#125;<br>  <span class="hljs-title function_">off</span>(<span class="hljs-params">event, fn</span>) &#123;<br>    <span class="hljs-keyword">const</span> fnList = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>[event] || []<br>    <span class="hljs-keyword">const</span> index = fnList.<span class="hljs-title function_">indexOf</span>(fn)<br>    <span class="hljs-comment">// 如果缓存列表里没有要找的fn 就return</span><br>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span><br>    fnList.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>  &#125;<br>  <span class="hljs-comment">//执行一次</span><br>  <span class="hljs-title function_">once</span>(<span class="hljs-params">event, callback</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">data</span>) =&gt; &#123;<br>      <span class="hljs-title function_">callback</span>(data)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">off</span>(event, f)<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">on</span>(event, f)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">user1</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户1订阅了:&#x27;</span>, content)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">user2</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户2订阅了:&#x27;</span>, content)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">user3</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户3订阅了:&#x27;</span>, content)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">user4</span>(<span class="hljs-params">content</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;用户4订阅了:&#x27;</span>, content)<br>&#125;<br><span class="hljs-keyword">const</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHub</span>()<br><span class="hljs-comment">// 订阅</span><br>e.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, user1)<br>e.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, user2)<br>e.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, user3)<br><br><span class="hljs-comment">// 取消user2方法的订阅</span><br>e.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, user2)<br><br>e.<span class="hljs-title function_">once</span>(<span class="hljs-string">&#x27;article2&#x27;</span>, user4)<br><br><span class="hljs-comment">// 发布</span><br>e.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, <span class="hljs-string">&#x27;Javascript 发布-订阅模式&#x27;</span>)<br>e.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;article1&#x27;</span>, <span class="hljs-string">&#x27;Javascript 发布-订阅模式&#x27;</span>)<br><br>e.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;article2&#x27;</span>, <span class="hljs-string">&#x27;Javascript 观察者模式&#x27;</span>)<br>e.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;article2&#x27;</span>, <span class="hljs-string">&#x27;Javascript 观察者模式&#x27;</span>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    用户1订阅了: Javascript 发布-订阅模式</span><br><span class="hljs-comment">    用户3订阅了: Javascript 发布-订阅模式</span><br><span class="hljs-comment">    用户1订阅了: Javascript 发布-订阅模式</span><br><span class="hljs-comment">    用户3订阅了: Javascript 发布-订阅模式</span><br><span class="hljs-comment">    用户4订阅了: Javascript 观察者模式</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="6-有并行限制的-Promise-调度器"><a href="#6-有并行限制的-Promise-调度器" class="headerlink" title="6.有并行限制的 Promise 调度器"></a>6.有并行限制的 Promise 调度器</h2><pre><code class="hljs"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scheduler</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span> = <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">runCounts</span> = <span class="hljs-number">0</span><br>  &#125;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">promiseCreator</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>(promiseCreator)<br>  &#125;<br>  <span class="hljs-title function_">taskStart</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>; i++) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>()<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">request</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">runCounts</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxCount</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">runCounts</span>++<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span><br>      .<span class="hljs-title function_">shift</span>()()<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">runCounts</span>--<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>()<br>      &#125;)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">timeout</span> = (<span class="hljs-params">time</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, time)<br>  &#125;)<br><span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scheduler</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">addTask</span> = (<span class="hljs-params">time, order</span>) =&gt; &#123;<br>  scheduler.<span class="hljs-title function_">add</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">timeout</span>(time).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(order)))<br>&#125;<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">300</span>, <span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-title function_">addTask</span>(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;4&#x27;</span>)<br>scheduler.<span class="hljs-title function_">taskStart</span>()<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>面试常问题目汇总</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP系列</title>
    <link href="/2024/02/27/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/HTTP%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/27/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/HTTP%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-HTTP系列"><a href="#🍭-HTTP系列" class="headerlink" title="🍭 HTTP系列"></a>🍭 HTTP系列</h1><h2 id="1-什么是-HTTP-HTTP-和-HTTPS-的区别"><a href="#1-什么是-HTTP-HTTP-和-HTTPS-的区别" class="headerlink" title="1. 什么是 HTTP? HTTP 和 HTTPS 的区别?"></a>1. 什么是 HTTP? HTTP 和 HTTPS 的区别?</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><pre><code class="hljs">&gt; HTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范&gt; 在实际应用中，HTTP 常被用于在 Web 浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密</code></pre><p><strong>特点如下：</strong></p><ol><li>支持客户&#x2F;服务器模式</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快</li><li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li>无状态：HTTP 协议无法根据之前的状态进行本次的请求处理</li></ol><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><blockquote><p>HTTPS 出现正是为了解决 HTTP 不安全的特性<br>为了保证这些隐私数据能加密传输，让 HTTP 运行安全的 SSL&#x2F;TLS 协议上，即 HTTPS &#x3D; HTTP + SSL&#x2F;TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密<br>SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，浏览器和服务器在使用 SSL 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p></blockquote><p><strong>加密过程:</strong></p><ol><li>首先客户端通过 URL 访问服务器建立 SSL 连接</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>服务器利用自己的私钥解密出会话密钥</li><li>服务器利用会话密钥加密与客户端之间的通信</li></ol><h3 id="区别如下："><a href="#区别如下：" class="headerlink" title="区别如下："></a>区别如下：</h3><ol><li>HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL&#x2F;TLS 协议进行了加密处理，相对更安全</li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443</li><li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li><li>HTTPS 需要 SSL，SSL 证书需要钱，功能越强大的证书费用越高</li></ol><h2 id="2-为什么说-HTTPS-比-HTTP-安全-HTTPS-是如何保证安全的？"><a href="#2-为什么说-HTTPS-比-HTTP-安全-HTTPS-是如何保证安全的？" class="headerlink" title="2. 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？"></a>2. 为什么说 HTTPS 比 HTTP 安全? HTTPS 是如何保证安全的？</h2><blockquote><p>而 HTTPS 的出现正是解决这些问题，HTTPS 是建立在 SSL 之上，其安全性由 SSL 来保证<br>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能</p></blockquote><h3 id="如何保证安全的？"><a href="#如何保证安全的？" class="headerlink" title="如何保证安全的？"></a>如何保证安全的？</h3><ol><li><p>混合加密</p><blockquote><p>在 HTTPS 通信过程中，采用的是对称加密+非对称加密，也就是混合加密</p></blockquote><ul><li>对称加密:对称加密指的是加密和解密使用的秘钥都是同一个，是对称的。</li><li>非对称加密:非对称加密，存在两个秘钥，一个叫公钥，一个叫私钥。两个秘钥是不同的，公钥可以公开给任何人使用，私钥则需要保密</li></ul></li><li><p>摘要算法<br><strong><code>实现完整性</code>的手段主要是<code>摘要算法</code>，也就是常说的<code>散列函数</code>、<code>哈希函数</code></strong></p><blockquote><p>可以理解成一种特殊的<code>压缩算法</code>，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”</p></blockquote></li><li><p>数字签名</p><blockquote><p><code>数字签名</code>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名</p></blockquote></li></ol><p><strong>原理其实很简单，就是用<code>私钥加密，公钥解密</code></strong><br>签名和公钥一样完全公开，任何人都可以获取。但这个签名只有用私钥对应的公钥才能解开，拿到摘要后，再比对原文验证完整性，就可以像签署文件一样证明消息确实是你发的</p><h3 id="可以看到，HTTPS-与-HTTP-虽然只差一个-SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下："><a href="#可以看到，HTTPS-与-HTTP-虽然只差一个-SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：" class="headerlink" title="可以看到，HTTPS 与 HTTP 虽然只差一个 SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下："></a>可以看到，HTTPS 与 HTTP 虽然只差一个 SSL，但是通信安全得到了大大的保障，通信的四大特性都以解决，解决方式如下：</h3><ol><li>机密性：混合算法</li><li>完整性：摘要算法</li><li>身份认证：数字签名</li><li>不可否定：数字签名</li><li>同时引入第三方证书机构，确保公开秘钥的安全性</li></ol><h2 id="3-UDP"><a href="#3-UDP" class="headerlink" title="3. UDP"></a>3. UDP</h2><h2 id="4-OSI"><a href="#4-OSI" class="headerlink" title="4. OSI"></a>4. OSI</h2><h2 id="5-TCP-x2F-IP"><a href="#5-TCP-x2F-IP" class="headerlink" title="5. TCP&#x2F;IP"></a>5. TCP&#x2F;IP</h2><h2 id="6-DNS"><a href="#6-DNS" class="headerlink" title="6. DNS"></a>6. DNS</h2><blockquote><p>DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器<br>DNS 相当于一个翻译官，负责将域名翻译成 ip 地址</p></blockquote><ul><li>IP 地址：一长串能够唯一地标记网络上的计算机的数字</li><li>域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识</li></ul><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><blockquote><p>域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…</p></blockquote><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><ol><li>递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案</li><li>迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求</li></ol><h3 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h3><blockquote><p>在域名服务器解析的时候，使用缓存保存域名和 IP 地址的映射</p></blockquote><ol><li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗</li><li>操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件</li></ol><h3 id="域名查询过程"><a href="#域名查询过程" class="headerlink" title="域名查询过程"></a>域名查询过程</h3><p>解析域名的过程如下：</p><ol><li>首先<code>搜索浏览器的 DNS 缓存</code>，缓存中维护一张域名与 IP 地址的对应表</li><li>若没有命中，则继续搜索<code>操作系统的 DNS 缓存</code></li><li>若仍然没有命中，则操作系统将域名发送至<code>本地域名服务器</code>，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li><li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向<code>上级域名服务</code>器进行迭代查询</li></ol><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><ol start="5"><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</li></ol><h2 id="7-如何理解-CDN？说说实现原理？"><a href="#7-如何理解-CDN？说说实现原理？" class="headerlink" title="7. 如何理解 CDN？说说实现原理？"></a>7. 如何理解 CDN？说说实现原理？</h2><p>CDN (全称 Content Delivery Network)，即<code>内容分发网络</code></p><blockquote><p>依靠部署在各地的<code>边缘服务器</code>，通过中心平台的<code>负载均衡</code>、<code>内容分发</code>、<code>调度等功能模块</code>，使用户<code>就近获取</code>所需内容，降低<code>网络拥塞</code>，提高用户<code>访问响应速度</code>和<code>命中率</code>。CDN 的关键技术主要有内容存储和分发技术<br>CDN 就是根据用户位置分配最近的资源</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li><p>负载均衡系统</p><ol><li>由于没有返回 IP 地址，于是本地 DNS 会向负载均衡系统再发送请求 ，则进入到 CDN 的全局负载均衡系统进行智能调度：</li><li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点</li><li>看用户所在的运营商网络，找相同网络的边缘节点</li><li>检查边缘节点的负载情况，找负载较轻的节点</li><li>然后把这个节点返回给用户，用户就能够就近访问 CDN 的缓存代理</li></ol></li><li><p>缓存代理</p><blockquote><p>缓存系统会有选择地缓存那些最常用的那些资源</p></blockquote></li></ol><p><strong>其中有两个衡量 CDN 服务质量的指标：</strong></p><ol><li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li><li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li></ol><h2 id="8-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别"><a href="#8-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别" class="headerlink" title="8. 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?"></a>8. 说说 HTTP1.0&#x2F;1.1&#x2F;2.0 的区别?</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><blockquote><p>HTTP 1.0 浏览器与服务器只<code>保持短暂的连接</code>，每次请求都需要与服务器建立一个 TCP 连接<br>服务器完成请求处理后<code>立即断开TCP连接</code>，服务器不跟踪每个客户也不记录过去的请求</p></blockquote><p><strong>简单来讲，每次与服务器交互，都需要新开一个连接</strong></p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><blockquote><p>在 HTTP1.1 中，<code>默认支持长连接</code>（Connection: keep-alive），即在一个 TCP 连接上可以<code>传送多个HTTP请求和响应</code>，减少了建立和关闭连接的消耗和延迟<br>HTTP 1.1 还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求<br>新增了一些<code>请求方法</code><br>新增了一些<code>请求头和响应头</code></p></blockquote><p><strong>建立一次连接，多次请求均由这个连接完成</strong></p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><blockquote><p>而 HTTP2.0 在相比之前版本，性能上有很大的提升，如添加了一个特性：</p></blockquote><ol><li>多路复用<blockquote><p>HTTP&#x2F;2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”</p></blockquote></li><li>二进制分帧<blockquote><p>HTTP&#x2F;2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，解析起来更高效</p></blockquote></li><li>首部压缩<blockquote><p>HTTP&#x2F;2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</p></blockquote></li><li>服务器推送<blockquote><p>HTTP2 引入服务器推送，允许服务端推送资源给客户端</p></blockquote></li></ol><h2 id="9-说说-HTTP-常见的状态码有哪些，适用场景？"><a href="#9-说说-HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="9. 说说 HTTP 常见的状态码有哪些，适用场景？"></a>9. 说说 HTTP 常见的状态码有哪些，适用场景？</h2><blockquote><p>HTTP 状态码（英语：HTTP Status Code），用以表示网页服务器超文本传输协议响应状态的 3 位数字代码</p></blockquote><p><strong>状态码第一位数字决定了不同的响应状态，有如下：</strong></p><ul><li>1 表示消息</li><li>2 表示成功</li><li>3 表示重定向</li><li>4 表示请求错误</li><li>5 表示服务器错误</li></ul><h3 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h3><blockquote><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束</p></blockquote><ul><li>100（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应</li><li>101：服务器根据客户端的请求切换协议，主要用于 websocket 或 http2 升级</li></ul><h3 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h3><blockquote><p>代表请求已成功被服务器接收、理解、并接受</p></blockquote><ul><li>200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回</li><li>201（已创建）：请求成功并且服务器创建了新的资源</li><li>202（已创建）：服务器已经接收请求，但尚未处理</li><li>203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源</li><li>204（无内容）：服务器成功处理请求，但没有返回任何内容</li><li>205（重置内容）：服务器成功处理请求，但没有返回任何内容</li><li>206（部分内容）：服务器成功处理了部分请求</li></ul><h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><blockquote><p>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向</p></blockquote><ul><li>300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择</li><li>301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置</li><li>302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li><li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理</li><li>307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li></ul><h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理</p><ul><li>400（错误请求）： 服务器不理解请求的语法</li><li>401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403（禁止）： 服务器拒绝请求</li><li>404（未找到）： 服务器找不到请求的网页</li><li>405（方法禁用）： 禁用请求中指定的方法</li><li>406（不接受）： 无法使用请求的内容特性响应请求的网页</li><li>407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理</li><li>408（请求超时）： 服务器等候请求时发生超时</li></ul><h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><blockquote><p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生</p></blockquote><ul><li>500（服务器内部错误）：服务器遇到错误，无法完成请求</li><li>501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码</li><li>502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应</li><li>503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）</li><li>504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求</li><li>505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本</li></ul><h3 id="三、适用场景"><a href="#三、适用场景" class="headerlink" title="三、适用场景"></a>三、适用场景</h3><ul><li>100：客户端在发送 POST 数据给服务器前，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输</li><li>206：一般用来做断点续传，或者是视频文件等大文件的加载</li><li>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用 301 就重定向到新的域名</li><li>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li><li>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li>400：参数有误，请求无法被服务器识别</li><li>403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网 IP 才能访问的时候则返回</li><li>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li><li>503：服务器停机维护时，主动用 503 响应请求或 nginx 设置限速，超过限速，会返回 503</li><li>504：网关超时</li></ul><h2 id="10-说一下-GET-和-POST-的区别？"><a href="#10-说一下-GET-和-POST-的区别？" class="headerlink" title="10. 说一下 GET 和 POST 的区别？"></a>10. 说一下 GET 和 POST 的区别？</h2><blockquote><p>GET 用于从服务器获取数据<br>POST 用于向服务器提交数据</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>数据方面</li></ol><ul><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。<br>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li></ul><ol start="2"><li>安全方面<br>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。<br>POST 参数不会被保存在浏览器历史或 web 服务器日志中。</li><li>缓存方面<br>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。<br>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。<br>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。<br>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li><li>数据包</li></ol><ul><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）</li><li>对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok<blockquote><p>并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次</p></blockquote></li></ul><h2 id="11-说说-HTTP-常见的请求头有哪些-作用？"><a href="#11-说说-HTTP-常见的请求头有哪些-作用？" class="headerlink" title="11. 说说 HTTP 常见的请求头有哪些? 作用？"></a>11. 说说 HTTP 常见的请求头有哪些? 作用？</h2><h2 id="12-说说地址栏输入-URL-敲下回车后发生了什么"><a href="#12-说说地址栏输入-URL-敲下回车后发生了什么" class="headerlink" title="12. 说说地址栏输入 URL 敲下回车后发生了什么?"></a>12. 说说地址栏输入 URL 敲下回车后发生了什么?</h2><p>简单的分析，从输入 URL 到回车后发生的行为如下：</p><ol><li><p>URL 解析</p><blockquote><p>首先浏览器会对输入的 URL 进行解析，解析出协议、主机、端口、路径等信息</p></blockquote></li><li><p>DNS 查询</p><ol><li>首先<code>搜索浏览器的 DNS 缓存</code>，缓存中维护一张域名与 IP 地址的对应表</li><li>若没有命中，则继续搜索<code>操作系统的 DNS 缓存</code></li><li>若仍然没有命中，则操作系统将域名发送至<code>本地域名服务器</code>，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</li><li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向<code>上级域名服务</code>器进行迭代查询</li></ol><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul><ol start="5"><li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</li></ol></li><li><p>TCP 连接</p><blockquote><p>在之前文章中，了解到 tcp 是一种面向有连接的传输层协议<br>在确定目标服务器服务器的 IP 地址后，则经历三次握手建立 TCP 连接.</p></blockquote></li><li><p>HTTP 请求</p><blockquote><p>当建立 tcp 连接之后，就可以在这基础上进行通信，浏览器发送 http 请求到目标服务器<br>请求的内容包括：请求行\请求头\请求主体</p></blockquote></li><li><p>响应请求<br>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个 HTTP 响应消息，包括：状态行&#x2F;响应头&#x2F;响应正文</p></li><li><p>页面渲染</p></li></ol><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储 cookie，解压 gzip，缓存资源等等</li><li>查看响应头的 Content-Type 的值，根据不同的资源类型采用不同的解析方式</li></ul><ol><li>解析 HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout &#x2F; reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ol><h2 id="13-说说-TCP-为什么需要三次握手和四次挥手？"><a href="#13-说说-TCP-为什么需要三次握手和四次挥手？" class="headerlink" title="13. 说说 TCP 为什么需要三次握手和四次挥手？"></a>13. 说说 TCP 为什么需要三次握手和四次挥手？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><blockquote><p>三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包<br>主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p></blockquote><p><strong>过程如下：</strong></p><ol><li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li><li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为 ACK 的值，此时服务器处于 SYN_RCVD 的状态</li><li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的 ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li></ol><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><blockquote><p>tcp 终止一个连接，需要经过四次挥手</p></blockquote><p>过程如下：</p><ol><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ol><h2 id="14-说说对-WebSocket-的理解？应用场景？"><a href="#14-说说对-WebSocket-的理解？应用场景？" class="headerlink" title="14. 说说对 WebSocket 的理解？应用场景？"></a>14. 说说对 WebSocket 的理解？应用场景？</h2><blockquote><p>WebSocket，是一种网络传输协议，位于 OSI 模型的应用层。可在单个 TCP 连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅<br>客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>全双工</p><blockquote><p>通信允许数据在<code>两个方向上同时传输</code>，它在能力上相当于两个单工通信方式的结合<br>例如指 A→B 的同时 B→A ，是<code>瞬时同步</code>的</p></blockquote></li><li><p>二进制帧</p><blockquote><p>WebSocket 更侧重于“实时通信”，而 HTTP&#x2F;2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别</p></blockquote></li><li><p>协议名</p><blockquote><p>引入 ws 和 wss 分别代表明文和密文的 websocket 协议，且默认端口使用 80 或 443，几乎与 http 一致</p></blockquote></li><li><p>握手</p><blockquote><p>WebSocket 也要有一个握手过程，然后才能正式收发数据</p></blockquote></li><li><p>客户端发送数据格式如下：</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>server.example.com<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Key</span><span class="hljs-punctuation">: </span>dGhlIHNhbXBsZSBub25jZQ==<br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://example.com<br><span class="hljs-attribute">Sec-WebSocket-Protocol</span><span class="hljs-punctuation">: </span>chat, superchat<br><span class="hljs-attribute">Sec-WebSocket-Version</span><span class="hljs-punctuation">: </span>13<br>Connection：必须设置Upgrade，表示客户端希望连接升级<br>Upgrade：必须设置Websocket，表示希望升级到Websocket协议<br>Sec-WebSocket-Key：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的“Sec-WebSocket-Accept应答，否则客户端会抛出错误，并关闭连接<br>Sec-WebSocket-Version ：表示支持的Websocket版本<br></code></pre></td></tr></table></figure></li><li><p>服务端返回的数据格式：</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">101</span> Switching Protocols<br><span class="hljs-attribute">Upgrade</span><span class="hljs-punctuation">: </span>websocket<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Upgrade<br><span class="hljs-attribute">Sec-WebSocket-Accept</span><span class="hljs-punctuation">: </span>s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat<br>HTTP/1.1 101 Switching Protocols：表示服务端接受 WebSocket 协议的客户端连接<br>Sec-WebSocket-Accep：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里“Sec-WebSocket-Key”的值，加上一个专用的 UUID，再计算摘要<br></code></pre></td></tr></table></figure></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li><li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li><li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li><li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ol><h3 id="基于websocket的事实通信的特点，其存在的应用场景大概有："><a href="#基于websocket的事实通信的特点，其存在的应用场景大概有：" class="headerlink" title="基于websocket的事实通信的特点，其存在的应用场景大概有："></a>基于websocket的事实通信的特点，其存在的应用场景大概有：</h3><p>弹幕<br>媒体聊天<br>协同编辑<br>基于位置的应用<br>体育实况更新<br>股票基金报价实时更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack系列</title>
    <link href="/2024/02/26/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Webpack%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/26/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Webpack%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-Webpack-系列"><a href="#🍭-Webpack-系列" class="headerlink" title="🍭 Webpack 系列"></a>🍭 Webpack 系列</h1><h2 id="1-说说你对-webpack-的理解？解决了什么问题？"><a href="#1-说说你对-webpack-的理解？解决了什么问题？" class="headerlink" title="1. 说说你对 webpack 的理解？解决了什么问题？"></a>1. 说说你对 webpack 的理解？解决了什么问题？</h2><blockquote><p>webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具;Webpack 最初的目标是实现前端项目的模块化，旨在更高效地管理和维护项目中的每一个资源</p></blockquote><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ol><li><p>最早的时候，我们会通过文件划分的形式实现模块化，也就是将每个功能及其相关状态数据各自单独放到不同的 JS 文件中<br>约定每个文件是一个独立的模块，然后再将这些 js 文件引入到页面，一个 script 标签对应一个模块，然后调用模块化的成员<br><strong>缺点</strong>：全局变量污染、命名冲突、依赖关系不清晰、无法管理模块之间的依赖关系</p></li><li><p>规定每个模块只暴露一个全局对象，然后模块的内容都挂载到这个对象中</p></li><li><p>我们使用立即执行函数为模块提供私有空间，通过参数的形式作为依赖声明，</p></li></ol><h3 id="静态模块"><a href="#静态模块" class="headerlink" title="静态模块"></a>静态模块</h3><p>这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源（可以直接被获取打包进 bundle.js 的资源）</p><p>当 webpack 处理应用程序时，它会在内部构建一个依赖图，此依赖图对应映射到项目所需的每个模块（不再局限 js 文件），并生成一个或多个 bundle</p><h3 id="webpack-的能力："><a href="#webpack-的能力：" class="headerlink" title="webpack 的能力："></a>webpack 的能力：</h3><ol><li>编译代码能力，提高效率，解决浏览器兼容问题</li><li>模块整合能力，提高性能，可维护性，解决浏览器频繁请求文件的问题</li><li>万物皆可模块能力，项目维护性增强，支持不同种类的前端模块类型，统一的模块化方案，所有资源文件的加载都可以通过代码控制</li></ol><h2 id="2-说说-webpack-的构建流程"><a href="#2-说说-webpack-的构建流程" class="headerlink" title="2. 说说 webpack 的构建流程?"></a>2. 说说 webpack 的构建流程?</h2><blockquote><p>webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来<br>从启动到结束会依次执行以下三大步骤：</p></blockquote><h3 id="初始化流程："><a href="#初始化流程：" class="headerlink" title="初始化流程："></a>初始化流程：</h3><blockquote><p>从配置文件<code>webpack.config.js</code>和 Shell 语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// 1. 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./path/to/my/entry/file.js&#x27;</span>，<br>  <span class="hljs-comment">// 2. 文件路径指向(可加快打包过程)。</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;react&#x27;</span>: pathToReact<br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 3. 生成文件，是模块构建的终点，包括输出文件与输出路径。</span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 4. 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">loaders</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel&#x27;</span>,<br>        <span class="hljs-attr">query</span>: &#123;<br>          <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;es2015&#x27;</span>, <span class="hljs-string">&#x27;react&#x27;</span>]<br>        &#125;<br>      &#125;<br>    ],<br>    <span class="hljs-attr">noParse</span>: [pathToReact]<br>  &#125;,<br>  <span class="hljs-comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>()<br>  ]<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置的 plugins</p></blockquote><p>完成上述步骤之后，则开始初始化 Compiler 编译对象，</p><h3 id="编译构建流程"><a href="#编译构建流程" class="headerlink" title="编译构建流程:"></a>编译构建流程:</h3><blockquote><p>从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理</p></blockquote><ol><li>根据配置中的 entry 找出所有的入口文件</li></ol><ul><li>执行了 run 方法后，首先会触发 compile</li></ul><ol start="2"><li>compile 编译</li></ol><ul><li>主要是构建一个 Compilation 对象</li></ul><ol start="3"><li>make 编译模块</li><li>build module 完成模块编译</li></ol><ul><li>这里主要调用配置的 loaders，将我们的模块转成标准的 JS 模块</li></ul><ol start="5"><li>随后执行 buildModule 进入真正的构建模块 module 内容的过程</li></ol><h3 id="输出流程"><a href="#输出流程" class="headerlink" title="输出流程"></a>输出流程</h3><blockquote><p>对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统</p></blockquote><ol><li><p>seal 输出资源<br>seal 方法主要是要生成 chunks，对 chunks 进行一系列的优化操作，并生成要输出的代码</p></li><li><p>emit 输出完成</p><blockquote><p>在确定好输出内容后，根据配置确定输出的路径和文件名</p></blockquote></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">output: &#123;<br>    path: path.<span class="hljs-built_in">resolve</span>(__dirname, <span class="hljs-string">&#x27;build&#x27;</span>),<br>        filename: <span class="hljs-string">&#x27;[name].js&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2024/02/26/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Webpack%E7%B3%BB%E5%88%97/webpack.png" class><h2 id="3-说说-webpack-中常见的-Loader？解决了什么问题？"><a href="#3-说说-webpack-中常见的-Loader？解决了什么问题？" class="headerlink" title="3. 说说 webpack 中常见的 Loader？解决了什么问题？"></a>3. 说说 webpack 中常见的 Loader？解决了什么问题？</h2><blockquote><p>loader 用于对模块的<code>源代码</code>进行转换，在 import 或”加载”模块时<code>预处理文件</code><br>webpack 做的事情，仅仅是分析出各种模块的<code>依赖关系</code>，然后形成<code>资源列表</code>，最终<code>打包生成</code>到指定的文件中。<br>默认情况下，在遇到 import 或者 require 加载模块的时候，webpack 只支持对 js 和 json 文件打包<br>像 css、sass、png 等这些类型的文件的时候，webpack 则无能为力，这时候就需要配置对应的 loader 进行文件内容的解析</p></blockquote><h3 id="关于配置-loader-的方式有三种："><a href="#关于配置-loader-的方式有三种：" class="headerlink" title="关于配置 loader 的方式有三种："></a>关于配置 loader 的方式有三种：</h3><ol><li>配置方式（推荐）：在 webpack.config.js 文件中指定 loader</li><li>内联方式：在每个 import 语句中显式指定 loader</li><li>CLI 方式：在 shell 命令中指定它们</li></ol><blockquote><p>关于 loader 的配置，我们是写在 module.rules 属性中，属性介绍如下：</p></blockquote><ol><li>rules 是一个数组的形式，因此我们可以配置很多个 loader</li><li>每一个 loader 对应一个对象的形式，对象属性 test 为匹配的规则，一般情况为正则表达式</li><li>属性 use 针对匹配到文件类型，调用对应的 loader 进行处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<br>          &#123; <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;style-loader&#x27;</span> &#125;,<br>          &#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,<br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>,<br>            &#125;,<br>          &#125;,<br>          &#123; <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;sass-loader&#x27;</span> &#125;,<br>        ],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>use 属性中配置了三个 loader 分别处理 css 文件因为 loader 支持<code>链式调用</code>，</li><li>loader 可以是<code>同步</code>的，也可以是<code>异步</code>的</li></ol><h3 id="常见的-loader"><a href="#常见的-loader" class="headerlink" title="常见的 loader"></a>常见的 loader</h3><ol><li>style-loader: 将 css 添加到 DOM 的内联样式标签 style 里</li><li>css-loader :允许将 css 文件通过 require 的方式引入，并返回 css 代码</li><li>less-loader: 处理 less</li><li>sass-loader: 处理 sass</li><li>postcss-loader: 用 postcss 来处理 CSS</li><li>autoprefixer-loader: 处理 CSS3 属性前缀，已被弃用，建议直接使用 postcss</li><li>file-loader: 分发文件到 output 目录并返回相对路径</li><li>url-loader: 和 file-loader 类似，但是当文件小于设定的 limit 时可以返回一个 Data Url</li><li>html-minify-loader: 压缩 HTML</li><li>babel-loader :用 babel 来转换 ES6 文件到 ES</li></ol><h2 id="4-说说-webpack-中常见的-Plugin？解决了什么问题？"><a href="#4-说说-webpack-中常见的-Plugin？解决了什么问题？" class="headerlink" title="4. 说说 webpack 中常见的 Plugin？解决了什么问题？"></a>4. 说说 webpack 中常见的 Plugin？解决了什么问题？</h2><blockquote><p>Plugin（Plug-in）是一种计算机应用程序，它和主应用程序互相交互，以提供特定的功能<br>目的在于解决 loader 无法实现的其他事</p></blockquote><p><strong>配置方式:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  ...<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProgressPlugin</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123; <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span> &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><blockquote><p>其本质是一个具有 apply 方法 javascript 对象<br>apply 方法会被 webpack compiler 调用，并且在整个编译生命周期都可以访问 compiler 对象</p></blockquote><p><strong>关于整个编译生命周期钩子，有如下：</strong></p><ol><li>entry-option ：初始化 option</li><li>run</li><li>compile： 真正开始的编译，在创建 compilation 对象之前</li><li>compilation ：生成好了 compilation 对象</li><li>make 从 entry 开始递归分析依赖，准备对每个模块进行 build</li><li>after-compile： 编译 build 过程结束</li><li>emit ：在将内存中 assets 内容写到磁盘文件夹之前</li><li>after-emit ：在将内存中 assets 内容写到磁盘文件夹之后</li><li>done： 完成所有的编译过程</li><li>failed： 编译失败的时候</li></ol><h3 id="常用的-Plugin"><a href="#常用的-Plugin" class="headerlink" title="常用的 Plugin"></a>常用的 Plugin</h3><ol><li>HtmlWebpackPlugin<blockquote><p>在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的 js 模块引⼊到该 html 中</p></blockquote></li><li>clean-webpack-plugin<br>删除（清理）构建目录</li><li>mini-css-extract-plugin<br>提取 CSS 到一个单独的文件中</li><li>DefinePlugin<br>允许在编译时创建配置的全局对象，是一个 webpack 内置的插件，不需要安装</li><li>copy-webpack-plugin<br>复制文件或目录到执行区域，如 vue 的打包过程中，如果我们将一些文件放到 public 的目录下，那么这个目录会被复制到 dist 文件夹中</li></ol><h2 id="5-说说-Loader-和-Plugin-的区别？编写-Loader，Plugin-的思路？"><a href="#5-说说-Loader-和-Plugin-的区别？编写-Loader，Plugin-的思路？" class="headerlink" title="5. 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？"></a>5. 说说 Loader 和 Plugin 的区别？编写 Loader，Plugin 的思路？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><blockquote><p>loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中<br>plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事</p></blockquote><ol><li><p>运行时机上的区别：</p><ul><li>loader 运行在打包文件之前</li><li>plugins 在整个编译周期都起作用</li></ul></li><li><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果<br>对于 loader，实质是一个转换器，将 A 文件进行编译形成 B 文件，操作的是文件，比如将 A.scss 或 A.less 转变为 B.css，单纯的文件转换过程</p></li></ol><h3 id="编写-Loader-的思路"><a href="#编写-Loader-的思路" class="headerlink" title="编写 Loader 的思路"></a>编写 Loader 的思路</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导出一个函数，source为webpack传递给loader的文件源内容</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">const</span> content = <span class="hljs-title function_">doSomeThing2JsString</span>(source)<br>  <span class="hljs-comment">// 如果 loader 配置了 options 对象，那么this.query将指向 options</span><br>  <span class="hljs-keyword">const</span> options = <span class="hljs-variable language_">this</span>.<span class="hljs-property">query</span><br>  <span class="hljs-comment">// 可以用作解析其他模块路径的上下文</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this.context&#x27;</span>)<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * this.callback 参数：</span><br><span class="hljs-comment">   * error：Error | null，当 loader 出错时向外抛出一个 error</span><br><span class="hljs-comment">   * content：String | Buffer，经过 loader 编译后需要导出的内容</span><br><span class="hljs-comment">   * sourceMap：为方便调试生成的编译后内容的 source map</span><br><span class="hljs-comment">   * ast：本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，进而省去重复生成 AST 的过程</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">callback</span>(<span class="hljs-literal">null</span>, content) <span class="hljs-comment">// 异步</span><br>  <span class="hljs-keyword">return</span> content <span class="hljs-comment">// 同步</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写-Plugin-的思路"><a href="#编写-Plugin-的思路" class="headerlink" title="编写 Plugin 的思路"></a>编写 Plugin 的思路</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> &#123;<br>  <span class="hljs-comment">// Webpack 会调用 MyPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// 找到合适的事件钩子，实现自己的插件功能</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">emit</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;MyPlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// compilation: 当前打包构建流程的上下文</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(compilation)<br><br>      <span class="hljs-comment">// do something...</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-说说-webpack-的热更新是如何做到的？原理是什么？"><a href="#6-说说-webpack-的热更新是如何做到的？原理是什么？" class="headerlink" title="6. 说说 webpack 的热更新是如何做到的？原理是什么？"></a>6. 说说 webpack 的热更新是如何做到的？原理是什么？</h2><blockquote><p>我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失<br>HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用</p></blockquote><p><strong>配置方式：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 开启 HMR 特性</span><br>    <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// hotOnly: true</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-comment">// 我们需要去指定哪些模块发生更新时进行HRM，如下代码：</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>) &#123;<br>  <span class="hljs-variable language_">module</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">&#x27;./util.js&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;util.js更新了&#x27;</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>关于 webpack 热模块更新的总结如下：</p><ol><li>通过 webpack-dev-server 创建两个服务器：提供静态资源的服务（express）和 Socket 服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新</li></ol><h2 id="7-说说-webpack-proxy-工作原理？为什么能解决跨域"><a href="#7-说说-webpack-proxy-工作原理？为什么能解决跨域" class="headerlink" title="7. 说说 webpack proxy 工作原理？为什么能解决跨域?"></a>7. 说说 webpack proxy 工作原理？为什么能解决跨域?</h2><blockquote><p>webpack proxy，即 webpack 提供的代理服务<br>基本行为就是接收客户端发送的请求后转发给其他服务器<br>其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）<br>在同域的服务器上设置一个代理，由代理服务器去请求其他域上的资源，再将结果返回给前端。这样，前端只需要请求同域的资源，就能避免跨域问题。</p></blockquote><h3 id="关于配置方面，在-webpack-配置对象属性中通过-devServer-属性提供，如下："><a href="#关于配置方面，在-webpack-配置对象属性中通过-devServer-属性提供，如下：" class="headerlink" title="关于配置方面，在 webpack 配置对象属性中通过 devServer 属性提供，如下："></a>关于配置方面，在 webpack 配置对象属性中通过 devServer 属性提供，如下：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ./webpack.config.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">contentBase</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">9000</span>,<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://api.github.com&#x27;</span>,<br>      &#125;,<br>    &#125;,<br>    <span class="hljs-comment">// ...</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>devServetr 里面 proxy 则是关于代理的配置，该属性为对象的形式，对象中每一个属性就是一个代理的规则匹配</p></li><li><p>属性的名称是需要被代理的请求路径前缀，一般为了辨别都会设置前缀为&#x2F;api，值为对应的代理匹配规则，对应如下：</p><ul><li>target：表示的是代理到的目标地址</li><li>pathRewrite：默认情况下，我们的 &#x2F;api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite</li><li>secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false</li><li>changeOrigin：它表示是否更新代理后请求的 headers 中 host 地址</li></ul></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><blockquote><p>proxy 工作原理实质上是利用 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器</p></blockquote><p><strong>举个例子：</strong></p><blockquote><p>在开发阶段，本地地址为 <a href="http://localhost:3000，该浏览器发送一个前缀带有/api">http://localhost:3000，该浏览器发送一个前缀带有/api</a> 标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>(&#123; <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.example.org&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> &#125;))<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)<br><span class="hljs-comment">// http://localhost:3000/api/foo/bar -&gt; http://www.example.org/api/foo/bar</span><br></code></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><blockquote><p>所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题</p></blockquote><p>解决过程：<br>当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地</p><p>在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据<br>注意：服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制</p><h2 id="8-说说如何借助-webpack-来优化前端性能？"><a href="#8-说说如何借助-webpack-来优化前端性能？" class="headerlink" title="8. 说说如何借助 webpack 来优化前端性能？"></a>8. 说说如何借助 webpack 来优化前端性能？</h2><p>通过 webpack 优化前端的手段有：</p><ol><li>JS 代码压缩</li></ol><ul><li>terser,webpack 默认就是使用 TerserPlugin 来处理我们的代码的</li></ul><ol start="2"><li>CSS 代码压缩</li></ol><ul><li>css-minimizer-webpack-plugin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">CssMinimizerPlugin</span>(&#123;<br>        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,<br>      &#125;),<br>    ],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>Html 文件代码压缩</li></ol><ul><li>使用 HtmlWebpackPlugin 插件来生成 HTML 的模板时候，通过配置属性 minify 进行 html 优化</li></ul><ol start="4"><li>文件大小压缩</li><li>图片压缩</li><li>Tree Shaking</li></ol><ul><li>Tree Shaking 是一个术语，在计算机中表示消除死代码，依赖于 ES Module 的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）</li></ul><ol start="7"><li>代码分离</li></ol><ul><li>将代码分离到不同的 bundle 中，之后我们可以按需加载，或者并行加载这些文件</li></ul><ol start="8"><li>内联 chunk</li></ol><ul><li>可以通过 InlineChunkHtmlPlugin 插件将一些 chunk 的模块内联到 html，如 runtime 的代码（对模块进行解析、加载、模块信息相关的代码），代码量并不大，但是必须加载的</li></ul><h2 id="9-如何提高-webpack-的构建速度"><a href="#9-如何提高-webpack-的构建速度" class="headerlink" title="9. 如何提高 webpack 的构建速度"></a>9. 如何提高 webpack 的构建速度</h2><p>常见的提升构建速度的手段有如下：</p><ul><li>优化 loader 配置<blockquote><p>在使用 loader 时，可以通过配置 include、exclude、test 属性来匹配文件，接触 include、exclude 规定哪些匹配应用 loader</p></blockquote></li><li>合理使用 resolve.extensions</li><li>优化 resolve.modules<blockquote><p>所以可以指明存放第三方模块的绝对路径，以减少寻找，配置如下：</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-comment">// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤</span><br>    <span class="hljs-comment">// 其中 __dirname 表示当前工作目录，也就是项目根目录</span><br>    <span class="hljs-attr">modules</span>: [path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;node_modules&#x27;</span>)],<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>优化 resolve.alias<blockquote><p>alias 给一些常用的路径起一个别名，特别当我们的项目目录结构比较深的时候，一个文件的路径可能是.&#x2F;..&#x2F;..&#x2F;的形式</p></blockquote></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    ...<br>    <span class="hljs-attr">resolve</span>:&#123;<br>        <span class="hljs-attr">alias</span>:&#123;<br>            <span class="hljs-string">&quot;@&quot;</span>:path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;./src&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 DLLPlugin 插件</li><li>使用 cache-loader<blockquote><p>在一些性能开销较大的 loader 之前添加 cache-loader，以将结果缓存到磁盘里，显著提升二次构建速度</p></blockquote></li><li>terser 启动多线程<blockquote><p>terser 启动多线程<br>使用多进程并行运行来提高构建速度</p></blockquote></li><li>合理使用 sourceMap</li></ul><h2 id="10-与webpack类似的工具还有哪些？区别？"><a href="#10-与webpack类似的工具还有哪些？区别？" class="headerlink" title="10. 与webpack类似的工具还有哪些？区别？"></a>10. 与webpack类似的工具还有哪些？区别？</h2><ol><li><p>Rollup<br>Rollup 是一款 <code>ES Modules</code> 打包器，从作用上来看，Rollup 与 Webpack 非常类似。不过相比于 Webpack，Rollup要<code>小巧</code>的多<br>现在很多我们熟知的库都都使用它进行打包，比如：Vue、React和three.js等</p></li><li><p>Parcel</p><blockquote><p>Parcel ，是一款完全零配置的前端打包器，它提供了 “傻瓜式” 的使用体验，只需了解简单的命令，就能构建前端应用程序</p></blockquote></li><li><p>Snowpack</p><blockquote><p>是一种闪电般快速的前端构建工具,Snowpack为你的应用程序每个文件构建一次，就可以永久缓存，文件更改时，Snowpack会重新构建该单个文件</p></blockquote></li><li><p>Vite</p><blockquote><p>vite ，是一种新型前端构建工具，能够显著提升前端开发体验</p></blockquote></li></ol><p><strong>它主要由两部分组成：</strong></p><ol><li>一个开发服务器，它基于 原生 ES 模块 提供了丰富的内建功能，如速度快到惊人的模块热更新HMR</li><li>一套构建指令，它使用 Rollup打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源</li></ol><p><strong>其作用类似webpack+ webpack-dev-server，其特点如下：</strong></p><ol><li>快速的冷启动</li><li>即时的模块热更新</li><li>真正的按需编译<br>vite会直接启动开发服务器，不需要进行打包操作，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快<br>利用现代浏览器支持ES Module的特性，当浏览器请求某个模块的时候，再根据需要对模块的内容进行编译，这种方式大大缩短了编译时间</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Webpack系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS系列</title>
    <link href="/2024/02/25/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/CSS%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/25/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/CSS%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-CSS-系列"><a href="#🍭-CSS-系列" class="headerlink" title="🍭 CSS 系列"></a>🍭 CSS 系列</h1><h2 id="1-css-盒模型"><a href="#1-css-盒模型" class="headerlink" title="1. css 盒模型"></a>1. css 盒模型</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">HTML中的每个元素都可以看作一个盒子，<br>这个盒子由元素的内容(content)、内边距(padding)、边框(border)、外边距(margin)组成。<br></code></pre></td></tr></table></figure><blockquote><p>盒模型分为两种：标准盒模型和 IE 盒模型。</p></blockquote><p>1.<strong>标准盒模型</strong>：(width不包括border和padding)<br>width &#x3D; margin + border + padding + content</p><blockquote><p>盒子 width&#x2F;height 就是 content，改变 border 和 padding 不会改变 content 内容的宽高，但是会改变盒子总宽高</p></blockquote><p>2.<strong>IE 盒模型</strong>：(width包括border和padding)<br>width &#x3D; margin + content(包含 border 和 padding)</p><blockquote><p>盒子 width&#x2F;height 包括 content+padding+border，改变 padding 和 border 不会改变总宽高，会改变 content 的宽高</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* IE 盒模型 */</span><br>    <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 标准盒模型(默认值) */</span><br>    <span class="hljs-attribute">box-sizing</span>: inherit;<span class="hljs-comment">/* 继承父元素 */</span><br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h2 id="2-css-选择器有哪些？优先级？哪些属性可以继承？"><a href="#2-css-选择器有哪些？优先级？哪些属性可以继承？" class="headerlink" title="2. css 选择器有哪些？优先级？哪些属性可以继承？"></a>2. css 选择器有哪些？优先级？哪些属性可以继承？</h2><ol><li>基本选择器：<br>&#x2F;ID 选择器(#id)&#x2F;类选择器(.class)&#x2F;属性选择器([attr])&#x2F;标签选择器(div)&#x2F;通配符选择器(*)</li><li>伪选择器：<br>&#x2F;伪类(.class::hover)&#x2F;伪元素(div::before)</li><li>分组选择器</li><li>组合器<br>&#x2F;子选择器(div&gt;p)&#x2F;兄弟选择器(div+p)</li></ol><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ol start="0"><li>第一优先级：!important 会覆盖页面内任何位置的元素样式</li><li>内联样式，如 style&#x3D;”color: green”，权值为 1000</li><li>ID 选择器，如#app，权值为 0100</li><li>类、伪类、属性选择器，如.foo, :first-child, div[class&#x3D;”foo”]，权值为 0010</li><li>标签、伪元素选择器，如 div::first-line，权值为 0001</li><li>通配符、子类选择器、兄弟选择器，如*, &gt;, +，权值为 0000</li><li>继承的样式没有权值</li></ol><h3 id="继承样式"><a href="#继承样式" class="headerlink" title="继承样式"></a>继承样式</h3><ol><li><p>可继承 <code>字体系列属性</code>&#x2F;<code>文本系列属性</code>&#x2F;<code>表格布局属性</code>&#x2F;<code>列表属性</code>&#x2F; <code>元素可见性</code></p></li><li><p>不可继承 <code>display</code>&#x2F;<code>盒子模型的属性：宽度、高度、内外边距、边框等</code>&#x2F;<code>背景属性：背景图片、颜色、位置等</code>&#x2F;<code>定位属性</code></p></li></ol><h2 id="3-说说-em-x2F-px-x2F-rem-x2F-vh-x2F-vw-区别"><a href="#3-说说-em-x2F-px-x2F-rem-x2F-vh-x2F-vw-区别" class="headerlink" title="3. 说说 em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw 区别?"></a>3. 说说 em&#x2F;px&#x2F;rem&#x2F;vh&#x2F;vw 区别?</h2><h3 id="px-像素"><a href="#px-像素" class="headerlink" title="px 像素"></a>px 像素</h3><blockquote><p>所谓像素就是呈现在我们显示器上的一个个小点 px 为绝对单位</p></blockquote><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><blockquote><p>em 是相对长度单位。相对于当前对象内文本的字体尺寸;如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em &#x3D; 16px）</p></blockquote><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>rem，相对单位，相对的只是 HTML 根元素 font-size 的值</p><h3 id="vh-x2F-vw"><a href="#vh-x2F-vw" class="headerlink" title="vh&#x2F;vw"></a>vh&#x2F;vw</h3><blockquote><p>vw ，就是根据窗口的宽度，分成 100 等份，100vw 就表示满宽，50vw 就表示一半宽。（vw 始终是针对窗口的宽），同理，vh 则为窗口的高度</p></blockquote><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><ol><li>@media(媒体查询)+rem 相对单位</li><li>vw+rem</li><li>flexible</li></ol><h2 id="4-css-中，有哪些方式可以隐藏页面元素？区别"><a href="#4-css-中，有哪些方式可以隐藏页面元素？区别" class="headerlink" title="4. css 中，有哪些方式可以隐藏页面元素？区别?"></a>4. css 中，有哪些方式可以隐藏页面元素？区别?</h2><ol><li>display:none<blockquote><p>特点：元素不可见，不占据空间，无法响应点击事件</p></blockquote></li><li>visibility:hidden<blockquote><p>元素不可见，占据页面空间，无法响应点击事件</p></blockquote></li><li>opacity:0<blockquote><p>改变元素透明度，元素不可见，占据页面空间，可以响应点击事件</p></blockquote></li><li>设置 height、width 模型属性为 0<blockquote><p>元素不可见，不占据页面空间，无法响应点击事件</p></blockquote></li><li>position:absolute,移出可视区域<blockquote><p>元素不可见，不影响页面布局</p></blockquote></li><li>clip-path<blockquote><p><code>clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);</code><br>元素不可见，占据页面空间，无法响应点击事件</p></blockquote></li></ol><h2 id="5-谈谈你对-BFC-的理解？"><a href="#5-谈谈你对-BFC-的理解？" class="headerlink" title="5. 谈谈你对 BFC 的理解？"></a>5. 谈谈你对 BFC 的理解？</h2><blockquote><p>BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的渲染规则：<br>BFC 目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素</p></blockquote><ol><li>内部的盒子会在垂直方向上一个接一个的放置</li><li>对于同一个 BFC 的俩个相邻的盒子的 margin 会发生重叠，与方向无关。</li><li>每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 的高度时，浮动子元素也参与计算</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然</li></ol><h3 id="触发-BFC-的条件包含不限于："><a href="#触发-BFC-的条件包含不限于：" class="headerlink" title="触发 BFC 的条件包含不限于："></a>触发 BFC 的条件包含不限于：</h3><ol><li>根元素，即 HTML 元素</li><li>浮动元素：float 值为 left、right</li><li>overflow 值不为 visible，为 auto、scroll、hidden</li><li>display 的值为 inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid</li><li>position 的值为 absolute 或 fixed</li></ol><h2 id="6-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"><a href="#6-元素水平垂直居中的方法有哪些？如果元素不定宽高呢？" class="headerlink" title="6. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？"></a>6. 元素水平垂直居中的方法有哪些？如果元素不定宽高呢？</h2><h3 id="1-flex"><a href="#1-flex" class="headerlink" title="1 flex"></a>1 flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.flex+margin */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.flex */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-绝对定位"><a href="#2-绝对定位" class="headerlink" title="2 绝对定位"></a>2 绝对定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleHeight);<br>  <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleWeight);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-grid"><a href="#3-grid" class="headerlink" title="3 grid"></a>3 grid</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.grid */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-table"><a href="#4-table" class="headerlink" title="4 table"></a>4 table</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-block;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"><a href="#7-如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？" class="headerlink" title="7. 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？"></a>7. 如何实现两栏布局，右侧自适应？三栏布局中间自适应呢？</h2><h3 id="两栏"><a href="#两栏" class="headerlink" title="两栏"></a>两栏</h3><ol><li>float:<blockquote><p>两栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在</p></blockquote></li></ol><p><strong>实现思路也非常的简单：</strong></p><ol><li><p>使用 float 左浮左边栏</p></li><li><p>右边模块使用 margin-left 撑出内容块做内容展示</p></li><li><p>为父级元素添加 BFC，防止下方元素飞到上方内容</p></li><li><p>flex:</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右边<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>flex 可以说是最好的方案了，代码少，使用简单</p><p>注意的是，flex 容器的一个默认属性值:align-items: stretch;</p><h3 id="三栏"><a href="#三栏" class="headerlink" title="三栏"></a>三栏</h3><p><strong>实现三栏布局中间自适应的布局方式有：</strong></p><ol><li><p>两边使用 float，中间使用 margin</p></li><li><p>两边使用 absolute，中间使用 margin</p></li><li><p>两边使用 float 和负 margin(双飞翼)</p></li><li><p>display: table 实现</p><ol><li>层通过 display: table 设置为表格，设置 table-layout: fixed&#96;表示列宽自身宽度决定，而不是自动计算。</li><li>内层的左中右通过 display: table-cell 设置为表格单元。</li><li>左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度</li></ol></li><li><p>flex 实现</p><ol><li>仅需将容器设置为 display:flex;，</li><li>盒内元素两端对其，将中间元素设置为 100%宽度，或者设为 flex:1，即可填充空白</li><li>盒内元素的高度撑开容器的高度</li></ol></li><li><p>grid 网格布局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-property">parent</span> &#123;<br>    <span class="hljs-attr">display</span>: grid;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%;<br>    grid-template-<span class="hljs-attr">columns</span>: 300px auto 300px;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-CSS3-新增了哪些新特性？"><a href="#8-CSS3-新增了哪些新特性？" class="headerlink" title="8. CSS3 新增了哪些新特性？"></a>8. CSS3 新增了哪些新特性？</h2><h3 id="css3-中新增了一些选择器-层次选择器-x2F-伪类选择器-x2F-属性选择器"><a href="#css3-中新增了一些选择器-层次选择器-x2F-伪类选择器-x2F-属性选择器" class="headerlink" title="css3 中新增了一些选择器:层次选择器&#x2F;伪类选择器&#x2F;属性选择器"></a>css3 中新增了一些选择器:<code>层次选择器</code>&#x2F;<code>伪类选择器</code>&#x2F;<code>属性选择器</code></h3><h3 id="新样式"><a href="#新样式" class="headerlink" title="新样式"></a>新样式</h3><ol><li><p>边框 css3 新增了三个边框属性，分别是：</p><ol><li>border-radius：创建圆角边框</li><li>box-shadow：为元素添加阴影</li><li>border-image：使用图片来绘制边框</li></ol><h4 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h4><p>设置元素阴影，设置属性如下：</p><ol><li>水平阴影</li><li>垂直阴影</li><li>模糊距离(虚实)</li><li>阴影尺寸(影子大小)</li><li>阴影颜色</li><li>内&#x2F;外阴影</li></ol></li><li><p>背景<br>新增了几个关于背景的属性，分别是 background-clip、background-origin、background-size 和 background-break</p><ul><li>background-clip:<code>background-clip: border-box; 背景从border开始显示</code></li><li>background-origin:<code>background-origin: border-box; 从border开始计算background-position</code></li></ul></li><li><p>文字</p><ul><li>word-wrap</li><li>text-overflow<blockquote><p>设置或检索当当前行超过指定容器的边界时如何显示</p></blockquote></li><li>text-shadow<blockquote><p>可向文本应用阴影</p></blockquote></li><li>text-decoration</li></ul></li><li><p>颜色<br>css3 新增了新的颜色表示方式 rgba 与 hsla</p></li></ol><h3 id="transition-过渡"><a href="#transition-过渡" class="headerlink" title="transition 过渡"></a>transition 过渡</h3><p>transition 属性可以被指定为一个或多个 CSS 属性的过渡效果，多个属性之间用逗号进行分隔，必须规定两项内容：1. 过度效果 2. 持续时间<br><code>transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)</code></p><h3 id="transform-转换"><a href="#transform-转换" class="headerlink" title="transform 转换"></a>transform 转换</h3><h3 id="animation-动画"><a href="#animation-动画" class="headerlink" title="animation 动画"></a>animation 动画</h3><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>颜色渐变是指在两个颜色之间平稳的过渡，css3 渐变包括</p><ol><li>linear-gradient：线性渐变<br>background-image: linear-gradient(direction, color-stop1, color-stop2, …);</li><li>radial-gradient：径向渐变<br>linear-gradient(0deg, red, green);</li></ol><h2 id="9-css3-动画有哪些？"><a href="#9-css3-动画有哪些？" class="headerlink" title="9. css3 动画有哪些？"></a>9. css3 动画有哪些？</h2><ol><li><p>transition 实现渐变动画<br>参数：</p><ul><li>property:填写需要变化的 css 属性</li><li>duration:完成过渡效果需要的时间单位(s 或者 ms)</li><li>timing-function:完成效果的速度曲线</li><li>delay: 动画效果的延迟触发时间</li></ul></li><li><p>transform 转变动画<br>包含四个常用的功能：</p><ul><li>translate：位移</li><li>scale：缩放</li><li>rotate：旋转</li><li>skew：倾斜</li></ul></li><li><p>animation 实现自定义动画</p><ul><li>通过 @keyframes 来定义关键帧<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> rotate &#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">0deg</span>);<br>  &#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<br>  &#125;<br>&#125;<br><span class="hljs-attribute">animation</span>: rotate <span class="hljs-number">2s</span>;<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="10-怎么理解回流跟重绘？什么场景下会触发？"><a href="#10-怎么理解回流跟重绘？什么场景下会触发？" class="headerlink" title="10. 怎么理解回流跟重绘？什么场景下会触发？"></a>10. 怎么理解回流跟重绘？什么场景下会触发？</h2><blockquote><p>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置<br>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</p></blockquote><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><ol><li>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</li><li>将 DOM 树和 CSSOM 树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给 GPU，展示在页面上</li></ol><h3 id="回流触发时机"><a href="#回流触发时机" class="headerlink" title="回流触发时机"></a>回流触发时机</h3><blockquote><p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p></blockquote><ol><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li><li>页面一开始渲染的时候（这避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的</li></ol><h3 id="重绘触发时机"><a href="#重绘触发时机" class="headerlink" title="重绘触发时机"></a>重绘触发时机</h3><blockquote><p>触发回流一定会触发重绘</p></blockquote><ol><li>颜色的修改</li><li>文本方向的修改</li><li>阴影的修改</li></ol><h3 id="减少回流重绘性能消耗"><a href="#减少回流重绘性能消耗" class="headerlink" title="减少回流重绘性能消耗"></a>减少回流重绘性能消耗</h3><ol><li>如果想设定元素的样式，通过改变元素的 class 类名 (尽可能在 DOM 树的最里层)<br>避免设置多项内联样式</li><li>应用元素的动画，使用 position 属性的 fixed 值或 absolute 值(如前文示例所提)</li><li>避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算</li><li>对于那些复杂的动画，对其设置 position: fixed&#x2F;absolute，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li><li>使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘</li><li>避免使用 CSS 的 JavaScript 表达式</li></ol><h2 id="11-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#11-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="11. 什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>11. 什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><blockquote><p>响应式网站设计（Responsive Web design）是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><blockquote><p>响应式设计的基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理，为了处理移动端，页面头部必须有 meta 声明 viewport</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no”&gt;</span></span><br></code></pre></td></tr></table></figure><p>属性对应如下：</p><ol><li>width&#x3D;device-width: 是自适应手机屏幕的尺寸宽度</li><li>maximum-scale:是缩放比例的最大值</li><li>inital-scale:是缩放的初始化</li><li>user-scalable:是用户的可以缩放的操作</li></ol><p>实现响应式布局的方式有如下：</p><ol><li>媒体查询</li><li>百分比</li><li>vw&#x2F;vh</li><li>rem</li></ol><h2 id="12-如果要做优化，CSS-提高性能的方法有哪些？"><a href="#12-如果要做优化，CSS-提高性能的方法有哪些？" class="headerlink" title="12. 如果要做优化，CSS 提高性能的方法有哪些？"></a>12. 如果要做优化，CSS 提高性能的方法有哪些？</h2><p>实现方式有很多种，主要有如下：</p><ol><li>内联首屏关键 CSS</li><li>异步加载 CSS</li><li>资源压缩</li><li>合理使用选择器</li><li>减少使用昂贵的属性</li><li>不要使用@import</li><li>其他<ul><li>减少重排操作，以及减少不必要的重绘</li><li>了解哪些属性可以继承而来，避免对这些属性重复编写</li><li>cssSprite，合成所有 icon 图片，用宽高加上 backgroud-position 的背景图方式显现- 出我们要的 icon 图，减少了 http 请求</li><li>把小的 icon 图片转成 base64 编码</li><li>CSS3 动画或者过渡尽量使用 transform 和 opacity 来实现动画，不要使用 left 和 top 属性</li></ul></li></ol><h2 id="13-如何实现单行／多行文本溢出的省略样式？"><a href="#13-如何实现单行／多行文本溢出的省略样式？" class="headerlink" title="13. 如何实现单行／多行文本溢出的省略样式？"></a>13. 如何实现单行／多行文本溢出的省略样式？</h2><h3 id="单行文本溢出省略"><a href="#单行文本溢出省略" class="headerlink" title="单行文本溢出省略"></a>单行文本溢出省略</h3><ol><li>text-overflow：规定当文本溢出时，显示省略符号来代表被修剪的文本</li><li>white-space：设置文字在一行显示，不能换行</li><li>overflow：文字长度超出限定宽度，则隐藏超出的内容</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多行文本溢出省略"><a href="#多行文本溢出省略" class="headerlink" title="多行文本溢出省略"></a>多行文本溢出省略</h3><ol><li>基于高度截断<blockquote><p>实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 overflow: hidden 隐藏多余文字</p></blockquote></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.demo</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;...&#x27;</span>;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>基于行数截断</p><ol><li>-webkit-line-clamp: 2：用来限制在一个块元素显示的文本的行数，为了实现该效果，它需要组合其他的 WebKit 属性）</li><li>display: -webkit-box：和 1 结合使用，将对象作为弹性伸缩盒子模型显示</li><li>-webkit-box-orient: vertical：和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式</li><li>overflow: hidden：文本溢出限定的宽度就隐藏内容</li><li>text-overflow: ellipsis：多行文本的情况下，用省略号“…”隐藏溢出范围的文本</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>  -webkit-line-clamp: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-box-orient: vertical;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="14-什么是-CSS-预处理器？有哪些常见的-CSS-预处理器？"><a href="#14-什么是-CSS-预处理器？有哪些常见的-CSS-预处理器？" class="headerlink" title="14. 什么是 CSS 预处理器？有哪些常见的 CSS 预处理器？"></a>14. 什么是 CSS 预处理器？有哪些常见的 CSS 预处理器？</h2><h3 id="预处理语言"><a href="#预处理语言" class="headerlink" title="预处理语言"></a>预处理语言</h3><ol><li>扩充了 Css 语言，增加了诸如变量、混合（mixin）、函数等功能，让 Css 更易维护、方便<br><strong>本质上，预处理是 Css 的超集</strong></li><li>包含一套自定义的语法及一个解析器，根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 Css 文件</li></ol><h3 id="Css-预编译语言在前端里面有三大优秀的预编处理器，分别是："><a href="#Css-预编译语言在前端里面有三大优秀的预编处理器，分别是：" class="headerlink" title="Css 预编译语言在前端里面有三大优秀的预编处理器，分别是："></a>Css 预编译语言在前端里面有三大优秀的预编处理器，分别是：</h3><ol><li>sass</li><li>less</li><li>stylus<blockquote><p>主要用来给 Node 项目进行 Css 预处理支持</p></blockquote></li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>虽然各种预处理器功能强大，但使用最多的，还是以下特性：</p><ol><li>变量（variables）<br>-less:<code>@red</code><br>-scss<code>$red</code></li><li>作用域（scope）<blockquote><p>sass 中不存在全局变量<br>ess 与 stylus 的作用域跟 javascript 十分的相似，首先会查找局部定义的变量，如果没有找到，会像冒泡一样，一级一级往下查找，直到根为止</p></blockquote></li><li>代码混合（ mixins）</li><li>嵌套（nested rules）</li><li>代码模块化（Modules）<ul><li>模块化就是将 Css 代码分成一个个模块</li><li>scss、less、stylus 三者的使用方法都如下所示<br><code>@import &#39;./common&#39;</code>;</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CSS系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript系列</title>
    <link href="/2024/02/24/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/24/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-JavaScript-系列"><a href="#🍭-JavaScript-系列" class="headerlink" title="🍭 JavaScript 系列"></a>🍭 JavaScript 系列</h1><h2 id="1-说说-JavaScript-中的数据类型"><a href="#1-说说-JavaScript-中的数据类型" class="headerlink" title="1. 说说 JavaScript 中的数据类型"></a>1. 说说 JavaScript 中的数据类型</h2><h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><ol><li>Number()</li></ol><table><thead><tr><th align="center">类型</th><th align="center">结果</th><th align="center"></th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">NaN</td><td align="center"></td></tr><tr><td align="center">null</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">true</td><td align="center">1</td><td align="center"></td></tr><tr><td align="center">false</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">字符串</td><td align="center">忽略前导 0，忽略前后空格，遇到非数字字符停止转换</td><td align="center"></td></tr><tr><td align="center">对象</td><td align="center">valueOf()方法返回原始值，否则 toString()方法返回原始值，否则报错</td><td align="center"></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象：通常转换成NaN(除了只包含单个数值的数组)</span><br><span class="hljs-title class_">Number</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-title class_">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>parseInt()</p></li><li><p>String()</p><table><thead><tr><th align="center">类型</th><th align="center">结果</th><th align="center"></th></tr></thead><tbody><tr><td align="center">undefined</td><td align="center">‘undefined’</td><td align="center"></td></tr><tr><td align="center">null</td><td align="center">‘null’</td><td align="center"></td></tr><tr><td align="center">true</td><td align="center">‘true’</td><td align="center"></td></tr><tr><td align="center">false</td><td align="center">‘false’</td><td align="center"></td></tr><tr><td align="center">对象</td><td align="center">valueOf()方法返回原始值，否则 toString()方法返回原始值，否则报错</td><td align="center"></td></tr></tbody></table></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//对象</span><br><span class="hljs-title class_">String</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-title class_">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>Boolean()<br>undefined&#x2F;null&#x2F;false&#x2F;+0&#x2F;-0&#x2F;NaN&#x2F;“”<br>除了上面几种会被转化成 false，其他都换被转化成 true</li></ol><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>比较运算（&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;）、if、while 需要布尔值地方<br>算术运算（+、-、*、&#x2F;、%）</p><h2 id="2-x3D-x3D-和-x3D-x3D-x3D-区别，分别在什么情况使用"><a href="#2-x3D-x3D-和-x3D-x3D-x3D-区别，分别在什么情况使用" class="headerlink" title="2. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用"></a>2. &#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;区别，分别在什么情况使用</h2><blockquote><p>等于操作符用两个等于号<code>（ == ）</code>表示，如果<code>操作数相等</code>，则会返回 true</p></blockquote><ol><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li><li>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</li><li>两个都为引用类型，则比较它们是否指向同一个对象</li><li>null 和 undefined 相等</li><li>存在 NaN 则返回 false</li></ol><blockquote><p>全等操作符由 3 个等于号（ &#x3D;&#x3D;&#x3D; ）表示，只有两个操作数在不转换的前提下相等才返回 true。即类型相同，值也需相同</p></blockquote><h2 id="3-深拷贝浅拷贝的区别？如何实现一个深拷贝？"><a href="#3-深拷贝浅拷贝的区别？如何实现一个深拷贝？" class="headerlink" title="3. 深拷贝浅拷贝的区别？如何实现一个深拷贝？"></a>3. 深拷贝浅拷贝的区别？如何实现一个深拷贝？</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝</p></blockquote><ol><li>如果属性是<code>基本类型</code>，拷贝的就是基本类型的<code>值</code>。如果属性是<code>引用类型</code>，拷贝的就是<code>内存地址</code></li><li>即浅拷贝是<code>拷贝一层</code>，深层次的引用类型则<code>共享内存地址</code></li></ol><h4 id="实现浅拷贝的方法"><a href="#实现浅拷贝的方法" class="headerlink" title="实现浅拷贝的方法"></a>实现浅拷贝的方法</h4><ol><li>Object.assign<br><code>const newObj = Object.assign(&#123;&#125;, obj);</code></li><li>Array.prototype.slice(), Array.prototype.concat()<br><code>const newArr = arr.slice(0)</code> <code>const newArr = arr.concat()</code></li><li>使用拓展运算符实现的复制<br><code>const newArr = [...arr]</code></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>深拷贝开辟一个<code>新的栈</code>，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</p></blockquote><h4 id="实现深拷贝的方法"><a href="#实现深拷贝的方法" class="headerlink" title="实现深拷贝的方法"></a>实现深拷贝的方法</h4><ol><li>_.cloneDeep()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>)<br><span class="hljs-keyword">const</span> obj2 = _.<span class="hljs-title function_">cloneDeep</span>(obj1)<br></code></pre></td></tr></table></figure><ol start="2"><li>jQuery.extend()</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jquery&#x27;</span>)<br><span class="hljs-keyword">const</span> obj2 = $.<span class="hljs-title function_">extend</span>(<span class="hljs-literal">true</span>, &#123;&#125;, obj1)<br></code></pre></td></tr></table></figure><ol start="3"><li><p>JSON.stringify()</p><blockquote><p>会忽略 undefined、symbol 和函数</p></blockquote><p><code>const obj2=JSON.parse(JSON.stringify(obj1));</code></p></li></ol><p>4 .手写循环递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-说说你对闭包的理解？闭包使用场景"><a href="#4-说说你对闭包的理解？闭包使用场景" class="headerlink" title="4. 说说你对闭包的理解？闭包使用场景"></a>4. 说说你对闭包的理解？闭包使用场景</h2><blockquote><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）<br>也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域</p></blockquote><h3 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h3><ol><li>创建私有变量延长变量的生命周期</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeSizer</span>(<span class="hljs-params">size</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = size + <span class="hljs-string">&#x27;px&#x27;</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> size12 = <span class="hljs-title function_">makeSizer</span>(<span class="hljs-number">12</span>)<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;size-12&#x27;</span>).<span class="hljs-property">onclick</span> = size12<br></code></pre></td></tr></table></figure><ol start="2"><li>柯里化函数<blockquote><p>柯里化的目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我们可以使用闭包柯里化这个计算面积的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getArea</span>(<span class="hljs-params">width</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">height</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> width * height<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> getTenWidthArea = <span class="hljs-title function_">getArea</span>(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span><br><span class="hljs-keyword">const</span> area1 = <span class="hljs-title function_">getTenWidthArea</span>(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li>使用闭包模拟私有方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> privateCounter = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeBy</span>(<span class="hljs-params">val</span>) &#123;<br>    privateCounter += val<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">changeBy</span>(<span class="hljs-number">1</span>)<br>    &#125;,<br>  &#125;<br>&#125;)()<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Counter1</span> = <span class="hljs-title function_">makeCounter</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">value</span>()) <span class="hljs-comment">/* logs 0 */</span><br><span class="hljs-title class_">Counter1</span>.<span class="hljs-title function_">increment</span>() */<br></code></pre></td></tr></table></figure><h3 id="闭包的缺点"><a href="#闭包的缺点" class="headerlink" title="闭包的缺点"></a>闭包的缺点</h3><p>闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄漏</p><h3 id="解决闭包的坏处"><a href="#解决闭包的坏处" class="headerlink" title="解决闭包的坏处"></a>解决闭包的坏处</h3><ol><li>限制闭包的作用域： 尽量避免在全局范围内创建闭包，而是在需要时将闭包限制在局部作用域内。这样可以减少闭包对内存的占用，避免因为闭包长时间占用内存而导致的内存泄漏问题。</li><li>及时释放资源： 当不再需要闭包时，要确保及时释放资源，避免内存泄漏。可以通过解除闭包引用、将闭包赋值为 null 等方式来手动释放资源，或者使用一些自动内存管理的工具来帮助检测和解决内存泄漏问题。</li></ol><h2 id="5-说说你对作用域链的理解"><a href="#5-说说你对作用域链的理解" class="headerlink" title="5. 说说你对作用域链的理解"></a>5. 说说你对作用域链的理解</h2><blockquote><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合<br>换句话说，作用域决定了代码区块中变量和其他资源的可见性</p></blockquote><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><blockquote><p>词法作用域，又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，JavaScript 遵循的就是词法作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span><br>  <span class="hljs-title function_">foo</span>()<br>&#125;<br><span class="hljs-title function_">bar</span>() <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><p>当在 Javascript 中使用一个变量的时候，首先 Javascript 引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域<br>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错</p></blockquote><h2 id="6-JavaScript-原型，原型链-有什么特点？"><a href="#6-JavaScript-原型，原型链-有什么特点？" class="headerlink" title="6. JavaScript 原型，原型链 ? 有什么特点？"></a>6. JavaScript 原型，原型链 ? 有什么特点？</h2><h3 id="https-vue3js-cn-interview-JavaScript-prototype-html-E4-BA-8C-E3-80-81-E5-8E-9F-E5-9E-8B-E9-93-BE"><a href="#https-vue3js-cn-interview-JavaScript-prototype-html-E4-BA-8C-E3-80-81-E5-8E-9F-E5-9E-8B-E9-93-BE" class="headerlink" title="https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE"></a><a href="https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE">https://vue3js.cn/interview/JavaScript/prototype.html#%E4%BA%8C%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE</a></h3><h3 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型(prototype)"></a>原型(prototype)</h3><blockquote><p>JavaScript 每个对象拥有一个原型对象<br>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾<br>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的 prototype 属性上，而非实例对象本身</p></blockquote><ol><li>函数可以有属性。 每个函数都有一个特殊的属性叫作原型 prototype</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( doSomething.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );<br><br><span class="hljs-comment">// 控制台输出</span><br>&#123;<br>    <span class="hljs-attr">constructor</span>: ƒ <span class="hljs-title function_">doSomething</span>(),<br>    <span class="hljs-attr">__proto__</span>: &#123;<br>        <span class="hljs-attr">constructor</span>: ƒ <span class="hljs-title class_">Object</span>(),<br>        <span class="hljs-attr">hasOwnProperty</span>: ƒ <span class="hljs-title function_">hasOwnProperty</span>(),<br>        <span class="hljs-attr">isPrototypeOf</span>: ƒ <span class="hljs-title function_">isPrototypeOf</span>(),<br>        <span class="hljs-attr">propertyIsEnumerable</span>: ƒ <span class="hljs-title function_">propertyIsEnumerable</span>(),<br>        <span class="hljs-attr">toLocaleString</span>: ƒ <span class="hljs-title function_">toLocaleString</span>(),<br>        <span class="hljs-attr">toString</span>: ƒ <span class="hljs-title function_">toString</span>(),<br>        <span class="hljs-attr">valueOf</span>: ƒ <span class="hljs-title function_">valueOf</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>constructor 属性指向函数本身<br>可以看到，原型对象有一个自有属性 constructor，这个属性指向该函数，如下图关系展示<img src="/2024/02/24/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/JavaScript%E7%B3%BB%E5%88%97/constructor.png" class></li></ol><h3 id="原型链-prototype-chain"><a href="#原型链-prototype-chain" class="headerlink" title="原型链(prototype chain)"></a>原型链(prototype chain)</h3><blockquote><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法<br>在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><blockquote><p><strong>proto</strong>作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p></blockquote><ol><li>每个对象的<strong>proto</strong>都是指向它的构造函数的原型对象 prototype 的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">person1.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>构造函数是一个函数对象，是通过 Function 构造器产生的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>原型对象本身是一个普通对象，而普通对象的构造函数都是 Object</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="4"><li>所有的构造器都是函数对象，函数对象都是 Function 构造产生的</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure><ol start="5"><li>Object 的原型对象也有<code>__proto__</code>属性指向 null，null 是原型链的顶端</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="7-Javascript-如何实现继承？"><a href="#7-Javascript-如何实现继承？" class="headerlink" title="7. Javascript 如何实现继承？"></a>7. Javascript 如何实现继承？</h2><blockquote><p>如果一个类别 B“继承自”另一个类别 A，就把这个 B 称为“A 的子类”，而把 A 称为“B 的父类别”也可以称“A 是 B 的超类”</p></blockquote><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><ol><li><p>原型链继承</p><blockquote><p>原型链继承的核心是将父类的实例作为子类的原型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child2&#x27;</span><br>&#125;<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>())<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">缺点：父类的实例属性会被所有子类共享,子类互相影响<br></code></pre></td></tr></table></figure></li><li><p>构造函数继承</p><blockquote><p>借助 call 调用 Parent 函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent1&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent1</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child) <span class="hljs-comment">// 没问题</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优化：父类的引用属性不会被共享<br>缺点：只能继承父类的实例属性和方法，不能继承原型属性/方法<br></code></pre></td></tr></table></figure></li><li><p>组合继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent3&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><br><span class="hljs-title class_">Parent3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child3</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 第二次调用 Parent3()</span><br>  <span class="hljs-title class_">Parent3</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;child3&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 第一次调用 Parent3()</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent3</span>()<br><span class="hljs-comment">// 手动挂上构造器，指向自己的构造函数</span><br><span class="hljs-title class_">Child3</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child3</span><br><span class="hljs-keyword">var</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>()<br><span class="hljs-keyword">var</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child3</span>()<br>s3.<span class="hljs-property">play</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-property">play</span>, s4.<span class="hljs-property">play</span>) <span class="hljs-comment">// 不互相影响</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s4.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// 正常输出&#x27;parent3&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">优化：融合了原型链继承和构造函数继承的优点，是 <span class="hljs-keyword">JavaScript </span>中最常用的继承模式<br>缺点：调用了两次父类构造函数<br></code></pre></td></tr></table></figure></li><li><p>原型式继承</p><blockquote><p>这里主要借助<code>Object.create</code>方法实现普通对象的继承</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> parent4 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent4&#x27;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;p2&#x27;</span>, <span class="hljs-string">&#x27;p3&#x27;</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">let</span> person4 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent4)<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">优点：简单易用<br>这种继承方式的缺点也很明显，因为<span class="hljs-keyword">Object</span>.<span class="hljs-keyword">create</span>方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能<br></code></pre></td></tr></table></figure></li><li><p>寄生式继承</p><blockquote><p>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> parent5 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parent5&#x27;</span>,<br>  <span class="hljs-attr">friends</span>: [<span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;p2&#x27;</span>, <span class="hljs-string">&#x27;p3&#x27;</span>],<br>  <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original)<br>  clone.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br><br><span class="hljs-keyword">let</span> person5 = <span class="hljs-title function_">clone</span>(parent5)<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：在原型式继承的基础上增强了实例<br>缺点：同样存在篡改的可能<br></code></pre></td></tr></table></figure></li><li><p>寄生组合式继承</p><blockquote><p>寄生组合式继承，借助解决普通对象的继承问题的 Object.create 方法，在前面几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">parent, child</span>) &#123;<br>  <span class="hljs-comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span><br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br>  child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span><br>&#125;<br><br><span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>)<br><br><span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span><br>&#125;<br><br><span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6) <span class="hljs-comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// parent6</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6.<span class="hljs-title function_">getFriends</span>()) <span class="hljs-comment">// child5</span><br></code></pre></td></tr></table></figure></li><li><p>ES6 继承</p><blockquote><p>ES6 中新增了 class 关键字，使得 JavaScript 的面向对象编程变得更加清晰，更加符合传统的面向对象编程</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent7</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  &#125;<br>  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child7</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent7</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> child7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child7</span>(<span class="hljs-string">&#x27;child7&#x27;</span>, <span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child7) <span class="hljs-comment">// Child7 &#123;name: &quot;child7&quot;, age: 18&#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child7.<span class="hljs-title function_">getName</span>()) <span class="hljs-comment">// child7</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">优点：语法简单，易于理解<br>缺点：无法继承原生构造函数<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-JavaScript-中执行上下文和执行栈是什么？"><a href="#8-JavaScript-中执行上下文和执行栈是什么？" class="headerlink" title="8. JavaScript 中执行上下文和执行栈是什么？"></a>8. JavaScript 中执行上下文和执行栈是什么？</h2><blockquote><p>执行上下文是一种对 Javascript 代码执行环境的抽象概念，也就是说只要有 Javascript 代码运行，那么它就一定是运行在执行上下文中</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol><li>创建阶段<ul><li>创建阶段主要做了两件事情，第一件事情是创建变量对象，第二件事情是确定 this 的指向</li><li>创建变量对象的过程中，主要做了三件事情，第一件事情是创建变量对象，第二件事情是创建作用域链，第三件事情是确定 this 的指向</li></ul></li><li>执行阶段<ul><li>执行阶段主要做了两件事情，第一件事情是执行代码，第二件事情是给变量赋值</li><li>执行代码的过程中，主要做了两件事情，第一件事情是执行代码，第二件事情是给变量赋值</li></ul></li><li>回收阶段<ul><li>回收阶段主要做了两件事情，第一件事情是回收变量，第二件事情是回收作用域链</li><li>回收变量的过程中，主要做了两件事情，第一件事情是回收变量，第二件事情是回收作用域链</li></ul></li></ol><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><blockquote><p>执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文</p></blockquote><h2 id="9-说说-JavaScript-中的事件模型"><a href="#9-说说-JavaScript-中的事件模型" class="headerlink" title="9. 说说 JavaScript 中的事件模型"></a>9. 说说 JavaScript 中的事件模型</h2><blockquote><p>javascript 中的<code>事件</code>，可以理解就是在 HTML 文档或者浏览器中发生的一种交互操作，使得网页具备互动性，<br>由于 DOM 是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了<code>事件流的概念</code></p></blockquote><p>事件流都会经历三个阶段：</p><ol><li>事件捕获阶段(capture phase)</li><li>处于目标阶段(target phase)</li><li>事件冒泡阶段(bubbling phase)</li></ol><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件模型可以分为三种：</p><h4 id="1-原始事件模型（DOM0-级）"><a href="#1-原始事件模型（DOM0-级）" class="headerlink" title="1.原始事件模型（DOM0 级）"></a>1.原始事件模型（DOM0 级）</h4><ol><li>通过 HTML 属性绑定</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--HTML代码中直接绑定--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun()&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>通过 JS 代码绑定</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过JS代码绑定</span><br><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)<br>btn.<span class="hljs-property">onclick</span> = fun<br></code></pre></td></tr></table></figure><ol start="3"><li>特点</li></ol><ul><li>绑定速度快</li><li>同一个类型的事件只能绑定一次</li><li>只支持冒泡，不支持捕获</li></ul><p>标准事件模型（DOM2 级）<br>IE 事件模型（基本不用）</p><h4 id="2-标准事件模型（DOM2-级）"><a href="#2-标准事件模型（DOM2-级）" class="headerlink" title="2.标准事件模型（DOM2 级）"></a>2.标准事件模型（DOM2 级）</h4><blockquote><p>在该事件模型中，一次事件共有三个过程:</p></blockquote><ol><li>事件捕获阶段：事件从 document 一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li><li>事件处理阶段：事件到达目标元素, 触发目标元素的监听函数</li><li>事件冒泡阶段：事件从目标元素冒泡到 document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件绑定监听函数的方式如下:</span><br><span class="hljs-title function_">addEventListener</span>(eventType, handler, useCapture)<br><span class="hljs-comment">// 事件移除监听函数的方式如下:</span><br><span class="hljs-title function_">removeEventListener</span>(eventType, handler, useCapture)<br><span class="hljs-comment">//参数说明:</span><br><span class="hljs-comment">//eventType: 事件类型, 如click, mouseover等</span><br><span class="hljs-comment">//handler: 事件处理函数</span><br><span class="hljs-comment">//useCapture: 是否在捕获阶段执行, 默认为false, 即在冒泡阶段执行</span><br></code></pre></td></tr></table></figure><h2 id="10-typeof-与-instanceof-区别"><a href="#10-typeof-与-instanceof-区别" class="headerlink" title="10. typeof 与 instanceof 区别"></a>10. typeof 与 instanceof 区别</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><blockquote><p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// &#x27;object&#x27;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> <span class="hljs-comment">// &#x27;function&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p></blockquote><p>使用如下：<code>object instanceof constructor</code></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值</li><li>instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断</li></ol><h2 id="11-说说你对-JavaScript-中的-new"><a href="#11-说说你对-JavaScript-中的-new" class="headerlink" title="11. 说说你对 JavaScript 中的 new"></a>11. 说说你对 JavaScript 中的 new</h2><ol><li>创建一个新的对象 obj</li><li>将对象与构建函数通过原型链连接起来</li><li>将构建函数中的 this 绑定到新建的对象 obj 上</li><li>根据构建函数返回类型作判断，如果是原始值则被忽略，如果是返回对象，需要正常处理</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">func, ...args</span>) &#123;<br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>  obj.<span class="hljs-property">__proto__</span> = func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">apply</span>(obj, args)<br>  <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-ajax-原理是什么？如何实现？"><a href="#12-ajax-原理是什么？如何实现？" class="headerlink" title="12. ajax 原理是什么？如何实现？"></a>12. ajax 原理是什么？如何实现？</h2><blockquote><p>即异步的 JavaScript 和 XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页内容。<br>Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 JavaScript 来操作 DOM 而更新页面</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>创建 Ajax 的核心对象 XMLHttpRequest 对象<br><code>const xhr = new XMLHttpRequest();</code></p></li><li><p>通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接<br><code>xhr.open(method, url, [async][, user][, password])</code></p></li><li><p>构建请求所需的数据内容，并通过 XMLHttpRequest 对象的 send() 方法发送给服务器端<br><code>xhr.send([body])</code></p></li><li><p>通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态;接受并处理服务端向客户端响应的数据结果;将处理结果更新到 HTML 页面中</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>request.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-keyword">if</span> (request.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-comment">// 整个请求过程完毕</span><br>    <span class="hljs-keyword">if</span> (request.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; request.<span class="hljs-property">status</span> &lt;= <span class="hljs-number">300</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request.<span class="hljs-property">responseText</span>) <span class="hljs-comment">// 服务端返回的结果</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (request.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">400</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;错误信息：&#x27;</span> + request.<span class="hljs-property">status</span>)<br>    &#125;<br>  &#125;<br>&#125;<br>request.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://xxxx&#x27;</span>)<br>request.<span class="hljs-title function_">send</span>()<br></code></pre></td></tr></table></figure><h2 id="13-说说你对事件循环"><a href="#13-说说你对事件循环" class="headerlink" title="13. 说说你对事件循环"></a>13. 说说你对事件循环</h2><blockquote><p>首先，JavaScript 是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环</p></blockquote><blockquote><p>同步任务进入主线程，即主执行栈，异步任务进入任务队列，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就事件循环</p></blockquote><p>在 JavaScript 中，所有的任务都可以分为</p><ol><li><p>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</p></li><li><p>异步任务：异步执行的任务，比如 ajax 网络请求，setTimeout 定时函数等</p><blockquote><p>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中<br>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</p></blockquote><ul><li>微任务：Promise、process.nextTick、MutationObserver</li><li>宏任务：script、setTimeout、setInterval、I&#x2F;O、UI rendering</li></ul></li></ol><h2 id="14-DOM-常见的操作有哪些？"><a href="#14-DOM-常见的操作有哪些？" class="headerlink" title="14. DOM 常见的操作有哪些？"></a>14. DOM 常见的操作有哪些？</h2><blockquote><p>文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口</p></blockquote><h3 id="下面就来分析-DOM-常见的操作，主要分为："><a href="#下面就来分析-DOM-常见的操作，主要分为：" class="headerlink" title="下面就来分析 DOM 常见的操作，主要分为："></a>下面就来分析 DOM 常见的操作，主要分为：</h3><ol><li>创建节点</li></ol><ul><li><code>createElement</code>,创建新元素，接受一个参数，即要创建元素的标签名</li><li><code>createTextNode</code>,创建文本节点，接受一个参数，即要创建的文本</li><li><code>createDocumentFragment</code>,创建一个新的空白文档片段</li><li><code>createAttribute</code>,创建一个新的属性节点</li></ul><ol start="2"><li>查询节点</li></ol><ul><li><code>getElementById</code>,通过元素的 id 属性值获取元素</li><li><code>getElementsByTagName</code>,通过元素的标签名获取元素</li><li><code>getElementsByClassName</code>,通过元素的 class 属性值获取元素</li><li><code>querySelector</code>,通过 CSS 选择器获取元素</li><li><code>querySelectorAll</code>,通过 CSS 选择器获取所有匹配的元素</li></ul><ol start="3"><li>更新节点</li></ol><ul><li><code>innerHTML</code>,不但可以修改一个 DOM 节点的文本内容，还可以直接通过 HTML 片段修改 DOM 节点内部的子树</li><li><code>innerText</code>,设置或返回被选元素的文本内容</li><li><code>style</code>,设置或返回被选元素的样式属性</li></ul><ol start="4"><li>添加节点</li></ol><ul><li><code>appendChild</code>,向节点添加最后一个子节点</li><li><code>insertBefore</code>,在指定的子节点前插入新的子节点</li><li><code>setAttribute</code>,设置元素的属性</li></ul><ol start="5"><li>删除节点<blockquote><p>删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的 removeChild 把自己删掉</p></blockquote></li></ol><h2 id="15-说说你对-BOM-的理解，常见的-BOM-对象你了解哪些？"><a href="#15-说说你对-BOM-的理解，常见的-BOM-对象你了解哪些？" class="headerlink" title="15. 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？"></a>15. 说说你对 BOM 的理解，常见的 BOM 对象你了解哪些？</h2><blockquote><p>BOM (Browser Object Model)，浏览器对象模型，提供了独立于内容与浏览器窗口进行交互的对象</p></blockquote><table><thead><tr><th align="center">DOM</th><th align="center">BOM</th><th align="center"></th></tr></thead><tbody><tr><td align="center">文档对象模型</td><td align="center">浏览器对象模型</td><td align="center"></td></tr><tr><td align="center">顶级对象 document</td><td align="center">顶级对象 window</td><td align="center"></td></tr><tr><td align="center">操作网页内容</td><td align="center">操作浏览器窗口</td><td align="center"></td></tr></tbody></table><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ol><li>窗口控制方法<ul><li>open() 打开新窗口</li><li>close() 关闭窗口</li><li>alert() 弹出警告框</li><li>confirm() 弹出确认框</li><li>prompt() 弹出提示框</li><li>print() 打印当前文档</li><li>moveTo() 移动窗口</li><li>resizeTo() 调整窗口大小</li><li>scrollBy() 按指定的像素数滚动内容</li><li>scrollTo() 滚动到指定的坐标</li></ul></li></ol><h3 id="location"><a href="#location" class="headerlink" title="location"></a>location</h3><blockquote><p>location 对象包含有关当前 URL 的信息</p></blockquote><p>location.reload()，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载</p><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><blockquote><p>navigator 对象主要用来获取浏览器的属性，区分浏览器类型。</p></blockquote><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><blockquote><p>保存的纯粹是客户端能力信息，也就是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度</p></blockquote><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 对象主要用来操作浏览器 URL 的历史记录，可以通过参数向前，向后，或者向指定 URL 跳转</p><ul><li>history.go():加载历史列表中的某个具体页面</li><li>history.forward()：向前跳转一个页面</li><li>history.back()：向后跳转一个页面</li><li>history.length：获取历史记录数</li></ul><h2 id="16-说说-JavaScript-中内存泄漏的几种情况？"><a href="#16-说说-JavaScript-中内存泄漏的几种情况？" class="headerlink" title="16. 说说 JavaScript 中内存泄漏的几种情况？"></a>16. 说说 JavaScript 中内存泄漏的几种情况？</h2><blockquote><p>由于疏忽或错误造成程序未能释放已经不再使用的内存</p></blockquote><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><blockquote><p>Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存</p></blockquote><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存</p><p>通常情况下有两种实现方式：</p><ol><li><p>标记清除</p><blockquote><p>当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“</p></blockquote></li><li><p>引用计数</p><blockquote><p>语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放</p></blockquote></li></ol><h3 id="常见内存泄露情况"><a href="#常见内存泄露情况" class="headerlink" title="常见内存泄露情况"></a>常见内存泄露情况</h3><ol><li>意外的全局变量</li><li>未清理的计时器或回调函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li>闭包</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>未清理的 DOM 引用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;element&#x27;</span>)<br>element.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-comment">// 事件监听addEventListener监听的时候</span><br>element.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="17-浏览器的存储方式有哪些"><a href="#17-浏览器的存储方式有哪些" class="headerlink" title="17. 浏览器的存储方式有哪些"></a>17. 浏览器的存储方式有哪些</h2><blockquote><p>cookies,localStorage,sessionStorage,indexedDB</p></blockquote><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><blockquote><p>服务器发送到用户浏览器并保存在本地的一小块数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie 有效期、安全性、使用范围的可选属性组成</p></blockquote><ol><li>特点： 小容量（通常限制在 4KB）、每个请求都会携带到服务器。</li><li>用途： 用于存储少量的文本数据，例如会话信息、用户偏好设置等。</li><li>生命周期： 可以设置失效时间，如果在浏览器没有设置失效时间，那么 cookie 将会在浏览器关闭时失效。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 document.cookie 进行读写。</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> =<br>  <span class="hljs-string">&#x27;username=John Doe; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>本地存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 除非被清除，否则永久保存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 localStorage 对象进行读写。</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p>会话存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 仅在当前会话下有效，关闭页面或浏览器后被清除。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 sessionStorage 对象进行读写。</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><blockquote><p>浏览器本地数据库</p></blockquote><ol><li>容量：相对较大，适用于存储大量结构化数据。</li><li>生命周期： 永久存储，不受会话影响。</li><li>用途： 用于存储大量结构化数据，例如浏览器端缓存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 indexedDB 对象进行读写。</span><br><span class="hljs-keyword">var</span> request = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;MyTestDatabase&#x27;</span>)<br>request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 错误处理逻辑</span><br>&#125;<br>request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span><br>  <span class="hljs-comment">// 成功处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="token-token-存储在哪里-token-怎么传递"><a href="#token-token-存储在哪里-token-怎么传递" class="headerlink" title="token,token 存储在哪里,token 怎么传递"></a>token,token 存储在哪里,token 怎么传递</h3><blockquote><p>Token（令牌）是在身份验证（Authentication）和授权（Authorization）过程中用于验证用户身份的一种方式。(访问资源对凭证)</p></blockquote><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ol><li>存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台</li><li>存储在 cookie 中，让它自动发送，不过缺点就是不能跨域</li><li>拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里面。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>用户登录： 用户提供用户名和密码进行登录。</li><li>认证服务器验证： 服务器验证用户提供的用户名和密码，如果验证通过，生成一个令牌。</li><li>令牌返回给客户端： 服务器将生成的令牌返回给客户端。</li><li>客户端存储令牌： 客户端通常将令牌存储在本地，如浏览器的 localStorage、sessionStorage 或者内存中。</li><li>后续请求携带令牌： 客户端在后续的请求中携带令牌，通常通过 HTTP 头部的 Authorization 字段或者其他方式。</li></ol><h2 id="18-说说你对函数式编程的理解？优缺点？"><a href="#18-说说你对函数式编程的理解？优缺点？" class="headerlink" title="18. 说说你对函数式编程的理解？优缺点？"></a>18. 说说你对函数式编程的理解？优缺点？</h2><blockquote><p>它由一个名称（Name）、一个值（Value）和其它几个用于控制 cookie 有效期、安全性、使用范围的可选属性组成</p></blockquote><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><blockquote><p>纯函数是对给定的输入返还相同输出的函数，并且要求你所有的数据都是不可变的，即纯函数&#x3D;无状态+数据不可变</p></blockquote><ol><li>特性：</li></ol><ul><li>函数内部传入指定的值，就会返回确定唯一的值</li><li>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数</li></ul><ol start="2"><li>优势：</li></ol><ul><li>使用纯函数，我们可以产生可测试的代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;double(2) 等于 4&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">4</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>不依赖外部环境计算，不会产生副作用，提高函数的复用性</li><li>可读性更强 ，函数不管是否是纯函数 都会有一个语义化的名称，更便于阅读</li><li>可以组装成复杂任务的可能性。符合模块化概念及单一职责原则</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li>优点</li></ol><ul><li>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li><li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</li><li>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</li><li>隐性好处。减少代码量，提高维护性</li></ul><ol start="2"><li>缺点：</li></ol><ul><li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</li><li>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</li><li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li></ul><h2 id="19-Javascript-中如何实现函数缓存？函数缓存有哪些应用场景？"><a href="#19-Javascript-中如何实现函数缓存？函数缓存有哪些应用场景？" class="headerlink" title="19. Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？"></a>19. Javascript 中如何实现函数缓存？函数缓存有哪些应用场景？</h2><ol><li>闭包</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">let</span> sum = b + a<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum) <span class="hljs-comment">// 3</span><br>  &#125;<br>  <span class="hljs-title function_">add</span>()<br>&#125;)()<br><span class="hljs-comment">//add函数本身，以及其内部可访问的变量，即 a = 1，这两个组合在⼀起就形成了闭包</span><br></code></pre></td></tr></table></figure><ol start="2"><li>柯里化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> add2 = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-comment">//**返回函数**</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) &#123;<br>    <span class="hljs-keyword">return</span> x + y<br>  &#125;<br>&#125;<br><span class="hljs-title function_">add2</span>(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>) <span class="hljs-comment">//7</span><br><span class="hljs-comment">// 将一个二元函数拆分成两个一元函数</span><br></code></pre></td></tr></table></figure><h2 id="20-说说-Javascript-数字精度丢失的问题，如何解决？"><a href="#20-说说-Javascript-数字精度丢失的问题，如何解决？" class="headerlink" title="20. 说说 Javascript 数字精度丢失的问题，如何解决？"></a>20. 说说 Javascript 数字精度丢失的问题，如何解决？</h2><blockquote><p><code>0.1 + 0.2 === 0.3 // false</code></p></blockquote><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><blockquote><p>在 JavaScript 中，Number 采用的是 IEEE754 规范中 64 位双精度浮点数编码</p></blockquote><p>64 位比特又可分为三个部分：</p><ol><li>符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数</li><li>指数位 E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为 1023</li><li>尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</li></ol><p><strong>为什么 0.1 +0.2&#x3D;&#x3D;&#x3D;0.30000000000000004:</strong></p><ol><li>0.1&gt;&gt;&gt;二进制&gt;&gt;&gt;科学记数法&gt;&gt;实际存储时的形式[64 位] 符号位+(指数位+指数偏移量)+小数部分) 即：<br>0.1 &gt;&gt;&gt; 0.0001 1001 1001 1001…（1001 无限循环）</li><li>同理，0.2<br>0.2&gt;&gt;二进制&gt;&gt;&gt;科学记数法&gt;&gt;实际存储时的形式<a href="%E7%AC%A6%E5%8F%B7%E4%BD%8D+%E6%8C%87%E6%95%B0%E4%BD%8D+%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86">64 位</a> 即<br>0.2 &gt;&gt;&gt; 0.0011 0011 0011 0011…（0011 无限循环）<br>可以看出来在转换为二进制时</li><li>将 0.1 和 0.2 的二进制形式按实际展开，末尾补零相加，结果如下<br>0.1+0.2 &gt;&gt; 0.0100 1100 1100 1100…（1100 无限循环）</li><li>因计算机存储位数的限制而截断的二进制数字，再转换为十进制，就成了 0.30000000000000004</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>toPrecision 特定方法返回四舍五入长度字符串</li><li>使用专门的库： 可以使用一些专门处理精度计算的库，如 BigNumber.js、decimal.js 等。这些库提供了更高精度的数字表示和计算功能，可以避免 JavaScript 原生的数字精度丢失问题。</li></ol><h2 id="21-防抖和节流"><a href="#21-防抖和节流" class="headerlink" title="21. 防抖和节流"></a>21. 防抖和节流</h2><p><strong>作用：</strong><br>控制事件触发频率的前端优化技术，用于提高性能和避免过度频繁的函数调用。</p><h3 id="防抖-Debouncing"><a href="#防抖-Debouncing" class="headerlink" title="防抖(Debouncing)"></a>防抖(Debouncing)</h3><blockquote><p>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timeout<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> =<span class="hljs-function">()=&gt;</span> &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timeout)<br>    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>      func.<span class="hljs-title function_">apply</span>(context, args)<br>    &#125;, wait)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> debouncedFunction = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要防抖的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Debounced function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, debouncedFunction)<br></code></pre></td></tr></table></figure><h3 id="节流-Throttling"><a href="#节流-Throttling" class="headerlink" title="节流(Throttling)"></a>节流(Throttling)</h3><blockquote><p>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      timer = <span class="hljs-literal">null</span><br>    &#125;, wait)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> throttledFunction = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要节流的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Throttled function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, throttledFunction)<br></code></pre></td></tr></table></figure><h2 id="22-如何判断一个元素是否在可视区域中？"><a href="#22-如何判断一个元素是否在可视区域中？" class="headerlink" title="22. 如何判断一个元素是否在可视区域中？"></a>22. 如何判断一个元素是否在可视区域中？</h2><ol><li>offsetTop、scrollTop、clientHeight、scrollHeight<blockquote><p>offsetTop:元素的上外边框至包含元素的上内边框之间的像素距离<br>scrollTop:滚动视窗的高度距离 window 顶部的距离，它会随着往上滚动而不断增加，初始值是 0，它是一个变化的值<br>clientHeight:元素的内部高度(content+padding)，以像素计<br>scrollHeight:元素的内容高度(content+padding+border)，以像素计</p></blockquote></li></ol><h2 id="23-如何实现上拉加载，下拉刷新？"><a href="#23-如何实现上拉加载，下拉刷新？" class="headerlink" title="23. 如何实现上拉加载，下拉刷新？"></a>23. 如何实现上拉加载，下拉刷新？</h2><blockquote><p>scrollTop：滚动视窗的高度距离 window 顶部的距离，它会随着往上滚动而不断增加，初始值是 0，它是一个变化的值<br>clientHeight:它是一个定值，表示屏幕可视区域的高度；<br>scrollHeight：页面不能滚动时也是存在的,此时 scrollHeight 等于 clientHeight。scrollHeight 表示 body 所有元素的总长度(包括 body 元素自身的 padding)<br>触底公式：<code>scrollTop + clientHeight &gt;= scrollHeight</code></p></blockquote><h2 id="24-什么是单点登录？如何实现？"><a href="#24-什么是单点登录？如何实现？" class="headerlink" title="24. 什么是单点登录？如何实现？"></a>24. 什么是单点登录？如何实现？</h2><blockquote><p>SSO 的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p></blockquote><h3 id="同域名下的单点登录"><a href="#同域名下的单点登录" class="headerlink" title="同域名下的单点登录"></a>同域名下的单点登录</h3><p>cookie 的 domain 属性设置为当前域的父域，并且父域的 cookie 会被子域所共享。path 属性默认为 web 应用的上下文路径</p><h3 id="不同域名下的单点登录"><a href="#不同域名下的单点登录" class="headerlink" title="不同域名下的单点登录"></a>不同域名下的单点登录</h3><ol><li><p>部署一个认证中心，用于专门处理登录请求的独立的 Web 服务<br>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个 Cookie 是认证中心的，应用系统是访问不到的）</p></li><li><p>可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端<br>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID（或 Token）放在响应体中传递给前端</p></li></ol><h2 id="25-web-常见的攻击方式有哪些？如何防御？"><a href="#25-web-常见的攻击方式有哪些？如何防御？" class="headerlink" title="25. web 常见的攻击方式有哪些？如何防御？"></a>25. web 常见的攻击方式有哪些？如何防御？</h2><h3 id="XSS-Cross-Site-Scripting-跨站脚本攻击"><a href="#XSS-Cross-Site-Scripting-跨站脚本攻击" class="headerlink" title="XSS (Cross Site Scripting) 跨站脚本攻击"></a>XSS (Cross Site Scripting) 跨站脚本攻击</h3><blockquote><p>XSS，跨站脚本攻击，允许攻击者将<code>恶意代码植入</code>到提供给其它<code>用户使用的页面</code>中</p></blockquote><ul><li>XSS 的攻击目标是为了<code>盗取存储在客户端的cookie</code>或者其他网站用于<code>识别客户端身份的敏感信息</code>。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互</li></ul><ol><li><p>存储型</p><ul><li>攻击者将恶意代码提交到目标网站的数据库中</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li><li><p>反射型</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li><li><p>DOM 型</p><ul><li>攻击者构造出特殊的 URL，其中包含恶意代码</li><li>用户打开带有恶意代码的 URL</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li></ul></li></ol><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><ol><li>攻击者提交而恶意代码(过滤掉用户输入的恶劣代码，然后提交给后端)</li></ol><h3 id="CSRF（Cross-site-request-forgery）跨站请求伪造"><a href="#CSRF（Cross-site-request-forgery）跨站请求伪造" class="headerlink" title="CSRF（Cross-site request forgery）跨站请求伪造"></a>CSRF（Cross-site request forgery）跨站请求伪造</h3><blockquote><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求<br>利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目</p></blockquote><p><strong>一个典型的 CSRF 攻击有着如下的流程：</strong></p><ol><li>受害者登录 a.com，并保留了登录凭证（Cookie）</li><li>攻击者引诱受害者访问了 b.com</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带 a.com 的 Cookie</li><li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li><li>a.com 以受害者的名义执行了 act&#x3D;xx</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作</li></ol><h3 id="CSRF-防御"><a href="#CSRF-防御" class="headerlink" title="CSRF 防御"></a>CSRF 防御</h3><ol><li><p>阻止不明外域的访问</p><ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li><p>提交时要求附加本域才能获取的信息</p><ul><li>CSRF Token</li><li>双重 Cookie 验证</li></ul></li></ol><h3 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h3>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6系列</title>
    <link href="/2024/02/22/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/ES6%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/22/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/ES6%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-ES6-系列"><a href="#🍭-ES6-系列" class="headerlink" title="🍭 ES6 系列"></a>🍭 ES6 系列</h1><h2 id="1-说说-var、let、const-之间的区别"><a href="#1-说说-var、let、const-之间的区别" class="headerlink" title="1. 说说 var、let、const 之间的区别"></a>1. 说说 var、let、const 之间的区别</h2><ol><li><p>var：<br>具有函数作用域。<br>会进行变量提升（hoisting）。<br>可以重复声明同名变量。<br>没有块级作用域，存在变量提升。</p></li><li><p>let：<br>具有块级作用域。<br>不会进行变量提升。<br>不允许重复声明同名变量。<br>存在“暂时性死区”。</p></li><li><p>const：<br>具有块级作用域。<br>不会进行变量提升。<br>不允许重复声明同名变量。<br>声明后不能再被赋值。</p></li></ol><h2 id="2-ES6-中数组新增了哪些扩展？"><a href="#2-ES6-中数组新增了哪些扩展？" class="headerlink" title="2. ES6 中数组新增了哪些扩展？"></a>2. ES6 中数组新增了哪些扩展？</h2><h3 id="1-扩展运算符的应用"><a href="#1-扩展运算符的应用" class="headerlink" title="1. 扩展运算符的应用"></a>1. 扩展运算符的应用</h3><blockquote><p>ES6 通过扩展元素符<code>...</code>，好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列</p></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>函数调用的时候，将一个数组变为参数序列</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">38</span>]<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 42</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>可以将某些数据结构转为数组<code>[...document.querySelectorAll(&#39;div&#39;)]</code></p></li><li><p>能够更简单实现数组复制<code>const [...a2] = a1;</code></p></li><li><p>数组的合并[…arr1, …arr2, …arr3]</p></li></ol><blockquote><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错</p></blockquote><h3 id="2-构造函数新增的方法"><a href="#2-构造函数新增的方法" class="headerlink" title="2. 构造函数新增的方法"></a>2. 构造函数新增的方法</h3><ol><li>Array.from()</li></ol><blockquote><p>将两类对象转为真正的数组：类似数组的对象和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<br>还可以接受第二个参数，用来对每个元素进行处理，将处理后的值放入返回的数组</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x)<br><span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure><ol start="2"><li>Array.of()</li></ol><ul><li>没有参数的时候，返回一个空数组<br><code>Array() // []</code></li><li>当参数只有一个的时候，实际上是指定数组的长度<br><code>Array(3) // [, , ,]</code></li><li>参数个数不少于 2 个时，Array()才会返回由参数组成的新数组<br><code>Array.of(3, 11, 8) // [3,11,8]</code></li></ul><h3 id="3-实例对象新增的方法"><a href="#3-实例对象新增的方法" class="headerlink" title="3. 实例对象新增的方法"></a>3. 实例对象新增的方法</h3><p>关于数组实例对象新增的方法有如下：</p><p>copyWithin()<br>find()、findIndex()<br>fill()<br>entries()，keys()，values()<br>includes()<br>flat()，flatMap()</p><h3 id="4-数组的空位"><a href="#4-数组的空位" class="headerlink" title="4. 数组的空位"></a>4. 数组的空位</h3><blockquote><p>数组的空位指，数组的某一个位置没有任何值</p></blockquote><p>ES6 则是明确将空位转为 undefined</p><h3 id="5-排序稳定性"><a href="#5-排序稳定性" class="headerlink" title="5. 排序稳定性"></a>5. 排序稳定性</h3><blockquote><p>将 sort()默认设置为稳定的排序算法</p></blockquote><h2 id="3-对象新增了哪些扩展？"><a href="#3-对象新增了哪些扩展？" class="headerlink" title="3. 对象新增了哪些扩展？"></a>3. 对象新增了哪些扩展？</h2><h3 id="1-属性的简写"><a href="#1-属性的简写" class="headerlink" title="1. 属性的简写"></a>1. 属性的简写</h3><ol><li><p>ES6 中，当对象键名与对应值名相等的时候，可以进行简写<br><code>const baz = &#123;foo&#125;</code></p></li><li><p>方法也能够进行简写</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello!&#x27;</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><br><span class="hljs-keyword">const</span> o = &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello!&#x27;</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：简写的对象方法不能用作构造函数，否则会报错</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">f</span>() <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h3 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h3><blockquote><p>ES6 允许字面量定义对象时，将表达式放在括号内</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> lastWord = <span class="hljs-string">&#x27;last word&#x27;</span><br><br><span class="hljs-keyword">const</span> a = &#123;<br>  <span class="hljs-string">&#x27;first word&#x27;</span>: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  [lastWord]: <span class="hljs-string">&#x27;world&#x27;</span>,<br>&#125;<br><br>a[<span class="hljs-string">&#x27;first word&#x27;</span>] <span class="hljs-comment">// &quot;hello&quot;</span><br>a[lastWord] <span class="hljs-comment">// &quot;world&quot;</span><br>a[<span class="hljs-string">&#x27;last word&#x27;</span>] <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&gt;表达式还可以用于定义方法名<br><br><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-string">&#x27;h&#x27;</span> + <span class="hljs-string">&#x27;ello&#x27;</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">hello</span>() <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><h3 id="3-super-关键字"><a href="#3-super-关键字" class="headerlink" title="3. super 关键字"></a>3. super 关键字</h3><blockquote><p>指向当前对象的原型对象</p></blockquote><h3 id="4-扩展运算符的应用"><a href="#4-扩展运算符的应用" class="headerlink" title="4. 扩展运算符的应用"></a>4. 扩展运算符的应用</h3><ol><li>在解构赋值中，未被读取的可遍历的属性，分配到指定的对象上面</li></ol><p><code>let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</code></p><ol start="2"><li>解构赋值是浅拷贝</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;<br><span class="hljs-keyword">let</span> &#123; ...x &#125; = obj<br></code></pre></td></tr></table></figure><h3 id="5-属性的遍历"><a href="#5-属性的遍历" class="headerlink" title="5. 属性的遍历"></a>5. 属性的遍历</h3><ol><li>for…in</li><li>Object.keys(obj)：返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li><li>Object.getOwnPropertyNames(obj)：返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li><li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名</li><li>Reflect.ownKeys(obj)：返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li></ol><h3 id="6-对象新增的方法"><a href="#6-对象新增的方法" class="headerlink" title="6. 对象新增的方法"></a>6. 对象新增的方法</h3><p>Object.is()<br>Object.assign()<br>Object.getOwnPropertyDescriptors()<br>Object.setPrototypeOf()，Object.getPrototypeOf()<br>Object.keys()，Object.values()，Object.entries()<br>Object.fromEntries()</p><h2 id="4-对函数增了哪些扩展"><a href="#4-对函数增了哪些扩展" class="headerlink" title="4. 对函数增了哪些扩展"></a>4. 对函数增了哪些扩展</h2><h3 id="1-函数参数默认值"><a href="#1-函数参数默认值" class="headerlink" title="1. 函数参数默认值"></a>1. 函数参数默认值</h3><h3 id="2-属性"><a href="#2-属性" class="headerlink" title="2. 属性"></a>2. 属性</h3><ol><li>函数的 length 属性<code>length将返回没有指定默认值的参数个数</code></li><li>name 属性<code>返回该函数的函数名</code></li><li>作用域<br>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域<br>等到初始化结束，这个作用域就会消失</li><li>严格模式<br>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式<code>&#39;use strict&#39;;</code>，否则会报错</li><li>箭头函数</li></ol><h2 id="5-你是怎么理解-ES6-中-Promise-的？使用场景？"><a href="#5-你是怎么理解-ES6-中-Promise-的？使用场景？" class="headerlink" title="5. 你是怎么理解 ES6 中 Promise 的？使用场景？"></a>5. 你是怎么理解 ES6 中 Promise 的？使用场景？</h2><blockquote><p>Promise 是异步编程的一种解决方案,解决了回调地狱的问题</p></blockquote><h3 id="Promise-的基本特性"><a href="#Promise-的基本特性" class="headerlink" title="Promise 的基本特性"></a>Promise 的基本特性</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><ol><li>pending（进行中）</li><li>fulfilled（已成功）</li><li>rejected（已失败）</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变（从 pending 变为 fulfilled 和从 pending 变为 rejected），就不会再变，任何时候都可以得到这个结果</li></ol><h3 id="Promise-的基本用法"><a href="#Promise-的基本用法" class="headerlink" title="Promise 的基本用法"></a>Promise 的基本用法</h3><p><code>const promise = new Promise(function(resolve, reject) &#123;&#125;);</code></p><blockquote><p>Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject<br>resolve 函数的作用是，将 Promise 对象的状态从“未完成”变为“成功”<br>reject 函数的作用是，将 Promise 对象的状态从“未完成”变为“失败</p></blockquote><h4 id="Promise-实例方法"><a href="#Promise-实例方法" class="headerlink" title="Promise 实例方法"></a>Promise 实例方法</h4><ol><li><p>then()<br>then 是实例状态发生改变时的回调函数，第一个参数是 resolved 状态的回调函数，第二个参数是 rejected 状态的回调函数</p></li><li><p>catch()<br>catch 是 then(null, rejection)的别名，用于指定发生错误时的回调函数</p></li><li><p>finally()<br>不管 Promise 对象最后状态如何，都会执行的操作</p></li></ol><h4 id="Promise-类-构造函数-方法"><a href="#Promise-类-构造函数-方法" class="headerlink" title="Promise 类(构造函数)方法"></a>Promise 类(构造函数)方法</h4><ol><li>Promise.all()<br>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例<br><code>const p = Promise.all([p1, p2, p3]);</code></li></ol><p>实例 p 的状态由 p1、p2、p3 决定，分为两种：</p><ul><li>只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数</li><li>只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数</li></ul><ol start="2"><li>Promise.race()<br>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</li></ol><p>只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变<br>率先改变的 Promise 实例的返回值则传递给 p 的回调函数</p><ol start="3"><li>allSettled()<blockquote><p>Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例</p></blockquote></li></ol><p>只有等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束</p><ol start="4"><li><p>resolve()</p><blockquote><p>Promise.resolve()方法将现有对象转为 Promise 对象</p></blockquote></li><li><p>reject()</p><blockquote><p>Promise.reject()方法也会返回一个新的 Promise 实例，该实例的状态为 rejected</p></blockquote></li></ol><h2 id="6-你是怎么理解-ES6-中-Generator-的？使用场景？"><a href="#6-你是怎么理解-ES6-中-Generator-的？使用场景？" class="headerlink" title="6. 你是怎么理解 ES6 中 Generator 的？使用场景？"></a>6. 你是怎么理解 ES6 中 Generator 的？使用场景？</h2><blockquote><p>Generator 函数是 ES6 提供的一种异步编程解决方案<br>function 关键字与函数名之间有一个星号<code>function* helloWorldGenerator()&#123;&#125; 函数体内部使用 yield 表达式，定义不同的内部状态</code>yield ‘hello’;&#96;</p></blockquote><h3 id="Generator-函数使用"><a href="#Generator-函数使用" class="headerlink" title="Generator 函数使用"></a>Generator 函数使用</h3><p>Generator 函数会<code>返回一个遍历器对象</code>，即具有<code>Symbol.iterator</code>属性，并且返回给自己<br>通过<code>yield关键字可以暂停</code>generator 函数返回的遍历器对象的状态<br>通过<code>next方法</code>才会遍历到下一个内部状态，其运行逻辑如下：</p><h2 id="7-你是怎么理解-ES6-中-Proxy-的？使用场景"><a href="#7-你是怎么理解-ES6-中-Proxy-的？使用场景" class="headerlink" title="7. 你是怎么理解 ES6 中 Proxy 的？使用场景?"></a>7. 你是怎么理解 ES6 中 Proxy 的？使用场景?</h2><blockquote><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p></blockquote><h3 id="Proxy-的基本用法"><a href="#Proxy-的基本用法" class="headerlink" title="Proxy 的基本用法"></a>Proxy 的基本用法</h3><p><code>var proxy = new Proxy(target, handler)</code></p><ul><li>target 表示所要拦截的目标对象（任何类型的对象，包括原生数组，函数，甚至另一个代理））</li><li>handler 通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为</li></ul><ol><li>handler 拦截器<br>属性：get、set、apply、construct、has、deleteProperty、ownKeys、getOwnPropertyDescriptor、defineProperty、preventExtensions、getPrototypeOf、setPrototypeOf、isExtensible、enumerate、ownKeys、apply、construct</li><li>Reflect<br>若需要在 Proxy 内部调用对象的默认行为，建议使用 Reflect，其是 ES6 中操作对象而提供的新 API</li><li>get<blockquote><p>get 接受三个参数，依次为目标对象、属性名和 proxy 实例本身，最后一个参数可选</p></blockquote></li><li>set<blockquote><p>set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 proxy 实例本身，最后一个参数可选</p></blockquote></li><li>Proxy.revocable(target, handler);<blockquote><p>返回一个可取消的 Proxy 实例</p></blockquote></li></ol><h2 id="8-你是怎么理解-ES6-中-Module-的？使用场景？"><a href="#8-你是怎么理解-ES6-中-Module-的？使用场景？" class="headerlink" title="8. 你是怎么理解 ES6 中 Module 的？使用场景？"></a>8. 你是怎么理解 ES6 中 Module 的？使用场景？</h2><blockquote><p>模块，（Module），是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。</p></blockquote><h3 id="Module-的基本特性"><a href="#Module-的基本特性" class="headerlink" title="Module 的基本特性"></a>Module 的基本特性</h3><ul><li>代码抽象</li><li>代码封装</li><li>代码复用</li><li>依赖管理</li></ul><h3 id="Module-的基本用法"><a href="#Module-的基本用法" class="headerlink" title="Module 的基本用法"></a>Module 的基本用法</h3><blockquote><p>ES6 模块内部自动采用了严格模式，这里就不展开严格模式的限制，毕竟这是 ES5 之前就已经规定好<br>模块功能主要由两个命令构成：</p></blockquote><ul><li>export：用于规定模块的对外接口</li><li>import：用于输入其他模块提供的功能</li></ul><h2 id="9-你是怎么理解-ES6-中-Decorator-的？使用场景？"><a href="#9-你是怎么理解-ES6-中-Decorator-的？使用场景？" class="headerlink" title="9. 你是怎么理解 ES6 中 Decorator 的？使用场景？"></a>9. 你是怎么理解 ES6 中 Decorator 的？使用场景？</h2>]]></content>
    
    
    
    <tags>
      
      <tag>ES6系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VUE3系列</title>
    <link href="/2024/02/22/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/VUE3%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/22/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/VUE3%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-Vue3-系列"><a href="#🍭-Vue3-系列" class="headerlink" title="🍭 Vue3 系列"></a>🍭 Vue3 系列</h1><h2 id="1-Vue3-0-的设计目标是什么？做了哪些优化"><a href="#1-Vue3-0-的设计目标是什么？做了哪些优化" class="headerlink" title="1. Vue3.0 的设计目标是什么？做了哪些优化"></a>1. Vue3.0 的设计目标是什么？做了哪些优化</h2><h3 id="优化方面"><a href="#优化方面" class="headerlink" title="优化方面"></a>优化方面</h3><ul><li>更小</li><li>更快</li><li>TypeScript 支持</li><li>API 设计一致性</li><li>提高自身可维护性</li><li>开放更多底层功能</li></ul><h4 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h4><blockquote><p>Vue3 移除一些不常用的 API,引入 tree-shaking，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p></blockquote><h4 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h4><p>主要体现在编译方面：</p><ol><li>diff 算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR 优化</li></ol><h4 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h4><blockquote><p>vue3 在兼顾 vue2 的 options API 的同时还推出了 composition API，大大增加了代码的逻辑组织和代码复用能力</p></blockquote><h3 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h3><h4 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h4><ul><li><p>源码管理<br>vue3 整个源码是通过 monorepo 的方式维护的，根据功能将不同的模块拆分到 packages 目录下面不同的子目录中</p></li><li><p>TypeScript<br>Vue3 是基于 typeScript 编写的，提供了更好的类型检查，能支持复杂的类型推导</p></li></ul><h4 id="2-性能"><a href="#2-性能" class="headerlink" title="2. 性能"></a>2. 性能</h4><ul><li>体积优化</li><li>编译优化</li><li>数据劫持优化<br>在 vue2 中，数据劫持是通过 Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除，vue3 中使用 Proxy API 替代了 defineProperty API</li></ul><h4 id="3-API"><a href="#3-API" class="headerlink" title="3. API"></a>3. API</h4><p>其两大显著的优化：<br>composition API 和 setup 函数</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><h2 id="2-Vue3-0-性能提升主要是通过哪几方面体现的？"><a href="#2-Vue3-0-性能提升主要是通过哪几方面体现的？" class="headerlink" title="2. Vue3.0 性能提升主要是通过哪几方面体现的？"></a>2. Vue3.0 性能提升主要是通过哪几方面体现的？</h2><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1. 编译阶段"></a>1. 编译阶段</h3><blockquote><p>Vue2，每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据 property 记录为依赖，当依赖发生改变，触发 setter，则会通知 watcher，从而使关联的组件重新渲染</p></blockquote><p>Vue3 在编译阶段，做了进一步优化。主要有如下：</p><ul><li><p>diff 算法优化</p><blockquote><p>vue3 在 diff 算法中相比 vue2 增加了静态标记</p></blockquote><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个 flag 标记，下次发生变化的时候直接找该地方进行比较</p></li><li><p>静态提升</p><blockquote><p>Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p></blockquote><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用<br><code>const _hoisted_1 = /*#__PURE__*/_createVNode(&quot;span&quot;, null, &quot;你好&quot;, -1 /* HOISTED */)</code></p></li><li><p>事件监听缓存</p><blockquote><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p></blockquote></li><li><p>SSR 优化</p><blockquote><p>当静态内容大到一定量级时候，会用 createStaticVNode 方法在客户端去生成一个 static node，这些静态 node，会被直接 innerHtml，就不需要创建对象，然后根据对象渲染</p></blockquote></li></ul><h3 id="2-源码体积"><a href="#2-源码体积" class="headerlink" title="2. 源码体积"></a>2. 源码体积</h3><blockquote><p>相比 Vue2，Vue3 整体体积变小了，除了移出一些不常用的 API，再重要的是 Tree shanking</p></blockquote><p>任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><h3 id="3-响应式系统"><a href="#3-响应式系统" class="headerlink" title="3. 响应式系统"></a>3. 响应式系统</h3><ol><li><p>vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式</p></li><li><p>vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历</p></li></ol><ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组 length 属性</li><li>可以监听删除属性</li></ul><h2 id="3-Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API-？"><a href="#3-Vue3-0-里为什么要用-Proxy-API-替代-defineProperty-API-？" class="headerlink" title="3. Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？"></a>3. Vue3.0 里为什么要用 Proxy API 替代 defineProperty API ？</h2><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote><p>定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p></blockquote><h4 id="实现响应式"><a href="#实现响应式" class="headerlink" title="实现响应式"></a>实现响应式</h4><ol><li><p>get<br>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的 this 并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p></li><li><p>set<br>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) &#123;<br>  app.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">foo</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) &#123;<br>  <span class="hljs-comment">//如果存在嵌套对象的情况，还需要在defineReactive中进行递归</span><br>  <span class="hljs-title function_">observe</span>(val)<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`get <span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;val&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> val<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>) &#123;<br>      <span class="hljs-keyword">if</span> (newVal !== val) &#123;<br>        <span class="hljs-comment">//当给key赋值为对象的时候，还需要在set属性中进行递归</span><br>        <span class="hljs-title function_">observe</span>(newVal)<br>        val = newVal<br>        <span class="hljs-title function_">update</span>()<br>      &#125;<br>    &#125;,<br>  &#125;)<br>&#125;<br><span class="hljs-comment">//在对象存在多个key情况下，需要进行遍历</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> || obj == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">defineReactive</span>(obj, key, obj[key])<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>缺点</strong>：</p><ol><li>检测不到对象属性的添加和删除</li><li>数组 API 方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ol><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>Proxy 的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>  <span class="hljs-comment">// Proxy相当于在对象外层加拦截</span><br>  <span class="hljs-keyword">const</span> observed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`获取<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;res&#125;</span>`</span>)<br>      <span class="hljs-comment">// return res</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">isObject</span>(res) ? <span class="hljs-title function_">reactive</span>(res) : res<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`设置<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;value&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) &#123;<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`删除<span class="hljs-subst">$&#123;key&#125;</span>:<span class="hljs-subst">$&#123;res&#125;</span>`</span>)<br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>  &#125;)<br>  <span class="hljs-keyword">return</span> observed<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？"><a href="#4-Vue3-0-所采用的-Composition-Api-与-Vue2-x-使用的-Options-Api-有什么不同？" class="headerlink" title="4. Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？"></a>4. Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</h2><h3 id="Options-Api"><a href="#Options-Api" class="headerlink" title="Options Api"></a>Options Api</h3><blockquote><p>Options API，即大家常说的选项 API，即以 vue 为后缀的文件，通过定义 methods，computed，watch，data 等属性与方法，共同处理页面逻辑</p></blockquote><p><strong>缺点</strong>：</p><ol><li>当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</li></ol><h3 id="Composition-Api"><a href="#Composition-Api" class="headerlink" title="Composition Api"></a>Composition Api</h3><blockquote><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p></blockquote><p><strong>优点</strong>：</p><ol><li>在逻辑组织和逻辑复用方面，Composition API 是优于 Options API</li><li>因为 Composition API 几乎是函数，会有更好的类型推断。</li><li>Composition API 对 tree-shaking 友好，代码也更容易压缩</li><li>Composition API 中见不到 this 的使用，减少了 this 指向不明的情况</li></ol><h2 id="5-说说-Vue-3-0-中-Treeshaking-特性？举例说明一下？"><a href="#5-说说-Vue-3-0-中-Treeshaking-特性？举例说明一下？" class="headerlink" title="5. 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？"></a>5. 说说 Vue 3.0 中 Treeshaking 特性？举例说明一下？</h2><blockquote><p>Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination<br>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p></blockquote><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><blockquote><p>Tree shaking 是基于 ES6 模板语法（import 与 exports），主要是借助 ES6 模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p></blockquote><p><strong>Tree shaking 无非就是做了两件事：</strong></p><ol><li>编译阶段利用 ES6 Module 判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ol><h3 id="通过-Tree-shaking，Vue3-给我们带来的好处是："><a href="#通过-Tree-shaking，Vue3-给我们带来的好处是：" class="headerlink" title="通过 Tree shaking，Vue3 给我们带来的好处是："></a>通过 Tree shaking，Vue3 给我们带来的好处是：</h3><ol><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ol><h2 id="6-用-Vue3-0-写过组件吗？如果想实现一个-Modal-你会怎么设计？"><a href="#6-用-Vue3-0-写过组件吗？如果想实现一个-Modal-你会怎么设计？" class="headerlink" title="6. 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？"></a>6. 用 Vue3.0 写过组件吗？如果想实现一个 Modal 你会怎么设计？</h2><h3 id="实现一个-Modal-组件，首先确定需要完成的内容："><a href="#实现一个-Modal-组件，首先确定需要完成的内容：" class="headerlink" title="实现一个 Modal 组件，首先确定需要完成的内容："></a>实现一个 Modal 组件，首先确定需要完成的内容：</h3><ul><li>遮罩层</li><li>标题内容</li><li>主体内容</li><li>确定和取消按钮</li></ul><p>主体内容需要灵活，所以可以是字符串，也可以是一段 html 代码<br>特点是它们在当前 vue 实例之外独立存在，通常挂载于 body 之上<br>除了通过引入 import 的形式，我们还可通过 API 的形式进行组件的调用<br>还可以包括配置全局样式、国际化、与 typeScript 结合</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><blockquote><p>Modal组件相关的目录结构</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">├── plugins<br>│   └── modal<br>│       ├── <span class="hljs-title class_">Content</span>.<span class="hljs-property">tsx</span> <span class="hljs-comment">// 维护 Modal 的内容，用于 h 函数和 jsx 语法</span><br>│       ├── <span class="hljs-title class_">Modal</span>.<span class="hljs-property">vue</span> <span class="hljs-comment">// 基础组件</span><br>│       ├── config.<span class="hljs-property">ts</span> <span class="hljs-comment">// 全局默认配置</span><br>│       ├── index.<span class="hljs-property">ts</span> <span class="hljs-comment">// 入口</span><br>│       ├── locale <span class="hljs-comment">// 国际化相关</span><br>│       │   ├── index.<span class="hljs-property">ts</span><br>│       │   └── lang<br>│       │       ├── en-<span class="hljs-variable constant_">US</span>.<span class="hljs-property">ts</span><br>│       │       ├── zh-<span class="hljs-variable constant_">CN</span>.<span class="hljs-property">ts</span><br>│       │       └── zh-<span class="hljs-variable constant_">TW</span>.<span class="hljs-property">ts</span><br>│       └── modal.<span class="hljs-property">type</span>.<span class="hljs-property">ts</span> <span class="hljs-comment">// ts类型声明相关</span><br><span class="hljs-comment">// 因为 Modal 会被 app.use(Modal) 调用作为一个插件，所以都放在plugins目录下</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>VUE3系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue系列</title>
    <link href="/2024/02/17/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Vue%E7%B3%BB%E5%88%97/"/>
    <url>/2024/02/17/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Vue%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-Vue-系列"><a href="#🍭-Vue-系列" class="headerlink" title="🍭 Vue 系列"></a>🍭 Vue 系列</h1><h2 id="1-什么是-Vue"><a href="#1-什么是-Vue" class="headerlink" title="1. 什么是 Vue"></a>1. 什么是 Vue</h2><blockquote><p>Vue.js 是一个用于创建用户界面的开源 JavaScript 框架，也是一个创建单页应用的 Web 应用框架.</p></blockquote><h3 id="Vue-特点"><a href="#Vue-特点" class="headerlink" title="Vue 特点"></a>Vue 特点</h3><ol><li><p><strong>数据驱动&#x2F;响应式数据绑定，双向数据绑定</strong></p><ol><li>它采用了 MVVM （Model-View-ViewModel）的架构模式，将数据模型（Model）与视图（View）进行关联，并通过 ViewModel 来管理这种关联。<br><br>当数据发生变化时，Vue.js 将负责更新视图，从而实现了数据驱动视图的更新<br><br>这使得开发者可以专注于数据逻辑，而不必直接操作 DOM。<br>通过双向数据绑定，Vue.js 不仅可以将数据变化反映到视图上，还可以将视图中用户的操作反馈到数据模型中，使得数据模型与视图之间可以双向同步。</li></ol></li><li><p><strong>组件化</strong></p><blockquote><p>Vue 允许将页面拆分成独立的组件(在 Vue 中每一个.vue 文件都可以视为一个组件)，每个组件有自己的逻辑、模板和样式，提高了代码的可维护性和复用性。</p></blockquote></li><li><p><strong>指令系统</strong></p><blockquote><p>指令 (Directives) Vue 提供了丰富的指令来操作 DOM，例如 v-if、v-for、v-bind 等，使得开发者能够简洁地处理 DOM 元素的显示和隐藏、循环渲染、属性绑定等操作</p></blockquote></li><li><p><strong>虚拟 DOM</strong></p><blockquote><p>Vue 使用虚拟 DOM 来高效地渲染页面，通过比较虚拟 DOM 和真实 DOM 的差异，最小化了 DOM 操作，提升了性能。</p></blockquote></li><li><p><strong>生命周期钩子</strong></p><blockquote><p>Vue 组件具有多个生命周期钩子，例如 created、mounted、updated、destroyed 等，在不同阶段执行相应的逻辑，方便开发者进行资源的初始化和清理。</p></blockquote></li></ol><h2 id="2-SPA-单页应用-single-page-application"><a href="#2-SPA-单页应用-single-page-application" class="headerlink" title="2. SPA 单页应用(single-page application)"></a>2. SPA 单页应用(single-page application)</h2><blockquote><p>基于 Web 的应用程序架构模式，它通过动态地更新当前页面而不是加载整个新页面来实现用户与应用程序的交互.所有必要的代码（HTML、JavaScript 和 CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载整个页面。</p></blockquote><h3 id="SPA-优点-x2F-缺点"><a href="#SPA-优点-x2F-缺点" class="headerlink" title="SPA 优点&#x2F;缺点"></a>SPA 优点&#x2F;缺点</h3><ol><li><p>优点：</p><ol><li>良好的用户体验：SPA 提供了更加流畅、快速的用户体验，因为页面切换时不需要重新加载整个页面，只需要更新部分内容。</li><li>前后端分离：SPA 的前端和后端可以完全分离，前端负责 UI 和交互逻辑，后端负责数据处理和业务逻辑，使得团队可以更好地分工合作。</li><li>减少服务器负担：由于页面不需要每次都从服务器重新加载，因此可以减少服务器的负担，降低网络流量。</li><li>更好的代码组织：SPA 通常采用模块化的开发方式，使得代码更易于维护和管理。</li></ol></li><li><p>缺点：</p><ol><li>首次加载慢：由于初始页面需要加载所有必要资源，因此首次加载可能会比较慢，尤其是对于较大型的应用程序。</li><li>SEO 难度较大：由于大部分内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地解析和索引页面内容，影响 SEO。</li><li>内存占用较高：由于页面不会重新加载，因此可能会导致内存占用较高，尤其是在长时间使用应用程序后。</li></ol></li></ol><h3 id="SPA-的原理和实现"><a href="#SPA-的原理和实现" class="headerlink" title="SPA 的原理和实现"></a>SPA 的原理和实现</h3><ol><li><p>原理：</p><ol><li>通过监听 URL 的变化，使用 History API 或者 hashchange 事件，来实现页面的切换。</li><li>通过 Ajax 请求获取数据，然后使用 JavaScript 更新页面内容。</li></ol></li><li><p>实现：</p></li></ol><ol><li><p>hash 模式：通过监听 hashchange 事件，来实现页面的切换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义 Router</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125; <span class="hljs-comment">// 存放路由path及callback</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentUrl</span> = <span class="hljs-string">&#x27;&#x27;</span><br><br>    <span class="hljs-comment">// 监听路由change调用相对应的路由回调</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>, <span class="hljs-literal">false</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback<br>  &#125;<br><br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">path</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]()<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 router</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">miniRouter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>()<br>miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page1&#x27;</span>))<br>miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page2&#x27;</span>))<br><br>miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment">// page1</span><br>miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>) <span class="hljs-comment">// page2</span><br></code></pre></td></tr></table></figure></li><li><p>history 模式：通过监听 popstate 事件，来实现页面的切换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义 Router</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = &#123;&#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listerPopState</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">init</span>(<span class="hljs-params">path</span>) &#123;<br>    history.<span class="hljs-title function_">replaceState</span>(&#123; <span class="hljs-attr">path</span>: path &#125;, <span class="hljs-literal">null</span>, path)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]()<br>  &#125;<br><br>  <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback<br>  &#125;<br><br>  <span class="hljs-title function_">push</span>(<span class="hljs-params">path</span>) &#123;<br>    history.<span class="hljs-title function_">pushState</span>(&#123; <span class="hljs-attr">path</span>: path &#125;, <span class="hljs-literal">null</span>, path)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]()<br>  &#125;<br><br>  <span class="hljs-title function_">listerPopState</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> path = e.<span class="hljs-property">state</span> &amp;&amp; e.<span class="hljs-property">state</span>.<span class="hljs-property">path</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">routers</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routers</span>[path]()<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用 Router</span><br><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">miniRouter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>()<br>miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page1&#x27;</span>))<br>miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page2&#x27;</span>))<br><br><span class="hljs-comment">// 跳转</span><br>miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>) <span class="hljs-comment">// page2</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="3-v-if-和-v-show-区别"><a href="#3-v-if-和-v-show-区别" class="headerlink" title="3. v-if 和 v-show 区别"></a>3. v-if 和 v-show 区别</h2><h3 id="共同点：控制元素在页面是否显示"><a href="#共同点：控制元素在页面是否显示" class="headerlink" title="共同点：控制元素在页面是否显示"></a>共同点：控制元素在页面是否显示</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li><p>控制和编译：<br><br>v-show 只是简单的基于 css 切换、隐藏则是为该元素添加 css–display:none，dom 元素依旧还在。<br><br>v-if 显示隐藏是将 dom 元素整个添加或删除，v-if 切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</p></li><li><p>生命周期：<br><br>v-show 由 false 变为 true 的时候不会触发组件的生命周期<br><br>v-if 由 false 变为 true 的时候，触发组件的 beforeCreate、create、beforeMount、mounted 钩子，由 true 变为 false 的时候触发组件的 beforeDestory、destoryed 方法</p></li><li><p>性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗；</p></li></ol><h2 id="4-Vue-实例挂载的过程"><a href="#4-Vue-实例挂载的过程" class="headerlink" title="4. Vue 实例挂载的过程"></a>4. Vue 实例挂载的过程</h2><ol><li>new Vue 的时候调用会调用_init 方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Vue</span>(<span class="hljs-params">options</span>) &#123;<br>  <span class="hljs-keyword">if</span> (process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vue</span>)) &#123;<br>    <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_init</span>(options)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>首先可以看 initMixin 方法，发现该方法在 Vue 原型上定义了_init 方法</p></blockquote><p>在 init() 中 会通过 callHook(vm,beforeCreate) 来执行 beforeCreate 生命周期函数然后通过 initState（vm） 初始化 props 、 methods 、data<br>接着会通过 callHook(vm, ‘created’) 来执行 created 生命周期函数 最后通过 vm.$mount(vm.$options.el) 来挂载元素</p><blockquote><p>在 initState 中会先通过 initProps 、 initMethods 、 initData 先后分别来初始化 相关数据 在这里会 初始化组件的 watcher 列表</p></blockquote><blockquote><p>initData 中会通过 observe(data, true) 来劫持 data 的所有属性，如果监听到数据变化就通知订阅者 watcher 来更新数据，以此来实现数据双向绑定 ，这就是 vue 实现数据响应式的 发布订阅者模式</p></blockquote><p>初始化 data 数据的时候 会校验 props 中变量名称和 data 中的不能重复，在这里会通过 observe 劫持 data 的所有属性，如果监听到数据变化就通知订阅者 watcher 来更新数据，以此来实现数据双向绑定 ，这就是 vue 实现数据响应式的 发布订阅者模式</p><ul><li>定义 $set、$get 、$delete、$watch 等方法</li><li>定义 $on、$off、$emit、$off 等事件</li><li>定义 _update、$forceUpdate、$destroy 生命周期</li></ul><ol start="2"><li><p>调用$mount 进行页面的挂载<br><br> 在调用vm.$mount 方法时 会将 template 解析为 抽象语法树 (ast tree) 再将抽象语法树 转换成 render 语法字符串 最终生成 render 方法 挂载到 vm 上后，会再次调用 mount 方法</p></li><li><p>挂载的时候主要是通过 mountComponent 方法<br><br>此时会触发 beforeMount 钩子函数 ，定义 updateComponent 来渲染页面视图的方法，监听组件数据，一旦发生变化，触发 beforeUpdate 生命钩子 最后执行 callHook(vm, ‘mounted’) 钩子函数 完成挂载</p></li><li><p>定义 updateComponent 更新函数<br><br>updateComponent 方法主要执行在 vue 初始化时声明的 render，update 方法</p></li><li><p>执行 render 生成虚拟 DOM</p></li><li><p>_update 将虚拟 DOM 生成真实 DOM 结构，并且渲染到页面中</p></li></ol><h2 id="5-请描述下你对-vue-生命周期的理解"><a href="#5-请描述下你对-vue-生命周期的理解" class="headerlink" title="5. 请描述下你对 vue 生命周期的理解"></a>5. 请描述下你对 vue 生命周期的理解</h2><blockquote><p>Vue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期(activated:keep-alive 缓存的组件激活时<br>deactivated:keep-alive 缓存的组件停用时调用)</p><img src="/2024/02/17/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/Vue%E7%B3%BB%E5%88%97/lifecycle.png" class></blockquote><ol><li>beforeCreate -&gt; created<br>初始化 vue 实例，进行数据观测</li><li>created<br>完成数据观测，属性与方法的运算，watch、event 事件回调的配置<br>可调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 dom，可通过 computed 和 watch 完成数据计算<br>此时 vm.$el 并没有被创建</li><li>created -&gt; beforeMount<br>判断是否存在 el 选项，若不存在则停止编译，直到调用 vm.$mount(el)才会继续编译<br>优先级：render &gt; template &gt; outerHTML<br>vm.el 获取到的是挂载 DOM 的</li><li>beforeMount<br>在此阶段可获取到 vm.el<br>此阶段 vm.el 虽已完成 DOM 初始化，但并未挂载在 el 选项上</li><li>beforeMount -&gt; mounted<br>此阶段 vm.el 完成挂载，vm.$el 生成的 DOM 替换了 el 选项所对应的 DOM</li><li>mounted<br>vm.el 已完成 DOM 的挂载与渲染，此刻打印 vm.$el，发现之前的挂载点及内容已被替换成新的 DOM</li><li>beforeUpdate<br>更新的数据必须是被渲染在模板上的（el、template、render 之一）<br>此时 view 层还未更新<br>若在 beforeUpdate 中再次修改数据，不会再次触发更新方法</li><li>updated<br>完成 view 层的更新<br>若在 updated 中再次修改数据，会再次触发更新方法（beforeUpdate、updated）</li><li>beforeDestroy<br>实例被销毁前调用，此时实例属性与方法仍可访问</li><li>destroyed<br>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器<br>并不能清除 DOM，仅仅销毁实例</li></ol><table><thead><tr><th align="center">生命周期</th><th align="center">描述</th><th align="right"></th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td><td align="right"></td></tr><tr><td align="center">created</td><td align="center">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td><td align="right"></td></tr><tr><td align="center">beforeMount</td><td align="center">未执行渲染、更新，dom 未创建</td><td align="right"></td></tr><tr><td align="center">mounted</td><td align="center">初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td><td align="right"></td></tr><tr><td align="center">beforeUpdate</td><td align="center">更新前，可用于获取更新前各种状态</td><td align="right"></td></tr><tr><td align="center">updated</td><td align="center">更新后，所有状态已是最新</td><td align="right"></td></tr><tr><td align="center">beforeDestroy</td><td align="center">销毁前，可用于一些定时器或订阅的取消</td><td align="right"></td></tr><tr><td align="center">destroyed</td><td align="center">组件已销毁，作用同上</td><td align="right"></td></tr></tbody></table><h3 id="题外话：数据请求在-created-和-mouted-的区别"><a href="#题外话：数据请求在-created-和-mouted-的区别" class="headerlink" title="题外话：数据请求在 created 和 mouted 的区别"></a>题外话：数据请求在 created 和 mouted 的区别</h3><p>created 是在组件实例一旦创建完成的时候立刻调用，这时候页面 dom 节点并未生成；<br><br>mounted 是在页面 dom 节点渲染完毕之后就立刻执行的。<br><br>两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在 mounted 中的请求有可能导致页面闪动（因为此时页面 dom 结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在 created 生命周期当中。</p><h2 id="6-v-if-和-v-for"><a href="#6-v-if-和-v-for" class="headerlink" title="6. v-if 和 v-for"></a>6. v-if 和 v-for</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>v-if:指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true 值的时候被渲染<br>v-for:指令基于一个数组渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是数组元素迭代的别名。</p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>v-for 的优先级高于 v-if，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果想为每个项目渲染的元素添加一个条件，那么将它包装在一个 template 元素中<br><strong>vue 源码中的处理逻辑是：在编译阶段，先处理 v-for，再处理 v-if，所以 v-for 的优先级高于 v-if</strong></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li><li>如果避免出现这种情况，则在外层嵌套 template（页面渲染不生成 dom 节点），在这一层进行 v-if 判断，然后在内部进行 v-for 循环</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>如果条件出现在循环内部，可通过计算属性 computed 提前过滤掉那些不需要显示的项</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">items</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>      <span class="hljs-keyword">return</span> item.<span class="hljs-property">isShow</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-SPA-首屏加载速度慢的怎么解决？"><a href="#7-SPA-首屏加载速度慢的怎么解决？" class="headerlink" title="7. SPA 首屏加载速度慢的怎么解决？"></a>7. SPA 首屏加载速度慢的怎么解决？</h2><blockquote><p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p></blockquote><h3 id="1-关于计算首屏时间"><a href="#1-关于计算首屏时间" class="headerlink" title="1. 关于计算首屏时间"></a>1. 关于计算首屏时间</h3><blockquote><p>通过 DOMContentLoad 或者 performance 来计算出首屏时间</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方案一：</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first contentful painting&#x27;</span>);<br>&#125;);<br><span class="hljs-comment">// 方案二：</span><br>performance.<span class="hljs-title function_">getEntriesByName</span>(<span class="hljs-string">&quot;first-contentful-paint&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">startTime</span><br><br><span class="hljs-comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span><br><span class="hljs-comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span><br>&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;first-contentful-paint&quot;</span>,<br>  <span class="hljs-attr">entryType</span>: <span class="hljs-string">&quot;paint&quot;</span>,<br>  <span class="hljs-attr">startTime</span>: <span class="hljs-number">507.80000002123415</span>,<br>  <span class="hljs-attr">duration</span>: <span class="hljs-number">0</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-加载慢的原因"><a href="#2-加载慢的原因" class="headerlink" title="2. 加载慢的原因"></a>2. 加载慢的原因</h3><ol><li><code>网络</code>延时问题</li><li><code>资源文件体积</code>是否过大</li><li>资源是否<code>重复发送请求</code>去加载了</li><li>加载脚本的时候，渲染内容堵塞了</li></ol><h3 id="3-常见的几种-SPA-首屏优化方式"><a href="#3-常见的几种-SPA-首屏优化方式" class="headerlink" title="3. 常见的几种 SPA 首屏优化方式"></a>3. 常见的几种 SPA 首屏优化方式</h3><ol><li>减小入口文件积(路由懒加载)(在 vue-router 配置路由的时候，采用动态加载路由的形式)</li><li>静态资源本地缓存(前端合理利用 localStorage)</li><li>UI 框架按需加载(在日常使用 UI 框架，例如 element-UI、或者 antd，按需引用)</li><li>图片资源的压缩(雪碧图、精灵图、图片懒加载)</li><li>组件重复打包</li><li>开启 GZip 压缩</li><li>使用 SSR 服务端渲染</li></ol><h2 id="8-为什么-data-属性是一个函数而不是一个对象？"><a href="#8-为什么-data-属性是一个函数而不是一个对象？" class="headerlink" title="8. 为什么 data 属性是一个函数而不是一个对象？"></a>8. 为什么 data 属性是一个函数而不是一个对象？</h2><h3 id="1-实例和组件定义-data-的区别"><a href="#1-实例和组件定义-data-的区别" class="headerlink" title="1. 实例和组件定义 data 的区别"></a>1. 实例和组件定义 data 的区别</h3><blockquote><p>vue 实例的时候定义 data 属性既可以是一个对象，也可以是一个函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 对象格式</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-comment">// 函数格式</span><br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    &#125;<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>组件中定义 data 属性，只能是一个函数</p></blockquote><h3 id="2-组件-data-定义函数与对象的区别"><a href="#2-组件-data-定义函数与对象的区别" class="headerlink" title="2. 组件 data 定义函数与对象的区别"></a>2. 组件 data 定义函数与对象的区别</h3><blockquote><p>在我们定义好一个组件的时候，vue 最终都会通过 Vue.extend()构成组件实例</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Component</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">data</span> = &#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>&#125;<br><span class="hljs-comment">//创建两个组件实例</span><br><span class="hljs-keyword">const</span> componentA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>()<br><span class="hljs-keyword">const</span> componentB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Component</span>()<br><span class="hljs-comment">//修改componentA组件data属性的值，componentB中的值也发生了改变</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 0</span><br>componentA.<span class="hljs-property">data</span>.<span class="hljs-property">count</span> = <span class="hljs-number">1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(componentB.<span class="hljs-property">data</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><ol><li>定义对象：产生这样的原因这是两者共用了同一个内存地址，componentA 修改的内容，同样对 componentB 产生了影响</li><li>采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同）<br>vue 组件可能会有很多个实例，采用函数返回一个全新 data 形式，使每个实例对象的数据不会受到其他实例对象数据的污染</li></ol><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="3. 原理"></a>3. 原理</h3><ol><li>首先可以看看 vue 初始化 data 的代码，data 的定义可以是函数也可以是对象</li></ol><blockquote><p>源码位置：&#x2F;vue-dev&#x2F;src&#x2F;core&#x2F;instance&#x2F;state.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">initData</span> (<span class="hljs-attr">vm</span>: <span class="hljs-title class_">Component</span>) &#123;<br>  <span class="hljs-keyword">let</span> data = vm.<span class="hljs-property">$options</span>.<span class="hljs-property">data</span><br>  data = vm.<span class="hljs-property">_data</span> = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span><br>    ? <span class="hljs-title function_">getData</span>(data, vm)<br>    : data || &#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>组件在创建的时候，会进行选项的合并</li></ol><blockquote><p>源码位置：&#x2F;vue-dev&#x2F;src&#x2F;core&#x2F;util&#x2F;options.js</p></blockquote><p>自定义组件会进入 mergeOptions 进行选项合并</p><ol start="3"><li>定义 data 会进行数据校验</li></ol><blockquote><p>源码位置：&#x2F;vue-dev&#x2F;src&#x2F;core&#x2F;instance&#x2F;init.js</p></blockquote><p>这时候 vm 实例为 undefined，进入 if 判断，若 data 类型不是 function，则出现警告提示</p><h2 id="9-动态给-vue-的-data-添加一个新的属性时会发生什么？怎样解决？"><a href="#9-动态给-vue-的-data-添加一个新的属性时会发生什么？怎样解决？" class="headerlink" title="9.动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？"></a>9.动态给 vue 的 data 添加一个新的属性时会发生什么？怎样解决？</h2><h3 id="直接添加属性的问题"><a href="#直接添加属性的问题" class="headerlink" title="直接添加属性的问题"></a>直接添加属性的问题</h3><p>定义一个 p 标签，通过 v-for 指令进行遍历<br>然后给 botton 标签绑定点击事件，我们预期点击按钮时，数据新增一个属性，界面也 新增一行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(value,key) in item&quot;</span> :key=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>    &#123;&#123; value &#125;&#125;<br>&lt;/p&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addProperty&quot;</span>&gt;</span>动态添加新属性<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="hljs-comment">//实例化一个vue实例，定义data属性和methods方法</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>:<span class="hljs-string">&quot;#app&quot;</span>,<br>   <span class="hljs-attr">data</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-attr">item</span>:&#123;<br>            <span class="hljs-attr">oldProperty</span>:<span class="hljs-string">&quot;旧属性&quot;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-title function_">addProperty</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">newProperty</span> = <span class="hljs-string">&quot;新属性&quot;</span>  <span class="hljs-comment">// 为items添加新属性</span><br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>)  <span class="hljs-comment">// 输出带有newProperty的items</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>点击按钮，发现结果不及预期，数据虽然更新了（console 打印出了新属性），但页面并没有更新</p><h3 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h3><p>我们为 obj 添加新属性的时候，却无法触发事件属性的拦截</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj.bar</span>  = <span class="hljs-string">&#x27;新属性&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>原因是一开始 obj 的 foo 属性被设成了响应式数据，而 bar 是后面新增的属性，并没有通过 Object.defineProperty 设置成响应式数据</p></blockquote><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><ol><li>Vue.set()<br><code>Vue.set( target, propertyName/index, value )</code></li><li>Object.assign()</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建一个新的对象，合并原对象和混入对象的属性</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;,<span class="hljs-variable language_">this</span>.<span class="hljs-property">someObject</span>,&#123;<span class="hljs-attr">newProperty1</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">newProperty2</span>:<span class="hljs-number">2</span> ...&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>$forcecUpdated() <code>$forceUpdate 迫使 Vue 实例重新渲染</code></li></ol><h2 id="10-Vue-中组件和插件有什么区别？"><a href="#10-Vue-中组件和插件有什么区别？" class="headerlink" title="10. Vue 中组件和插件有什么区别？"></a>10. Vue 中组件和插件有什么区别？</h2><h3 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h3><p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在 Vue 中每一个.vue 文件都可以视为一个组件</p><blockquote><p>组件的优势:</p></blockquote><ol><li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li><li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li><li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li></ol><h3 id="插件是什么"><a href="#插件是什么" class="headerlink" title="插件是什么"></a>插件是什么</h3><blockquote><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p></blockquote><ol><li>添加全局<code>方法</code>或者<code>属性</code>。如: vue-custom-element</li><li><code>添加全局资源</code>：指令&#x2F;过滤器&#x2F;过渡等。如 vue-touch</li><li>通过全局混入来<code>添加组件选项</code>。如 vue-router</li><li><code>添加 Vue 实例方法</code>，通过把它们添加到 Vue.prototype 上实现。</li><li><code>一个库</code>，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</li></ol><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><h4 id="1-编写形式"><a href="#1-编写形式" class="headerlink" title="1. 编写形式"></a>1. 编写形式</h4><blockquote><p>编写一个组件，可以有很多方式，我们最常见的就是 vue 单文件的这种格式，每一个.vue 文件我们都可以看成是一个组件</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- vue文件标准格式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">      ...</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>编写插件<br>vue 插件的实现应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123;<br>  <span class="hljs-comment">// 1. 添加全局方法或 property</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">myGlobalMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 逻辑...</span><br>  &#125;<br><br>  <span class="hljs-comment">// 2. 添加全局资源</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;my-directive&#x27;</span>, &#123;<br>    bind (el, binding, vnode, oldVnode) &#123;<br>      <span class="hljs-comment">// 逻辑...</span><br>    &#125;<br>    ...<br>  &#125;)<br><br>  <span class="hljs-comment">// 3. 注入组件选项</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 逻辑...</span><br>    &#125;<br>    ...<br>  &#125;)<br><br>  <span class="hljs-comment">// 4. 添加实例方法</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) &#123;<br>    <span class="hljs-comment">// 逻辑...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-注册形式"><a href="#2-注册形式" class="headerlink" title="2.注册形式"></a>2.注册形式</h4><blockquote><p>组件注册 vue 组件注册主要分为全局注册与局部注册</p></blockquote><ol><li>全局注册通过 Vue.component 方法，第一个参数为组件的名称，第二个参数为传入的配置项<br><code>Vue.component(&#39;my-component-name&#39;, &#123; /* ... */ &#125;)</code></li><li>局部注册只需在用到的地方通过 components 属性注册一个组件</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> component1 = &#123;...&#125; <span class="hljs-comment">// 定义一个组件</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-attr">components</span>:&#123;<br>component1   <span class="hljs-comment">// 局部注册</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>插件注册</p></blockquote><p>插件的注册通过 Vue.use()的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项<br><br><code>Vue.use(插件名字,&#123; /* ... */&#125; )</code></p><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h4><p>组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue<br>插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身</p><h2 id="11-Vue-组件间通信有哪些方式"><a href="#11-Vue-组件间通信有哪些方式" class="headerlink" title="11.Vue 组件间通信有哪些方式"></a>11.Vue 组件间通信有哪些方式</h2><h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><h4 id="props-传递数据"><a href="#props-传递数据" class="headerlink" title="props 传递数据"></a>props 传递数据</h4><blockquote><p>父组件通过 props 向子组件传递数据，子组件通过 props 接收数据</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件vue2</span><br><span class="hljs-attr">props</span>:&#123;<br>    <span class="hljs-comment">// 字符串形式</span><br>   <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">// 接收的类型参数</span><br>   <span class="hljs-comment">// 对象形式</span><br>   <span class="hljs-attr">age</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">Number</span>, <span class="hljs-comment">// 接收的类型为数值</span><br>      <span class="hljs-attr">defaule</span>:<span class="hljs-number">18</span>,  <span class="hljs-comment">// 默认值为18</span><br>      <span class="hljs-attr">require</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// age属性必须传递</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 子组件vue3</span><br><span class="hljs-keyword">import</span> &#123; defineProps, defineEmits &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">count</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-number">0</span><br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 父组件</span><br>&lt;child :name=<span class="hljs-string">&quot;name&quot;</span> :age=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/child&gt;<br></code></pre></td></tr></table></figure><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><blockquote><p>子组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;父组件绑定监听器获取到子组件传递过来的参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Chilfen.vue vue2</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, good)<br><span class="hljs-comment">//Chilfen.vue vue3</span><br><span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>()<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">childAdd</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;add&#x27;</span>, props.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// Father.vue</span><br>&lt;<span class="hljs-title class_">Children</span> @add=<span class="hljs-string">&quot;cartAdd($event)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="ref-获取子组件实例"><a href="#ref-获取子组件实例" class="headerlink" title="ref 获取子组件实例"></a>ref 获取子组件实例</h4><blockquote><p>父组件在使用子组件的时候设置 ref;父组件通过设置子组件 ref 来获取数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;callChildMethod&quot;</span>&gt;</span>Call Child Method<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">callChildMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    childRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">childMethod</span>();</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;</span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">      Child Component</span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">childMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Method called from parent&#x27;</span>);</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  &#125;;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h3><h4 id="EventBus-中央事件总线"><a href="#EventBus-中央事件总线" class="headerlink" title="EventBus 中央事件总线"></a>EventBus 中央事件总线</h4><blockquote><p>创建一个中央事件总线 EventBus;兄弟组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;另一个兄弟组件通过$on 监听自定义事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>() <span class="hljs-comment">// Vue已经实现了Bus的功能</span><br><br><span class="hljs-comment">//Children1.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 触发事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from EventBus!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-comment">// Children2.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听事件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// Output: Hello from EventBus!</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h4 id="parent-或-root"><a href="#parent-或-root" class="headerlink" title="$parent 或$root"></a>$parent 或$root</h4><blockquote><p>通过共同祖辈$parent或者$root 搭建通信桥连</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">//<br>&lt;!-- ParentComponent.vue --&gt;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;child&gt;&lt;/child&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import child from &#x27;~/components/dam/child&#x27;<br>export default &#123;<br>  components: &#123;<br>    child,<br>  &#125;,<br>  methods: &#123;<br>    fatherMethod() &#123;<br>      console.log(&#x27;测试&#x27;)<br>    &#125;,<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br><br>&#123;/*<br>&lt;!-- ChildComponent.vue --&gt;<br>*/&#125;<br>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;childMethod()&quot;&gt;点击&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  methods: &#123;<br>    childMethod() &#123;<br>      this.$parent.fatherMethod()<br>    &#125;,<br>  &#125;,<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="祖孙与后代组件之间的通信"><a href="#祖孙与后代组件之间的通信" class="headerlink" title="祖孙与后代组件之间的通信"></a>祖孙与后代组件之间的通信</h3><h4 id="attrs-与-listeners"><a href="#attrs-与-listeners" class="headerlink" title="$attrs 与$listeners"></a>$attrs 与$listeners</h4><p>设置批量向下传属性$attrs和 $listeners<br>包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。<br>可以通过 v-bind&#x3D;”$attrs” 传⼊内部组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// child：并未在props中声明foo</span><br>&lt;p&gt;&#123;&#123;$attrs.<span class="hljs-property">foo</span>&#125;&#125;&lt;/p&gt;<br><br><span class="hljs-comment">// parent</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;foo&quot;</span>/&gt;</span></span><br><span class="hljs-comment">// 给Grandson隔代传值，communication/index.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;lalala&quot;</span> @<span class="hljs-attr">some-event</span>=<span class="hljs-string">&quot;onSomeEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child2</span>&gt;</span></span><br><br><span class="hljs-comment">// Child2做展开</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grandson</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Grandson</span>&gt;</span></span><br><br><span class="hljs-comment">// Grandson使⽤</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span></span><br><span class="language-xml">&#123;&#123;msg&#125;&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><blockquote><p>在祖先组件定义 provide 属性，返回传递的值;在后代组件通过 inject 接收组件传递过来的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 祖先组件</span><br><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">foo</span>:<span class="hljs-string">&#x27;foo&#x27;</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 后代组件</span><br><span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;foo&#x27;</span>] <span class="hljs-comment">// 获取到祖先组件传递过来的值</span><br></code></pre></td></tr></table></figure><h3 id="非关系组件间之间的通信"><a href="#非关系组件间之间的通信" class="headerlink" title="非关系组件间之间的通信"></a>非关系组件间之间的通信</h3><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ol><li>state 用来存放共享变量的地方</li><li>getter，可以增加一个 getter 派生状态，(相当于 store 中的计算属性），用来获得共享变量的值</li><li>mutations 用来存放修改 state 的方法。</li><li>actions 也是用来存放修改 state 的方法，不过 action 是在 mutations 的基础上进行。常用来做一些异步操作</li></ol><h2 id="12-vue-数据的双向绑定原理"><a href="#12-vue-数据的双向绑定原理" class="headerlink" title="12.vue 数据的双向绑定原理"></a>12.vue 数据的双向绑定原理</h2><blockquote><p>Vue 数据双向绑定原理是通过 数据劫持 + 发布者-订阅者模式 的方式来实现的，首先是通过 ES5 提供的 Object.defineProperty() 方法来劫持（监听）各属性的 getter、setter，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。</p></blockquote><h3 id="Vue-中的双向绑定流程是什么的"><a href="#Vue-中的双向绑定流程是什么的" class="headerlink" title="Vue 中的双向绑定流程是什么的"></a>Vue 中的双向绑定流程是什么的</h3><ol><li>new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中</li><li>同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中</li><li>同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数</li><li>由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher</li><li>将来 data 中数据⼀旦发生变化，会首先找到对应的 Dep，通知所有 Watcher 执行更新函数</li></ol><h3 id="Vue-中的双向绑定原理"><a href="#Vue-中的双向绑定原理" class="headerlink" title="Vue 中的双向绑定原理"></a>Vue 中的双向绑定原理</h3><ol><li>先来一个构造函数：执行初始化，对 data 执行响应化处理\对 data 选项执行响应化具体操作</li><li>编译 Compile<br>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li><li>依赖收集<br>视图中会用到 data 中某 key，这称为依赖。同⼀个 key 可能出现多次，每次都需要收集出来用⼀个 Watcher 来维护它们，此过程称为依赖收集多个 Watcher 需要⼀个 Dep 来管理，需要更新时由 Dep 统⼀通知<ol><li>实现思路</li></ol><ul><li>defineReactive 时为每⼀个 key 创建⼀个 Dep 实例</li><li>初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1</li><li>由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中</li><li>当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新</li></ul></li></ol><h2 id="13-Vue-中的-nextTick-有什么作用"><a href="#13-Vue-中的-nextTick-有什么作用" class="headerlink" title="13. Vue 中的$nextTick 有什么作用"></a>13. Vue 中的$nextTick 有什么作用</h2><h3 id="NextTick-是什么"><a href="#NextTick-是什么" class="headerlink" title="NextTick 是什么"></a>NextTick 是什么</h3><blockquote><p>Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue 将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</p></blockquote><p>为什么要有 nexttick</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  &#123;<br>    num<br>  &#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>  num = i<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新 10 万次视图)，有了 nextTick 机制，只需要更新一次，所以 nextTick 本质是一种优化策略</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p>如果想要在修改数据后立刻得到更新后的 DOM 结构，可以使用 Vue.nextTick()</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;修改后的值&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// $nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;修改后的值&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;原始的值&#x27;</span><br><span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.$nextTick()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;修改后的值&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>把回调函数放入 callbacks 等待执行</li><li>将执行函数放到微任务或者宏任务中</li><li>事件循环到了微任务或者宏任务，执行函数依次执行 callbacks 中的回调</li></ol><h2 id="14-说说你对-slot-的理解？slot-使用场景有哪些？"><a href="#14-说说你对-slot-的理解？slot-使用场景有哪些？" class="headerlink" title="14. 说说你对 slot 的理解？slot 使用场景有哪些？"></a>14. 说说你对 slot 的理解？slot 使用场景有哪些？</h2><blockquote><p>(插槽)是 Web 组件内的一个占位符该占位符可以在后期使用自己的标记语言填充</p></blockquote><p><strong>作用</strong>:通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理.</p><p><strong>分类</strong>:</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><blockquote><p>子组件用<slot>标签来确定渲染的位置，标签里面可以放 DOM 结构，当父组件使用的时候没有往插槽传入内容，标签内 DOM 结构就会显示在页面</slot></p></blockquote><blockquote><p>父组件在使用的时候，直接在子组件的标签内写入内容即可</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件Child.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>默认插槽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote><p>子组件用 name 属性来表示插槽的名字，不传为默认插槽</p></blockquote><blockquote><p>父组件中在使用时在默认插槽的基础上加上 slot 属性，值为子组件插槽 name 属性值</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件Child.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span>具名插槽<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 具名插槽⽤插槽名做参数 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">content</span>&gt;</span>内容...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote><p>子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件 v-slot 接受的对象上</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- // 子组件Child.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span> <span class="hljs-attr">testProps</span>=<span class="hljs-string">&quot;子组件的值&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>没传footer插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- // 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>    来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span><br>    来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在源码层面，Vue 的编译器会将 slot 标签解析成对应的 VNode，并在渲染过程中根据 VNode 的信息来处理 slot。具体来说，编译器会为 slot 生成对应的渲染函数，并在渲染函数中根据 slot 的类型和属性值来决定如何处理插槽内容。</p><h2 id="15-Vue-observable-你有了解过吗？说说看"><a href="#15-Vue-observable-你有了解过吗？说说看" class="headerlink" title="15. Vue.observable 你有了解过吗？说说看"></a>15. Vue.observable 你有了解过吗？说说看</h2><blockquote><p><code>Vue.observable</code>，让一个对象变成<code>响应式数据</code>。Vue 内部会用它来处理 data 函数返回的对象</p></blockquote><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p>在非父子组件通信时，可以使用通常的 bus 或者使用 vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable 就是一个很好的选择</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个js文件</span><br><br><span class="hljs-comment">// 引入vue</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue</span><br><span class="hljs-string">// 创建state对象，使用observable让state对象可响应</span><br><span class="hljs-string">export let state = Vue.observable(&#123;</span><br><span class="hljs-string">  name: &#x27;</span>张三<span class="hljs-string">&#x27;,</span><br><span class="hljs-string">  &#x27;</span>age<span class="hljs-string">&#x27;: 38</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">// 创建对应的方法</span><br><span class="hljs-string">export let mutations = &#123;</span><br><span class="hljs-string">  changeName(name) &#123;</span><br><span class="hljs-string">    state.name = name</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  setAge(age) &#123;</span><br><span class="hljs-string">    state.age = age</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// 在.vue文件中直接使用即可</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;template&gt;</span><br><span class="hljs-string">  &lt;div&gt;</span><br><span class="hljs-string">    姓名：&#123;&#123; name &#125;&#125;</span><br><span class="hljs-string">    年龄：&#123;&#123; age &#125;&#125;</span><br><span class="hljs-string">    &lt;button @click=&quot;changeName(&#x27;</span>李四<span class="hljs-string">&#x27;)&quot;&gt;改变姓名&lt;/button&gt;</span><br><span class="hljs-string">    &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt;</span><br><span class="hljs-string">  &lt;/div&gt;</span><br><span class="hljs-string">&lt;/template&gt;</span><br><span class="hljs-string">import &#123; state, mutations &#125; from &#x27;</span>@/store<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 在计算属性中拿到值</span><br>  <span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">name</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">name</span><br>    &#125;,<br>    <span class="hljs-title function_">age</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">age</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-comment">// 调用mutations里面的方法，更新数据</span><br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">changeName</span>: mutations.<span class="hljs-property">changeName</span>,<br>    <span class="hljs-attr">setAge</span>: mutations.<span class="hljs-property">setAge</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><h2 id="16-你知道-vue-中-key-的原理吗？说说你对它的理解"><a href="#16-你知道-vue-中-key-的原理吗？说说你对它的理解" class="headerlink" title="16. 你知道 vue 中 key 的原理吗？说说你对它的理解"></a>16. 你知道 vue 中 key 的原理吗？说说你对它的理解</h2><blockquote><p>key 是给每一个 vnode 的唯一 id，也是 diff 的一种优化策略，可以根据 key，更准确， 更快的找到对应的 vnode 节点</p></blockquote><h3 id="当我们在使用-v-for-时，需要给单元加上-key"><a href="#当我们在使用-v-for-时，需要给单元加上-key" class="headerlink" title="当我们在使用 v-for 时，需要给单元加上 key"></a>当我们在使用 v-for 时，需要给单元加上 key</h3><ol><li><p>如果不用 key，Vue 会采用就地复用原则：最小化 element 的移动，并且会尝试尽最大程度在同适当的地方对相同类型的 element，做 patch 或者 reuse。<br>分析下整体流程：<br>比较 A，A，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 B，B，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 C，F，相同类型的节点，进行 patch，数据不同，发生 dom 操作<br>比较 D，C，相同类型的节点，进行 patch，数据不同，发生 dom 操作<br>比较 E，D，相同类型的节点，进行 patch，数据不同，发生 dom 操作<br>循环结束，将 E 插入到 DOM 中<br>一共发生了 3 次更新，1 次插入操作</p></li><li><p>如果使用了 key，Vue 会根据 keys 的顺序记录 element，曾经拥有了 key 的 element 如果不再出现的话，会被直接 remove 或者 destoryed<br>在使用 key 的情况：vue 会进行这样的操作：<br>比较 A，A，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 B，B，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 C，F，不相同类型的节点<br>比较 E、E，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 D、D，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>比较 C、C，相同类型的节点，进行 patch，但数据相同，不发生 dom 操作<br>循环结束，将 F 插入到 C 之前<br>一共发生了 0 次更新，1 次插入操作</p></li></ol><h2 id="17-说说你对-keep-alive-的理解是什么？"><a href="#17-说说你对-keep-alive-的理解是什么？" class="headerlink" title="17. 说说你对 keep-alive 的理解是什么？"></a>17. 说说你对 keep-alive 的理解是什么？</h2><blockquote><p>keep-alive 是 vue 中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染 DOM<br><br>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p></blockquote><h3 id="keep-alive-属性"><a href="#keep-alive-属性" class="headerlink" title="keep-alive 属性"></a>keep-alive 属性</h3><blockquote><p>keep-alive 可以设置以下 props 属性：</p></blockquote><ol><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li><li>max - 数字。最多可以缓存多少组件实例</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated 与 deactivated）：</p></blockquote><ol><li>首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated</li><li>再次进入组件时：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated</li></ol><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ol><li>在组件渲染的时候会自动执行 render 函数<br><br>this.cache 是一个对象，用来存储需要缓存的组件，它将以如下形式存储：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = &#123;<br>  <span class="hljs-attr">key1</span>: <span class="hljs-string">&#x27;组件1&#x27;</span>,<br>  <span class="hljs-attr">key2</span>: <span class="hljs-string">&#x27;组件2&#x27;</span>,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>在组件销毁的时候执行 pruneCacheEntry 函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">cache[key] = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在 mounted 钩子函数中观测 include 和 exclude 的变化，如下</li><li>如果 include 或 exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行 pruneCache 函数</li><li>在该函数内对 this.cache 对象进行遍历，取出每一项的 name 值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用 pruneCacheEntry 函数将其从 this.cache 对象剔除即可</li></ol><h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><ol><li>首先获取组件的 key 值：<code>const key = vnode.key == null? </code></li><li>拿到 key 值后去 this.cache 对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下：直接从缓存中拿 vnode 的组件实例，此时重新调整该组件 key 的顺序，将其从原来的地方删掉并重新放在 this.keys 中最后一个</li><li>this.cache 对象中没有该 key 值的情况，如下：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* 如果没有命中缓存，则将其设置进缓存 */</span><br><span class="hljs-keyword">else</span> &#123;<br>    cache[key] = vnode<br>    keys.<span class="hljs-title function_">push</span>(key)<br>    <span class="hljs-comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>        <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>表明该组件还没有被缓存过，则以该组件的 key 为键，组件 vnode 为值，将其存入 this.cache 中，并且把 key 存入 this.keys 中</p><p>此时再判断 this.keys 中缓存组件的数量是否超过了设置的最大缓存数量值 this.max，如果超过了，则把第一个缓存组件删掉</p><h2 id="18-Vue-常用的修饰符有哪些有什么应用场景"><a href="#18-Vue-常用的修饰符有哪些有什么应用场景" class="headerlink" title="18. Vue 常用的修饰符有哪些有什么应用场景"></a>18. Vue 常用的修饰符有哪些有什么应用场景</h2><p>Vue 常用的修饰符有哪些有什么应用场景</p><blockquote><p>在 Vue 中，修饰符处理了许多 DOM 事件的细节:表单修饰符\事件修饰符\鼠标按键修饰符\键值修饰符\v-bind 修饰符</p></blockquote><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><ol><li>lazy<blockquote><p>在我们填完信息，光标离开标签的时候，才会将值赋予给 value，也就是在 change 事件之后再进行信息同步</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;</code></p><ol start="2"><li>trim<blockquote><p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;</code></p><ol start="3"><li>number<blockquote><p>自动将用户的输入值转为数值类型，但如果这个值无法被 parseFloat 解析，则会返回原来的值</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.number=&quot;value&quot;&gt;</code></p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ol><li>stop<blockquote><p>阻止了事件冒泡，相当于调用了 event.stopPropagation 方法</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>prevent<blockquote><p>阻止了事件的默认行为，相当于调用了 event.preventDefault 方法</p></blockquote></li></ol><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p><ol start="3"><li>self<blockquote><p>只当在 event.target 是当前元素自身时触发处理函数</p></blockquote></li></ol><p><code>&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code></p><ol start="4"><li>once<blockquote><p>绑定了事件以后只能触发一次，第二次就不会触发</p></blockquote></li></ol><p>&lt;button @click.once&#x3D;”shout(1)”&gt;ok</p><ol start="5"><li>capture<blockquote><p>使事件触发从包含这个元素的顶层开始往下触发</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;<br>    obj1<br>   &lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>         obj2<br>      &lt;div @click=<span class="hljs-string">&quot;shout(3)&quot;</span>&gt;<br>            obj3<br>            &lt;div @click=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;<br>               obj4<br>            &lt;/div&gt;<br>      &lt;/div&gt;<br>   &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>passive<blockquote><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发 onscroll 事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 onscroll 事件整了一个.lazy 修饰符</p></blockquote></li></ol><p><code>&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code></p><ol start="7"><li>native<blockquote><p>让组件变成像 html 内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</p></blockquote></li></ol><p><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></p><h3 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h3><blockquote><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p></blockquote><ol><li>left 左键点击</li><li>right 右键点击</li><li>middle 中键点击</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click.<span class="hljs-property">left</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.right</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.middle</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h3><blockquote><p>键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：</p></blockquote><ol><li>普通键（enter、tab、delete、space、esc、up…）</li><li>系统修饰键（ctrl、alt、meta、shift…）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只有按键为keyCode的时候才触发</span><br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> @keyup.<span class="hljs-property">keyCode</span>=<span class="hljs-string">&quot;shout()&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="v-bind-修饰符"><a href="#v-bind-修饰符" class="headerlink" title="v-bind 修饰符"></a>v-bind 修饰符</h3><ol><li>sync<blockquote><p>能对 props 进行一个双向绑定</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父组件</span><br>&lt;comp :myMessage.<span class="hljs-property">sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br><br><span class="hljs-comment">//父亲组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">:myMessage</span>=<span class="hljs-string">&quot;bar&quot;</span> @<span class="hljs-attr">update:myMessage</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span></span><br><span class="hljs-title function_">func</span>(<span class="hljs-params">e</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = e;<br>&#125;<br><span class="hljs-comment">//子组件js</span><br><span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>使用 sync 的时候，子组件传递的事件名格式必须为 update:value，其中 value 必须与子组件中 props 中声明的名称完全一致.</li><li>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync&#x3D;”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</li><li>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync&#x3D;”{ title: doc.title }”，是无法正常工作的.</li></ol><ol start="2"><li>props<blockquote><p>设置自定义标签属性，避免暴露数据，防止污染 HTML 结构</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input id=<span class="hljs-string">&quot;uid&quot;</span> title=<span class="hljs-string">&quot;title1&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span> :index.<span class="hljs-property">prop</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>camel<blockquote><p>将命名变为驼峰命名法，如将 view-Box 属性名转换为 viewBox</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;svg :viewBox=<span class="hljs-string">&quot;viewBox&quot;</span>&gt;&lt;/svg&gt;<br></code></pre></td></tr></table></figure><h2 id="19-你有写过自定义指令吗？自定义指令的应用场景有哪些？"><a href="#19-你有写过自定义指令吗？自定义指令的应用场景有哪些？" class="headerlink" title="19. 你有写过自定义指令吗？自定义指令的应用场景有哪些？"></a>19. 你有写过自定义指令吗？自定义指令的应用场景有哪些？</h2><blockquote><p>在 vue 中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统我们看到的 v-开头的行内属性，都是指令</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="全局注册主要是通过-Vue-directive-方法进行注册"><a href="#全局注册主要是通过-Vue-directive-方法进行注册" class="headerlink" title="全局注册主要是通过 Vue.directive 方法进行注册"></a>全局注册主要是通过 Vue.directive 方法进行注册</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数</span><br><br><span class="hljs-comment">// 注册一个全局自定义指令 `v-focus`</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-comment">// 当被绑定的元素插入到 DOM 中时……</span><br>  <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>    <span class="hljs-comment">// 聚焦元素</span><br>    el.<span class="hljs-title function_">focus</span>() <span class="hljs-comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span><br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="局部注册通过在组件-options-选项中设置-directive-属性"><a href="#局部注册通过在组件-options-选项中设置-directive-属性" class="headerlink" title="局部注册通过在组件 options 选项中设置 directive 属性"></a>局部注册通过在组件 options 选项中设置 directive 属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">directives</span>: &#123;<br>  <span class="hljs-attr">focus</span>: &#123;<br>    <span class="hljs-comment">// 指令的定义</span><br>    <span class="hljs-attr">inserted</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">el</span>) &#123;<br>      el.<span class="hljs-title function_">focus</span>() <span class="hljs-comment">// 页面加载完成之后自动让输入框获取到焦点的小功能</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>所有的钩子函数的参数都有以下：</p></blockquote><ol><li>el：指令所绑定的元素，可以用来直接操作 DOM</li><li>binding：一个对象，包含以下 property：<ol><li>name：指令名，不包括 v- 前缀。</li><li>value：指令的绑定值，例如：v-my-directive&#x3D;”1 + 1” 中，绑定值为 2。</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li><li>expression：字符串形式的指令表达式。例如 v-my-directive&#x3D;”1 + 1” 中，表达式为 “1 + 1”。</li><li>arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。</li><li>modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }</li></ol></li><li>vnode：Vue 编译生成的虚拟节点</li><li>oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用</li></ol><h2 id="20-Vue-中的过滤器了解吗？过滤器的应用场景有哪些？"><a href="#20-Vue-中的过滤器了解吗？过滤器的应用场景有哪些？" class="headerlink" title="20. Vue 中的过滤器了解吗？过滤器的应用场景有哪些？"></a>20. Vue 中的过滤器了解吗？过滤器的应用场景有哪些？</h2><blockquote><p>Vue3 中已废弃 filter<br>vue 中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在双花括号中 --&gt;</span><br>&#123;&#123; message | capitalize &#125;&#125;<br><br><span class="hljs-comment">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>在组件的选项中定义本地的过滤器</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-attr">capitalize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>    value = value.<span class="hljs-title function_">toString</span>()<br>    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>定义全局过滤器：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  value = value.<span class="hljs-title function_">toString</span>()<br>  <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="21-什么是虚拟-DOM？如何实现一个虚拟-DOM？说说你的思路"><a href="#21-什么是虚拟-DOM？如何实现一个虚拟-DOM？说说你的思路" class="headerlink" title="21. 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路"></a>21. 什么是虚拟 DOM？如何实现一个虚拟 DOM？说说你的思路</h2><blockquote><p>实际上它只是一层对<code>真实DOM的抽象</code>，以 JavaScript 对象 (VNode 节点) 作为基础的树，用<code>对象的属性</code>来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上</p></blockquote><h3 id="为什么需要虚拟-DOM"><a href="#为什么需要虚拟-DOM" class="headerlink" title="为什么需要虚拟 DOM"></a>为什么需要虚拟 DOM</h3><blockquote><p>通过 VNode，vue 可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过 diff 算法得出一些需要修改的最小单位,再更新视图，减少了 dom 操作，提高了性能</p></blockquote><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol><li>vue 是通过 createElement 生成 VNode<blockquote><p>_createElement 接收 5 个参数：</p></blockquote><ol><li>context 表示 VNode 的上下文环境，是 Component 类型</li><li>tag 表示标签，它可以是一个字符串，也可以是一个 Component</li><li>data 表示 VNode 的数据，它是一个 VNodeData 类型</li><li>children 表示当前 VNode 的子节点，它是任意类型的</li><li>normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的</li></ol></li></ol><p>createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个虚拟树结构，用于描述真实的 DOM 树结构</p><h2 id="22-你了解-vue-的-diff-算法吗？说说看"><a href="#22-你了解-vue-的-diff-算法吗？说说看" class="headerlink" title="22. 你了解 vue 的 diff 算法吗？说说看"></a>22. 你了解 vue 的 diff 算法吗？说说看</h2><blockquote><p>diff 算法是一种通过同层的树节点进行比较的高效算法</p></blockquote><h3 id="其有两个特点："><a href="#其有两个特点：" class="headerlink" title="其有两个特点："></a>其有两个特点：</h3><ol><li>比较只会在同层级进行, 不会跨层级比较</li><li>在 diff 比较的过程中，循环从两边向中间比较</li></ol><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图</p></blockquote><ol><li><p>patch 函数前两个参数位为 oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p><ol><li>没有新节点，直接触发旧节点的 destory 钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm</li><li>旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点，子节点不完全一致，则调用 updateChildren</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ol></li><li><p>patchVnode 主要做了几个判断：</p><ol><li>新节点是否是文本节点，如果是，则直接更新 dom 的文本内容为新节点的文本内容<br>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新 DOM，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把 DOM 删除</li></ol></li><li><p>子节点不完全一致，则调用 updateChildren</p><ol><li>当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1</li><li>当新老 VNode 节点的 end 相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1</li><li>当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1</li><li>当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<br>从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行 patchVnode，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面<br>调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置</li></ol></li></ol><h2 id="23-Vue-项目中有封装过-axios-吗？主要是封装哪方面的？"><a href="#23-Vue-项目中有封装过-axios-吗？主要是封装哪方面的？" class="headerlink" title="23. Vue 项目中有封装过 axios 吗？主要是封装哪方面的？"></a>23. Vue 项目中有封装过 axios 吗？主要是封装哪方面的？</h2><blockquote><p>Axios 是一个基于 Promise 的 HTTP 库，可以用于浏览器和 Node.js 环境中发送 HTTP 请求。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>支持 Promise API，可以轻易地执行所有类似于 then() 以及 catch() 方法的异步操作；</li><li>具有可取消的请求功能；</li><li>可以拦截请求和响应；</li><li>支持浏览器和 Node.js。</li><li>自动转换 JSON 数据、CSRF 保护等功能。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 Axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 发送 GET 请求</span><br>axios<br>  .<span class="hljs-title function_">get</span>(<br>    <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">_limit</span>: <span class="hljs-number">5</span>,<br>      &#125;,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>      &#125;,<br>    &#125;<br>  )<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error fetching data:&#x27;</span>, error)<br>  &#125;)<br><br><span class="hljs-comment">// 发送 POST 请求</span><br>axios<br>  .<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>, &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error posting data:&#x27;</span>, error)<br>  &#125;)<br><span class="hljs-comment">// PUT\DELETE 请求同理</span><br></code></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>封装 axios 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// axiosInstance.js</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 创建一个 Axios 实例</span><br><span class="hljs-keyword">const</span> axiosInstance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>, <span class="hljs-comment">// 设置基础 URL</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 设置超时时间</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, <span class="hljs-comment">// 设置请求头</span><br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 请求拦截器</span><br>axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在请求发送之前做一些处理，比如添加 token 等</span><br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-comment">// 响应拦截器</span><br>axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对响应数据做些什么</span><br>    <span class="hljs-keyword">return</span> response<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对响应错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axiosInstance<br></code></pre></td></tr></table></figure><ol start="2"><li>二次封装</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api.js</span><br><br><span class="hljs-keyword">import</span> axiosInstance <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./axiosInstance&#x27;</span><br><br><span class="hljs-comment">// 封装 GET 请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPosts</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axiosInstance.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 封装 POST 请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createPost</span> = (<span class="hljs-params">postData</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axiosInstance.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>, postData)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createDelete</span> = (<span class="hljs-params">ids</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axiosInstance</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/member/cart&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      ids,<br>    &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="axios-的-原理"><a href="#axios-的-原理" class="headerlink" title="axios 的(原理)"></a>axios 的(原理)</h3><blockquote><p>Axios 的底层实现使用了 XMLHttpRequest 对象，它将请求数据包装在一个 Promise 中，并发送网络请求。Axios 还提供了一个拦截器（interceptor），允许在请求或响应被处理前、或者响应被 reject 前截获它们。</p></blockquote><h4 id="Axios-主要使用了以下技术来实现："><a href="#Axios-主要使用了以下技术来实现：" class="headerlink" title="Axios 主要使用了以下技术来实现："></a>Axios 主要使用了以下技术来实现：</h4><ol><li>构造 XMLHttpRequest 对象</li><li>序列化参数</li><li>配置请求信息</li><li>监听 xhr 的变化，包括 XHR 自身状态变化，和 http 响应状态变化</li><li>对响应数据进行处理和解析</li></ol><p>Axios 对 XHR 进行了两层封装，第一层封装屏蔽了 XHR 对象差异，提供了统一的 API；<br><br>第二层封装是基于 Promise 对象，让 HTTP 请求异步执行。<br></p><h2 id="24-你了解-axios-的原理吗？有看过它的源码吗？"><a href="#24-你了解-axios-的原理吗？有看过它的源码吗？" class="headerlink" title="24. 你了解 axios 的原理吗？有看过它的源码吗？(*)"></a>24. 你了解 axios 的原理吗？有看过它的源码吗？(*)</h2><h2 id="25-SSR-解决了什么问题？有做过-SSR-吗？你是怎么做的？"><a href="#25-SSR-解决了什么问题？有做过-SSR-吗？你是怎么做的？" class="headerlink" title="25. SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？(*)"></a>25. SSR 解决了什么问题？有做过 SSR 吗？你是怎么做的？(*)</h2><blockquote><p>Server-Side Rendering 我们称其为 SSR，意为服务端渲染<br>指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ol><li><p>SSR 主要解决了以下两种问题：</p><ul><li>seo：搜索引擎优先爬取页面 HTML 结构，使用 ssr 时，服务端已经生成了和业务想关联的 HTML，有利于 seo</li><li>首屏呈现渲染：用户无需等待页面所有 js 加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）</li></ul></li><li><p>但是使用 SSR 同样存在以下的缺点：</p><ul><li>复杂度：整个项目的复杂度</li><li>库的支持性，代码兼容</li><li>性能问题<br>每个请求都是 n 个实例的创建，不然会污染，消耗会变得很大<br>缓存 node serve、 nginx 判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。</li><li>降级：监控 cpu、内存占用过多，就 spa，返回单个的壳 -服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用</li></ul></li></ol><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h2 id="26-说下你的-vue-项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"><a href="#26-说下你的-vue-项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？" class="headerlink" title="26. 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？"></a>26. 说下你的 vue 项目的目录结构，如果是大型项目你该怎么划分结构和划分组件呢？</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js">project<br>|-- dist<br>|-- node_modules<br>|-- public<br>│      favicon.<span class="hljs-property">ico</span><br>│      index.<span class="hljs-property">html</span><br>|-- src<br>   |-- assets<br>      |-- images<br>      |-- styles<br>   |-- api<br>      |-- index.<span class="hljs-property">js</span><br>   |-- components<br>      |-- input<br>         |-- index.<span class="hljs-property">js</span><br>         |-- index.<span class="hljs-property">module</span>.<span class="hljs-property">scss</span><br>   |-- config<br>      |-- index.<span class="hljs-property">js</span><br>   |-- constants<br>      |-- index.<span class="hljs-property">js</span><br>   |-- router<br>      |-- index.<span class="hljs-property">js</span><br>   |-- store<br>      |-- index.<span class="hljs-property">js</span><br>   |-- utils<br>      |-- index.<span class="hljs-property">js</span><br>   |-- views<br>      |-- home<br>         |-- index.<span class="hljs-property">vue</span><br>   |  <span class="hljs-title class_">App</span>.<span class="hljs-property">vue</span><br>   |  main.<span class="hljs-property">js</span><br>|-- tests<br>|-- types<br>|  .<span class="hljs-property">browserslistrc</span><br>│  .<span class="hljs-property">env</span>.<span class="hljs-property">production</span><br>│  .<span class="hljs-property">eslintrc</span>.<span class="hljs-property">js</span><br>│  .<span class="hljs-property">gitignore</span><br>│  package-lock.<span class="hljs-property">json</span><br>│  package.<span class="hljs-property">json</span><br>│  <span class="hljs-variable constant_">README</span>.<span class="hljs-property">md</span><br>│  vue.<span class="hljs-property">config</span>.<span class="hljs-property">js</span><br></code></pre></td></tr></table></figure><h2 id="27-vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"><a href="#27-vue-要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？" class="headerlink" title="27. vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？"></a>27. vue 要做权限管理该怎么做？如果控制到按钮级别的权限怎么做？</h2><blockquote><p>前端权限控制可以分为四个方面：</p></blockquote><ul><li>接口权限</li><li>按钮权限</li><li>菜单权限</li><li>路由权限</li></ul><h3 id="接口权限"><a href="#接口权限" class="headerlink" title="接口权限"></a>接口权限</h3><blockquote><p>接口权限目前一般采用 jwt 的形式来验证，没有通过的话一般返回 401，跳转到登录页面重新进行登录<br>登录完拿到 token，将 token 存起来，通过 axios 请求拦截器进行拦截，每次请求的时候头部携带 token</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;<br>    config.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;token&#x27;</span>] = cookie.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">return</span> config<br>&#125;)<br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;,&#123;response&#125;=&gt;&#123;<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">40099</span> || response.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">40098</span>) &#123; <span class="hljs-comment">//token过期或者错误</span><br>        router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="路由权限"><a href="#路由权限" class="headerlink" title="路由权限"></a>路由权限</h3><ol><li>初始化即挂载全部路由，并且在路由上标记相应的权限信息，每次路由跳转前做校验</li><li>初始化的时候先挂载不需要权限控制的路由，比如登录页，404 等错误页。如果用户通过 URL 进行强制访问，则会直接进入 404，相当于从源头上做了控制<br><br>登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用 addRoutes 添加路由</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">meta</span>: &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;permission&#x27;</span>,<br>  <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;lock&#x27;</span>,<br>  <span class="hljs-attr">roles</span>: [<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;editor&#x27;</span>] <span class="hljs-comment">// you can set roles in root nav</span><br>&#125;,<br><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 菜单权限</span><br><span class="hljs-string"></span><br><span class="hljs-string">1. 菜单与路由分离，菜单由后端返回,全局路由守卫里做判断</span><br><span class="hljs-string">2. 菜单和路由都由后端返回</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 按钮权限</span><br><span class="hljs-string"></span><br><span class="hljs-string">1. 按钮权限也可以用 v-if 判断</span><br><span class="hljs-string">2. 通过自定义指令进行按钮权限的判断</span><br><span class="hljs-string"></span><br><span class="hljs-string">## 28. Vue 项目中你是如何解决跨域的呢？</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 同源策略</span><br><span class="hljs-string"></span><br><span class="hljs-string">&gt; 同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互</span><br><span class="hljs-string">&gt; 如果两个 URL 的协议、端口（如果有指定的话）和主机都相同的话，则这两个 URL 是同源的</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>http<br><span class="hljs-attr">http</span>:<span class="hljs-comment">//store.company.com/dir2/other.html</span><br>协议：http<br>主机：store.<span class="hljs-property">company</span>.<span class="hljs-property">com</span><br>端口：<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><blockquote><p>解决跨域的方法有很多，下面列举了三种：</p></blockquote><ol><li>JSONP</li><li>CORS</li><li>Proxy</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><blockquote><p>它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应<br><br>CORS 实现起来非常方便，只需要增加一些 HTTP 头，让服务器能声明允许的访问来源只要后端实现了 CORS，就实现了跨域</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>  ctx.<span class="hljs-title function_">set</span>(<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span><br>  )<br>  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> == <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) &#123;<br>    ctx.<span class="hljs-property">body</span> = <span class="hljs-number">200</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p></blockquote><h2 id="29-vue-项目本地开发完成后部署到服务器后报-404-是什么原因呢？"><a href="#29-vue-项目本地开发完成后部署到服务器后报-404-是什么原因呢？" class="headerlink" title="29. vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？"></a>29. vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？</h2><h3 id="为什么-history-模式下有问题"><a href="#为什么-history-模式下有问题" class="headerlink" title="为什么 history 模式下有问题"></a>为什么 history 模式下有问题</h3><p>Vue 是属于单页应用（single-page application）</p><p>而 SPA 是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个 index.html</p><p>现在，我们回头来看一下我们的 nginx 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">server &#123;<br>  listen  <span class="hljs-number">80</span>;<br>  server_name  www.<span class="hljs-property">xxx</span>.<span class="hljs-property">com</span>;<br><br>  location / &#123;<br>    index  /data/dist/index.<span class="hljs-property">html</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以根据 nginx 配置得出，当我们在地址栏输入 <a href="http://www.xxx.com/">www.xxx.com</a> 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 <a href="http://www.xxx.com/login">www.xxx.com/login</a></p><p>关键在这里，当我们在 website.com&#x2F;login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况</p><h3 id="为什么-hash-模式下没有问题"><a href="#为什么-hash-模式下没有问题" class="headerlink" title="为什么 hash 模式下没有问题"></a>为什么 hash 模式下没有问题</h3><p>router hash 模式我们都知道是用符号#表示的，如 website.com&#x2F;#&#x2F;login, hash 的值为 #&#x2F;login</p><p>它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面</p><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com&#x2F;#&#x2F;login 只有 website.com 会被包含在请求中 ，因此对于服务端来说，即使没有配置 location，也不会返回 404 错误</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对 nginx 配置文件.conf 修改，添加 try_files $uri $uri&#x2F; &#x2F;index.html;</p><p>server {<br>listen 80;<br>server_name <a href="http://www.xxx.com/">www.xxx.com</a>;</p><p>location &#x2F; {<br>index &#x2F;data&#x2F;dist&#x2F;index.html;<br>try_files $uri $uri&#x2F; &#x2F;index.html;<br>}<br>}</p><h2 id="30-你是怎么处理-vue-项目中的错误的？"><a href="#30-你是怎么处理-vue-项目中的错误的？" class="headerlink" title="30. 你是怎么处理 vue 项目中的错误的？"></a>30. 你是怎么处理 vue 项目中的错误的？</h2><h2 id="31-vue3-有了解过吗？能说说跟-vue2-的区别吗？"><a href="#31-vue3-有了解过吗？能说说跟-vue2-的区别吗？" class="headerlink" title="31. vue3 有了解过吗？能说说跟 vue2 的区别吗？"></a>31. vue3 有了解过吗？能说说跟 vue2 的区别吗？</h2><h3 id="1-双向数据绑定原理不同"><a href="#1-双向数据绑定原理不同" class="headerlink" title="1. 双向数据绑定原理不同"></a>1. 双向数据绑定原理不同</h3><blockquote><p>vue2：vue2 的双向数据绑定是利用 ES5 的一个 APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。</p></blockquote><blockquote><p>vue3：vue3 中使用了 ES6 的 Proxy API 对数据代理。相比 vue2.x，使用 proxy 的优势如下：</p></blockquote><ol><li>defineProperty 只能监听某个属性，不能对全对象监听</li><li>可以省去 for in，闭包等内容来提升效率(直接绑定整个对象即可)</li><li>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x 可以检测到数组内部数据的变化。</li></ol><h3 id="2-是否支持碎片-framents"><a href="#2-是否支持碎片-framents" class="headerlink" title="2.是否支持碎片(framents)"></a>2.是否支持碎片(framents)</h3><blockquote><p>vue2 不支持碎片。</p></blockquote><blockquote><p>vue3：vue3 支持碎片（Fragments） ，就是说可以拥有多个根节点。</p></blockquote><h3 id="3-API-类型不同-compositon-Api"><a href="#3-API-类型不同-compositon-Api" class="headerlink" title="3. API 类型不同 (compositon Api)"></a>3. API 类型不同 (compositon Api)</h3><blockquote><p>vue2：vue2 使用选项类型 api，选项型 api 在代码里分割了不同的属性：data,computed,methods 等。</p></blockquote><blockquote><p>vue3：vue3 使用合成型 api，新的合成型 api 能让我们使用方法来分割，相比于旧的 api 使用属性来分组，这样代码会更加简便和整洁。</p></blockquote><h3 id="4-声明周期钩子不同"><a href="#4-声明周期钩子不同" class="headerlink" title="4. 声明周期钩子不同"></a>4. 声明周期钩子不同</h3><table><thead><tr><th align="center">vue2</th><th align="center">vue3</th><th>vue</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center"></td><td></td></tr><tr><td align="center">created</td><td align="center"></td><td></td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td><td></td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td><td></td></tr><tr><td align="center">beforeUpdate</td><td align="center">onBeforeUpdate</td><td></td></tr><tr><td align="center">updated</td><td align="center">onUpdated</td><td></td></tr><tr><td align="center">beforeDestroy</td><td align="center">onBeforeUnmount</td><td></td></tr><tr><td align="center">destroyed</td><td align="center">onUnmounted</td><td></td></tr></tbody></table><h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><blockquote><p>Vue 3 提供了更好的 Tree-shaking 支持\更小的 bundle 大小\更快的更新速度、更好的 TypeScript 支持\更高效的虚拟 DOM 实现和编译优化。</p></blockquote><h3 id="6-异步组件（Suspense）"><a href="#6-异步组件（Suspense）" class="headerlink" title="6. 异步组件（Suspense）"></a>6. 异步组件（Suspense）</h3><p>Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tempalte</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">suspense</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        Loading...      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">suspense</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-Teleport"><a href="#7-Teleport" class="headerlink" title="7.Teleport"></a>7.Teleport</h3><p>Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;dialogVisible = true&quot;</span>&gt;</span>显示弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;dialogVisible&quot;</span>&gt;</span><br>    我是弹窗，我直接移动到了body标签下<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue系列-1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-frontend</title>
    <link href="/2024/02/17/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-frontend/"/>
    <url>/2024/02/17/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-frontend/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-interview-frontend"><a href="#🍭-interview-frontend" class="headerlink" title="🍭 interview-frontend"></a>🍭 interview-frontend</h1><h2 id="1-Echarts"><a href="#1-Echarts" class="headerlink" title="1. Echarts"></a>1. Echarts</h2><h2 id="2-Uniapp"><a href="#2-Uniapp" class="headerlink" title="2. Uniapp"></a>2. Uniapp</h2><h2 id="3-webpack"><a href="#3-webpack" class="headerlink" title="3. webpack"></a>3. webpack</h2><h2 id="4-git"><a href="#4-git" class="headerlink" title="4. git"></a>4. git</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview-vue+H5C3-id3</title>
    <link href="/2024/02/16/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3-id3/"/>
    <url>/2024/02/16/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3-id3/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-Vue-H5C3-id3"><a href="#🍭-面试-Vue-H5C3-id3" class="headerlink" title="🍭 面试-Vue+H5C3-id3"></a>🍭 面试-Vue+H5C3-id3</h1><h2 id="21-vue-如何封装一个组件"><a href="#21-vue-如何封装一个组件" class="headerlink" title="21. vue 如何封装一个组件"></a>21. vue 如何封装一个组件</h2><ol><li>首先，使用 Vue.extend()创建一个组件&#x2F;&#x2F; 创建.vue 文件</li><li>然后，使用 Vue.component()方法注册组件&#x2F;&#x2F;导入组件</li><li>接着，如果子组件需要数据，可以在 props 中接受定义</li><li>最后，子组件修改好数据之后，想把数据传递给父组件，可以使用 emit()方法</li></ol><h2 id="22-vue-过滤器"><a href="#22-vue-过滤器" class="headerlink" title="22. vue 过滤器"></a>22. vue 过滤器</h2><blockquote><p>vue3.0 中已经废弃了过滤器，可以使用计算属性或者方法代替</p></blockquote><ol><li>全局过滤器</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;filterName&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 过滤器的处理逻辑</span><br>  <span class="hljs-keyword">return</span> value<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="2"><li>局部过滤器</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-title function_">filterName</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 过滤器的处理逻辑</span><br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>{}&#x2F;v-bind 使用<!-- 在双花括号中 --></li></ol><!-- 在 `v-bind` 中 --><div v-bind:id="rawId | formatId"></div><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br><span class="hljs-comment">## 23. vue 强制刷新</span><br><br><span class="hljs-number">1.</span> 刷新当前页面<br><br>```<span class="language-javascript">js</span><br><span class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">go</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>()</span><br></code></pre></td></tr></table></figure><ol start="2"><li>v-if</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>强制刷新<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>刷新路由</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/refresh&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">t</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &#125; &#125;)<br></code></pre></td></tr></table></figure><h2 id="24-vue2-和-vue3-的区别"><a href="#24-vue2-和-vue3-的区别" class="headerlink" title="24. vue2 和 vue3 的区别"></a>24. vue2 和 vue3 的区别</h2><h3 id="1-双向数据绑定原理不同"><a href="#1-双向数据绑定原理不同" class="headerlink" title="1. 双向数据绑定原理不同"></a>1. 双向数据绑定原理不同</h3><blockquote><p>vue2：vue2 的双向数据绑定是利用 ES5 的一个 APIObject.definePropert() 对数据进行劫持，结合发布订阅模式的方式来实现的。</p></blockquote><blockquote><p>vue3：vue3 中使用了 ES6 的 Proxy API 对数据代理。相比 vue2.x，使用 proxy 的优势如下：</p></blockquote><ol><li>defineProperty 只能监听某个属性，不能对全对象监听</li><li>可以省去 for in，闭包等内容来提升效率(直接绑定整个对象即可)</li><li>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x 可以检测到数组内部数据的变化。</li></ol><h3 id="2-是否支持碎片-framents"><a href="#2-是否支持碎片-framents" class="headerlink" title="2.是否支持碎片(framents)"></a>2.是否支持碎片(framents)</h3><blockquote><p>vue2 不支持碎片。</p></blockquote><blockquote><p>vue3：vue3 支持碎片（Fragments） ，就是说可以拥有多个根节点。</p></blockquote><h3 id="3-API-类型不同-compositon-Api"><a href="#3-API-类型不同-compositon-Api" class="headerlink" title="3. API 类型不同 (compositon Api)"></a>3. API 类型不同 (compositon Api)</h3><blockquote><p>vue2：vue2 使用选项类型 api，选项型 api 在代码里分割了不同的属性：data,computed,methods 等。</p></blockquote><blockquote><p>vue3：vue3 使用合成型 api，新的合成型 api 能让我们使用方法来分割，相比于旧的 api 使用属性来分组，这样代码会更加简便和整洁。</p></blockquote><h3 id="4-声明周期钩子不同"><a href="#4-声明周期钩子不同" class="headerlink" title="4. 声明周期钩子不同"></a>4. 声明周期钩子不同</h3><table><thead><tr><th align="center">vue2</th><th align="center">vue3</th><th>vue</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center"></td><td></td></tr><tr><td align="center">created</td><td align="center"></td><td></td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td><td></td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td><td></td></tr><tr><td align="center">beforeUpdate</td><td align="center">onBeforeUpdate</td><td></td></tr><tr><td align="center">updated</td><td align="center">onUpdated</td><td></td></tr><tr><td align="center">beforeDestroy</td><td align="center">onBeforeUnmount</td><td></td></tr><tr><td align="center">destroyed</td><td align="center">onUnmounted</td><td></td></tr></tbody></table><h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><blockquote><p>Vue 3 提供了更好的 Tree-shaking 支持\更小的 bundle 大小\更快的更新速度、更好的 TypeScript 支持\更高效的虚拟 DOM 实现和编译优化。</p></blockquote><h3 id="6-异步组件（Suspense）"><a href="#6-异步组件（Suspense）" class="headerlink" title="6. 异步组件（Suspense）"></a>6. 异步组件（Suspense）</h3><p>Vue3 提供 Suspense 组件，允许程序在等待异步组件加载完成前渲染兜底的内容，如 loading ，使用户的体验更平滑。使用它，需在模板中声明，并包括两个命名插槽：default 和 fallback。Suspense 确保加载完异步内容时显示默认插槽，并将 fallback 插槽用作加载状态。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tempalte</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">suspense</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">List</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">fallback</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        Loading...      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">suspense</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="7-Teleport"><a href="#7-Teleport" class="headerlink" title="7.Teleport"></a>7.Teleport</h3><p>Vue3 提供 Teleport 组件可将部分 DOM 移动到 Vue app 之外的位置。比如项目中常见的 Dialog 弹窗。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;dialogVisible = true&quot;</span>&gt;</span>显示弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;dialogVisible&quot;</span>&gt;</span><br>    我是弹窗，我直接移动到了body标签下<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="25-vue3-的项目如何实现进一步的性能优化"><a href="#25-vue3-的项目如何实现进一步的性能优化" class="headerlink" title="25. vue3 的项目如何实现进一步的性能优化"></a>25. vue3 的项目如何实现进一步的性能优化</h2><ol><li><p>编码优化</p><ol><li>防抖、节流</li><li>路由懒加载、异步组件</li><li>组件复用和维护</li><li>key 值的使用</li><li>keep-alive 缓存组件</li></ol></li><li><p>加载缓存</p><ol><li>图片懒加载</li><li>按需加载</li><li>CDN 加速</li></ol></li><li><p>打包优化</p><ol><li>Gzip 压缩</li></ol></li></ol><h2 id="26-实现首屏加载优化"><a href="#26-实现首屏加载优化" class="headerlink" title="26. 实现首屏加载优化"></a>26. 实现首屏加载优化</h2><h3 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h3><ol><li>骨架屏&#x2F;loading</li></ol><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol><li>路由懒加载，异步组件，按需加载</li><li>图片懒加载，精灵图</li><li>CDN 加速，减少 js&#x2F;css 文件大小和 DOM 节点数量</li><li>Gzip 压缩</li></ol><h2 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h2><h2 id="nuxt-js"><a href="#nuxt-js" class="headerlink" title="nuxt.js"></a>nuxt.js</h2>]]></content>
    
    
    
    <tags>
      
      <tag>interview-vue+H5C3-3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-vue+H5C3-id2</title>
    <link href="/2024/02/16/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3-id2/"/>
    <url>/2024/02/16/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3-id2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-Vue-H5C3-id2"><a href="#🍭-面试-Vue-H5C3-id2" class="headerlink" title="🍭 面试-Vue+H5C3-id2"></a>🍭 面试-Vue+H5C3-id2</h1><h2 id="11-axios-封装和-原理"><a href="#11-axios-封装和-原理" class="headerlink" title="11. axios 封装和(原理)"></a>11. axios 封装和(原理)</h2><blockquote><p>Axios 是一个基于 Promise 的 HTTP 库，可以用于浏览器和 Node.js 环境中发送 HTTP 请求。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>支持 Promise API，可以轻易地执行所有类似于 then() 以及 catch() 方法的异步操作；</li><li>具有可取消的请求功能；</li><li>可以拦截请求和响应；</li><li>支持浏览器和 Node.js。</li><li>自动转换 JSON 数据、CSRF 保护等功能。</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入 Axios</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 发送 GET 请求</span><br>axios<br>  .<span class="hljs-title function_">get</span>(<br>    <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>,<br>    &#123;<br>      <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">_limit</span>: <span class="hljs-number">5</span>,<br>      &#125;,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>      &#125;,<br>    &#125;<br>  )<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error fetching data:&#x27;</span>, error)<br>  &#125;)<br><br><span class="hljs-comment">// 发送 POST 请求</span><br>axios<br>  .<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>, &#123;<br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>    <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">userId</span>: <span class="hljs-number">1</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>)<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error posting data:&#x27;</span>, error)<br>  &#125;)<br><span class="hljs-comment">// PUT\DELETE 请求同理</span><br></code></pre></td></tr></table></figure><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>封装 axios 实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// axiosInstance.js</span><br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 创建一个 Axios 实例</span><br><span class="hljs-keyword">const</span> axiosInstance = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>, <span class="hljs-comment">// 设置基础 URL</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-comment">// 设置超时时间</span><br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>, <span class="hljs-comment">// 设置请求头</span><br>  &#125;,<br>&#125;)<br><br><span class="hljs-comment">// 请求拦截器</span><br>axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 在请求发送之前做一些处理，比如添加 token 等</span><br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-comment">// 响应拦截器</span><br>axiosInstance.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对响应数据做些什么</span><br>    <span class="hljs-keyword">return</span> response<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对响应错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> axiosInstance<br></code></pre></td></tr></table></figure><ol start="2"><li>二次封装</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api.js</span><br><br><span class="hljs-keyword">import</span> axiosInstance <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./axiosInstance&#x27;</span><br><br><span class="hljs-comment">// 封装 GET 请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getPosts</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axiosInstance.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 封装 POST 请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createPost</span> = (<span class="hljs-params">postData</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> axiosInstance.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/posts&#x27;</span>, postData)<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">createDelete</span> = (<span class="hljs-params">ids</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">axiosInstance</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/member/cart&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      ids,<br>    &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="axios-的-原理"><a href="#axios-的-原理" class="headerlink" title="axios 的(原理)"></a>axios 的(原理)</h3><blockquote><p>Axios 的底层实现使用了 XMLHttpRequest 对象，它将请求数据包装在一个 Promise 中，并发送网络请求。Axios 还提供了一个拦截器（interceptor），允许在请求或响应被处理前、或者响应被 reject 前截获它们。</p></blockquote><h4 id="Axios-主要使用了以下技术来实现："><a href="#Axios-主要使用了以下技术来实现：" class="headerlink" title="Axios 主要使用了以下技术来实现："></a>Axios 主要使用了以下技术来实现：</h4><ol><li>构造 XMLHttpRequest 对象</li><li>序列化参数</li><li>配置请求信息</li><li>监听 xhr 的变化，包括 XHR 自身状态变化，和 http 响应状态变化</li><li>对响应数据进行处理和解析</li></ol><p>Axios 对 XHR 进行了两层封装，第一层封装屏蔽了 XHR 对象差异，提供了统一的 API；<br><br>第二层封装是基于 Promise 对象，让 HTTP 请求异步执行。<br></p><h2 id="12-vue-路由怎么传参"><a href="#12-vue-路由怎么传参" class="headerlink" title="12. vue 路由怎么传参"></a>12. vue 路由怎么传参</h2><h3 id="vue-几个路由"><a href="#vue-几个路由" class="headerlink" title="vue 几个路由"></a>vue 几个路由</h3><ol><li>route（路由）：<br>route 指的是单个路由对象，它代表着当前路由的状态信息，包括路径、参数、查询参数、路由元信息等。<br>在 Vue Router 中，route 对象由 this.$route 访问，或者在组件内部通过 $route 访问。</li><li>routes（路由配置）：<br>routes 是路由的配置信息，它是一个数组，包含了应用中所有路由的定义。<br>每个路由对象包括了路径、组件、路由元信息等信息。<br>在 Vue Router 中，routes 是在创建路由器时传递给它的一个配置项，用于定义整个应用的路由结构。</li><li>router（路由器）：<br>router 是 Vue Router 的核心实例，它管理着应用中的所有路由信息。<br>router 实例通过创建 Vue 实例时传递给它的 router 配置项创建。<br>router 实例提供了一些重要的方法和属性，如路由导航、路由信息访问等。</li></ol><h3 id="params-传参"><a href="#params-传参" class="headerlink" title="params 传参"></a>params 传参</h3><ol><li>声明式 router-link</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由配置</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span><br>    &#125;<br>  ]<br>&#125;)<br><br>&lt;router-link :to=<span class="hljs-string">&quot;/user/123&quot;</span>&gt;<span class="hljs-title class_">User</span>&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>编程式 this.$router.push</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//子路由配置</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>    &#125;,<br>  ],<br>&#125;)<br><span class="hljs-comment">//父路由编程式传参(一般通过事件触发)</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>  <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/$&#123;id&#125;&#x27;</span>,<br>&#125;)<br><span class="hljs-comment">//子路由接收参数</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span><br></code></pre></td></tr></table></figure><h3 id="query-传参"><a href="#query-传参" class="headerlink" title="query 传参"></a>query 传参</h3><ol><li>声明式 router-link</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span><br>    &#125;<br>  ]<br>&#125;)<br><span class="hljs-comment">//父路由组件</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123;name:&#x27;User&#x27;,query:&#123;id:123&#125;&#125;&quot;</span>&gt;进入<span class="hljs-title class_">User</span>路由&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>编程式 this.$router.push</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>    &#125;,<br>  ],<br>&#125;)<br><span class="hljs-comment">//父路由组件</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>  <span class="hljs-attr">query</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">123</span>,<br>  &#125;,<br>&#125;)<br><span class="hljs-comment">//子路由组件</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">query</span>.<span class="hljs-property">id</span><br></code></pre></td></tr></table></figure><h2 id="13-vue-的-hash-模式和-history-模式的区别"><a href="#13-vue-的-hash-模式和-history-模式的区别" class="headerlink" title="13. vue 的 hash 模式和 history 模式的区别"></a>13. vue 的 hash 模式和 history 模式的区别</h2><ol><li><p>URL 格式不同</p><blockquote><p>hash 模式 url 带#号，history 模式不带#号。</p></blockquote><ul><li>hash 模式：<a href="http://www.xxx.com/#/user/id">http://www.xxx.com/#/user/id</a></li><li>history 模式：<a href="http://www.xxx.com/user/id">http://www.xxx.com/user/id</a></li></ul></li><li><p>URL 导航方式不同</p><blockquote><p>Hash 模式使用 URL 的哈希部分来进行路由导航，而 History 模式使用 HTML5 History API。</p></blockquote><ul><li>hash 模式：通过 hashchange 事件监听 URL 的变化</li><li>history 模式：通过 popstate 事件监听 URL 的变化</li></ul></li><li><p>URL 切换时是否会向服务器发送请求</p><blockquote><p>hash 模式不会向服务器发送请求，history 模式会向服务器发送请求。</p></blockquote><ul><li>hash 模式：不会向服务器发送请求</li><li>history 模式：会向服务器发送请求</li></ul></li></ol><h2 id="14-vue-router-的路由拦截"><a href="#14-vue-router-的路由拦截" class="headerlink" title="14. vue-router 的路由拦截"></a>14. vue-router 的路由拦截</h2><h3 id="1-axios-拦截"><a href="#1-axios-拦截" class="headerlink" title="1. axios 拦截"></a>1. axios 拦截</h3><blockquote><p>Axios 提供了 interceptors 属性，它包含了 request 和 response 两个对象，分别用于请求拦截和响应拦截。我们可以通过给这两个对象添加拦截器函数来实现请求和响应的拦截。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">&#x27;Bearer &#x27;</span> + <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 对响应数据做点什么</span><br>    <span class="hljs-keyword">return</span> response<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br></code></pre></td></tr></table></figure><h3 id="2-Vue-Router-的-beforeEach-导航守卫："><a href="#2-Vue-Router-的-beforeEach-导航守卫：" class="headerlink" title="2. Vue Router 的 beforeEach 导航守卫："></a>2. Vue Router 的 beforeEach 导航守卫：</h3><blockquote><p>Vue Router 提供了 beforeEach 导航守卫，它可以在路由导航之前执行一些操作，比如检查权限、重定向等。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">// 路由配置</span><br>  ],<br>&#125;)<br><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在路由导航之前执行的操作</span><br>  <span class="hljs-keyword">const</span> isAuthenticated = <span class="hljs-title function_">checkAuth</span>() <span class="hljs-comment">// 检查用户是否登录</span><br>  <span class="hljs-keyword">if</span> (to.<span class="hljs-property">meta</span>.<span class="hljs-property">requiresAuth</span> &amp;&amp; !isAuthenticated) &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-string">&#x27;/login&#x27;</span>) <span class="hljs-comment">// 如果需要登录权限而用户未登录，则重定向到登录页</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">next</span>() <span class="hljs-comment">// 否则放行</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="15-vue-的动态路由"><a href="#15-vue-的动态路由" class="headerlink" title="15. vue 的动态路由()"></a>15. vue 的动态路由()</h2><blockquote><p>Vue Router 中的动态路由是指在路由路径中包含参数，这些参数的值是动态变化的，而不是固定的字符串。通过动态路由，我们可以实现根据不同的参数值加载不同的路由组件，从而实现更灵活的路由配置和页面展示。</p></blockquote><h2 id="16-解决刷新后二次加载路由的问题"><a href="#16-解决刷新后二次加载路由的问题" class="headerlink" title="16. 解决刷新后二次加载路由的问题"></a>16. 解决刷新后二次加载路由的问题</h2><h3 id="1-使用-history-模式"><a href="#1-使用-history-模式" class="headerlink" title="1. 使用 history 模式"></a>1. 使用 history 模式</h3><blockquote><p>在 History 模式下，浏览器会认为每次路径变化都是向服务器请求新的资源，因此在刷新页面时会向服务器发送请求</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  <span class="hljs-attr">routes</span>: [...]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-window-location-reload"><a href="#2-window-location-reload" class="headerlink" title="2. window.location.reload()"></a>2. window.location.reload()</h3><p>window.location.reload() 是用于在浏览器中刷新当前页面的 JavaScript 方法。当这个方法被调用时，浏览器会完全重新加载当前页面，可能会导致所有客户端 JavaScript 变量和 DOM 都被重置。</p><h3 id="3-matcher"><a href="#3-matcher" class="headerlink" title="3. matcher"></a>3. matcher</h3><blockquote><p>在 Vue Router 中，matcher 是一个用于匹配路由的对象，它包含了路由的配置信息，以及一些用于匹配路由的方法。我们可以通过调用 matcher 的 addRoutes 方法来动态添加路由配置，从而实现动态路由的加载。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRouter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> newRouter = <span class="hljs-title function_">createRouter</span>()<br>  router.<span class="hljs-property">matcher</span> = newRouter.<span class="hljs-property">matcher</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17-vue-中-computed-和-watch-的区别"><a href="#17-vue-中-computed-和-watch-的区别" class="headerlink" title="17. vue 中 computed 和 watch 的区别"></a>17. vue 中 computed 和 watch 的区别</h2><ol><li><p>computed</p><blockquote><p>computed 是计算属性，它的值是由计算得来的，它依赖于其他属性的值，并且当依赖的属性值发生变化时，它会重新计算得到新的值。</p></blockquote><ul><li>computed 支持缓存，不支持异步</li><li>computed 第一次调用时会执行一次，之后只有在依赖的属性发生变化时才会重新计算</li></ul></li><li><p>watch</p><blockquote><p>watch 是一个监听器，它用于监听某个属性的变化，当属性的值发生变化时，它会执行相应的回调函数。</p></blockquote><ul><li>watch 支持异步，不支持缓存</li><li>watch 监听的属性发生变化时，会执行回调函数</li><li>watch 监听多个属性时，可以通过 immediate 选项来指定是否在组件创建时立即执行回调函数</li></ul></li></ol><h2 id="18-vue-数据的双向绑定原理"><a href="#18-vue-数据的双向绑定原理" class="headerlink" title="18. vue 数据的双向绑定原理"></a>18. vue 数据的双向绑定原理</h2><blockquote><p>Vue 数据双向绑定原理是通过 数据劫持 + 发布者-订阅者模式 的方式来实现的，首先是通过 ES5 提供的 Object.defineProperty() 方法来劫持（监听）各属性的 getter、setter，并在当监听的属性发生变动时通知订阅者，是否需要更新，若更新就会执行对应的更新函数。</p></blockquote><h3 id="Vue-中的双向绑定流程是什么的"><a href="#Vue-中的双向绑定流程是什么的" class="headerlink" title="Vue 中的双向绑定流程是什么的"></a>Vue 中的双向绑定流程是什么的</h3><ol><li>new Vue()首先执行初始化，对 data 执行响应化处理，这个过程发生 Observe 中</li><li>同时对模板执行编译，找到其中动态绑定的数据，从 data 中获取并初始化视图，这个过程发生在 Compile 中</li><li>同时定义⼀个更新函数和 Watcher，将来对应数据变化时 Watcher 会调用更新函数</li><li>由于 data 的某个 key 在⼀个视图中可能出现多次，所以每个 key 都需要⼀个管家 Dep 来管理多个 Watcher</li><li>将来 data 中数据⼀旦发生变化，会首先找到对应的 Dep，通知所有 Watcher 执行更新函数</li></ol><h3 id="Vue-中的双向绑定原理"><a href="#Vue-中的双向绑定原理" class="headerlink" title="Vue 中的双向绑定原理"></a>Vue 中的双向绑定原理</h3><ol><li>先来一个构造函数：执行初始化，对 data 执行响应化处理\对 data 选项执行响应化具体操作</li><li>编译 Compile<br>对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数</li><li>依赖收集<br>视图中会用到 data 中某 key，这称为依赖。同⼀个 key 可能出现多次，每次都需要收集出来用⼀个 Watcher 来维护它们，此过程称为依赖收集多个 Watcher 需要⼀个 Dep 来管理，需要更新时由 Dep 统⼀通知<ol><li>实现思路</li></ol><ul><li>defineReactive 时为每⼀个 key 创建⼀个 Dep 实例</li><li>初始化视图时读取某个 key，例如 name1，创建⼀个 watcher1</li><li>由于触发 name1 的 getter 方法，便将 watcher1 添加到 name1 对应的 Dep 中</li><li>当 name1 更新，setter 触发时，便可通过对应 Dep 通知其管理所有 Watcher 更新</li></ul></li></ol><h2 id="19-vuex-响应式处理"><a href="#19-vuex-响应式处理" class="headerlink" title="19. vuex 响应式处理"></a>19. vuex 响应式处理</h2><blockquote><p>我们在 Vuex 中修改状态时，需要使用 commit 方法来触发对应的 mutations，而 mutations 中的函数会被同步地调用来修改状态。由于 Vue 的响应式系统会监听状态的变化，一旦状态发生改变，依赖于该状态的组件就会自动更新。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js</span><br><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; createPinia &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br><span class="hljs-keyword">const</span> pinia = <span class="hljs-title function_">createPinia</span>()<br><br>app.<span class="hljs-title function_">use</span>(pinia)<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// store/index.js</span><br><br><span class="hljs-keyword">import</span> &#123; defineStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pinia&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useCounterStore = <span class="hljs-title function_">defineStore</span>(&#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;counter&#x27;</span>,<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  &#125;),<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">asyncIncrement</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>))<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">increment</span>()<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params">state</span>) &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++<br>    &#125;,<br>    <span class="hljs-title function_">decrement</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>--<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- Counter.vue --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;asyncIncrement&quot;</span>&gt;</span>Async Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useCounterStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useCounterStore</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> count = store.<span class="hljs-property">count</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> doubleCount = store.<span class="hljs-property">doubleCount</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> increment = store.<span class="hljs-property">increment</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> asyncIncrement = store.<span class="hljs-property">asyncIncrement</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="20-搭建-vue-脚手架"><a href="#20-搭建-vue-脚手架" class="headerlink" title="20.搭建 vue 脚手架"></a>20.搭建 vue 脚手架</h2><h3 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h3><ol><li>安装 node</li><li>安装 vue-cli</li><li>vue create 项目名</li><li>选择配置</li><li>cd 项目名</li><li>npm run serve</li></ol><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><ol><li>安装 node</li><li>npm init vite@latest 项目名</li><li>选择配置</li><li>cd 项目名</li><li>npm install</li><li>npm run dev</li></ol><h3 id="https-juejin-cn-post-7099381863101235213"><a href="#https-juejin-cn-post-7099381863101235213" class="headerlink" title="https://juejin.cn/post/7099381863101235213"></a><strong><a href="https://juejin.cn/post/7099381863101235213">https://juejin.cn/post/7099381863101235213</a></strong></h3><ol><li>安装启动 vite</li><li>修改 vite.config.js</li><li>安装 vue-router</li><li>集成 Stylus&#x2F;Sass&#x2F;Less</li><li>集成 element-plus</li><li>集成封装 axios</li><li>安装 pinia</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>interview-vue+H5C3-2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-vue+H5C3</title>
    <link href="/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/"/>
    <url>/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-Vue-H5C3"><a href="#🍭-面试-Vue-H5C3" class="headerlink" title="🍭 面试-Vue+H5C3"></a>🍭 面试-Vue+H5C3</h1><h2 id="1-语义化的理解"><a href="#1-语义化的理解" class="headerlink" title="1. 语义化的理解"></a>1. 语义化的理解</h2><blockquote><p>语义化是指使用合适的 HTML 标签来描述文档结构和内容，使得页面结构和内容更加清晰、易读，并对搜索引擎和开发者友好。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 头部 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 导航栏 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 区块（有语义化的div） --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 主要区域 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 主要内容 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 侧边栏 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 底部 --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-1-语义化的优点"><a href="#1-1-语义化的优点" class="headerlink" title="1.1 语义化的优点"></a>1.1 语义化的优点</h3><ol><li>有利于搜索引擎优化</li><li>有利于开发者阅读和维护</li></ol><h2 id="2-H5C3-新特性"><a href="#2-H5C3-新特性" class="headerlink" title="2. H5C3 新特性"></a>2. H5C3 新特性</h2><h3 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h3><ol><li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li><li>音频、视频 API(audio,video)</li><li>画布(Canvas) API</li><li>数据存储 localStorage、sessionStorage</li><li>拖拽释放(Drag and drop) API</li><li>新的表单元素： 引入了新的表单元素，如<code>&lt;input&gt;</code>的 type 属性中的 email、url、tel 等，以及<code>&lt;datalist&gt;</code>元素，提供更丰富的表单功能。</li></ol><h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><ol start="0"><li>flex 和 grid 布局</li><li>新增选择器:属性选择器、伪类选择器、伪元素选择器</li><li>媒体查询： 允许根据设备的特性和屏幕尺寸来应用不同的样式，实现响应式设计。</li><li>阴影、边框: 提供了<code>box-shadow</code>和<code>border-radius</code>等属性，</li><li>盒模型: 提供了<code>box-sizing</code>属性，可以更好的控制盒模型。</li><li>渐变: 提供了<code>linear-gradient</code>和<code>radial-gradient</code>等属性，可以实现更丰富的渐变效果。</li><li>过渡和动画： 引入了过渡（transition）和动画（animation）属性，使得页面元素的状态变化更加平滑和具有动态效果。</li><li>背景: 提供了<code>background-size</code>、<code>background-origin</code>、<code>background-clip</code>等属性，可以更好的控制背景图片的显示效果。</li></ol><h2 id="3-rem-如何实现适配"><a href="#3-rem-如何实现适配" class="headerlink" title="3. rem 如何实现适配"></a>3. rem 如何实现适配</h2><blockquote><p>rem 是相对于根元素的字体大小(html&gt;font-size)的单位，通过设置根元素的字体大小，可以实现页面的适配。</p></blockquote><ol><li>rem 定义</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; //根元素字体大小，此时<span class="hljs-number">1rem</span> = <span class="hljs-number">16px</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>rem 适配<br>以电脑 1920px 设计宽度为例，根据实际屏幕宽度设置 html 根元素 font-size 大小<br>rem &#x3D; 屏幕宽度 &#x2F; 设计稿宽度(1920px) *100<br>若屏幕宽度为 1920px，即 1rem &#x3D; 100px，</li></ol><h2 id="4-v-if-和-v-show-的区别"><a href="#4-v-if-和-v-show-的区别" class="headerlink" title="4. v-if 和 v-show 的区别"></a>4. v-if 和 v-show 的区别</h2><h3 id="共同点：控制元素在页面是否显示"><a href="#共同点：控制元素在页面是否显示" class="headerlink" title="共同点：控制元素在页面是否显示"></a>共同点：控制元素在页面是否显示</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li><p>控制和编译：<br><br>v-show 只是简单的基于 css 切换、隐藏则是为该元素添加 css–display:none，dom 元素依旧还在。<br><br>v-if 显示隐藏是将 dom 元素整个添加或删除，v-if 切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</p></li><li><p>生命周期：<br><br>v-show 由 false 变为 true 的时候不会触发组件的生命周期<br><br>v-if 由 false 变为 true 的时候，触发组件的 beforeCreate、create、beforeMount、mounted 钩子，由 true 变为 false 的时候触发组件的 beforeDestory、destoryed 方法</p></li><li><p>性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗；</p></li></ol><h2 id="5-Vue"><a href="#5-Vue" class="headerlink" title="5. Vue"></a>5. Vue</h2><blockquote><p>创建用户界面的开源 JavaScript 框架，也是一个创建单页应用的 Web 应用框架</p></blockquote><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="数据驱动-MVVM"><a href="#数据驱动-MVVM" class="headerlink" title="数据驱动(MVVM)"></a>数据驱动(MVVM)</h4><ol><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为 UI 展示出来，可以简单的理解为 HTML 页面</li><li>ViewModel：视图模型层，用来连接 Model 和 View，是 Model 和 View 之间的通信桥梁</li></ol><ol><li>它有两个方向：一是将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图转化成模型，即将所看到的页面转化成后端的数据。</li><li>实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</li></ol><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><blockquote><p>在 Vue 中每一个.vue 文件都可以视为一个组件<br><strong>优点：</strong></p></blockquote><ol><li>降低整个系统的耦合度</li><li>提高可维护性</li></ol><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><ol><li>指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li></ol><h4 id="Vue-x2F-React"><a href="#Vue-x2F-React" class="headerlink" title="Vue&#x2F;React"></a>Vue&#x2F;React</h4><p><strong>相同点</strong></p><ol><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有 Virtual DOM（虚拟 dom）</li><li>数据驱动视图</li><li>都有支持 native 的方案：Vue 的 weex、React 的 React native</li><li>都有自己的构建工具：Vue 的 vue-cli、React 的 Create React App<br><strong>区别</strong></li><li>数据流向的不同。react 从诞生开始就推崇单向数据流，而 Vue 是双向数据流</li><li>数据变化的实现原理不同。react 使用的是不可变数据，而 Vue 使用的是可变的数据</li><li>组件化通信的不同。react 中我们通过使用回调函数来进行通信的，而 Vue 中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff 算法不同。react 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。Vue 使用双向指针，边对比，边更新 DOM</li></ol><h2 id="6-v-for-中的-key-是什么作用？"><a href="#6-v-for-中的-key-是什么作用？" class="headerlink" title="6. v-for 中的 key 是什么作用？"></a>6. v-for 中的 key 是什么作用？</h2><h3 id="官方的解释："><a href="#官方的解释：" class="headerlink" title="官方的解释："></a>官方的解释：</h3><ol><li><p>key 属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比（使用到 diff 算法）时辨识 VNodes；</p></li><li><p>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法；</p><img src="/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/diff0.png" class></li><li><p>而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除&#x2F;销毁 key 不存在的元素。</p></li></ol><h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><blockquote><p>diff 算法是一种通过同层的树节点进行比较的高效算法</p></blockquote><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li>比较只会在同层级进行, 不会跨层级比较</li><li>在 diff 比较的过程中，循环从两边向中间比较</li></ol><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><blockquote><p>当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图</p></blockquote><ol><li><p>patch 函数前两个参数位为 oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p><ol><li>没有新节点，直接触发旧节点的 destory 钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm</li><li>旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点，子节点不完全一致，则调用 updateChildren</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ol></li><li><p>patchVnode 主要做了几个判断：</p><ol><li>新节点是否是文本节点，如果是，则直接更新 dom 的文本内容为新节点的文本内容<br>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新 DOM，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把 DOM 删除</li></ol></li><li><p>子节点不完全一致，则调用 updateChildren</p><ol><li>当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1</li><li>当新老 VNode 节点的 end 相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1</li><li>当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1</li><li>当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<br>从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行 patchVnode，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面<br>调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置</li></ol></li></ol><h2 id="7-请描述下你对-vue-生命周期的理解"><a href="#7-请描述下你对-vue-生命周期的理解" class="headerlink" title="7. 请描述下你对 vue 生命周期的理解"></a>7. 请描述下你对 vue 生命周期的理解</h2><blockquote><p>Vue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期(activated:keep-alive 缓存的组件激活时<br>deactivated:keep-alive 缓存的组件停用时调用)</p></blockquote><ol><li>beforeCreate -&gt; created<br>初始化 vue 实例，进行数据观测</li><li>created<br>完成数据观测，属性与方法的运算，watch、event 事件回调的配置<br>可调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 dom，可通过 computed 和 watch 完成数据计算<br>此时 vm.$el 并没有被创建</li><li>created -&gt; beforeMount<br>判断是否存在 el 选项，若不存在则停止编译，直到调用 vm.$mount(el)才会继续编译<br>优先级：render &gt; template &gt; outerHTML<br>vm.el 获取到的是挂载 DOM 的</li><li>beforeMount<br>在此阶段可获取到 vm.el<br>此阶段 vm.el 虽已完成 DOM 初始化，但并未挂载在 el 选项上</li><li>beforeMount -&gt; mounted<br>此阶段 vm.el 完成挂载，vm.$el 生成的 DOM 替换了 el 选项所对应的 DOM</li><li>mounted<br>vm.el 已完成 DOM 的挂载与渲染，此刻打印 vm.$el，发现之前的挂载点及内容已被替换成新的 DOM</li><li>beforeUpdate<br>更新的数据必须是被渲染在模板上的（el、template、render 之一）<br>此时 view 层还未更新<br>若在 beforeUpdate 中再次修改数据，不会再次触发更新方法</li><li>updated<br>完成 view 层的更新<br>若在 updated 中再次修改数据，会再次触发更新方法（beforeUpdate、updated）</li><li>beforeDestroy<br>实例被销毁前调用，此时实例属性与方法仍可访问</li><li>destroyed<br>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器<br>并不能清除 DOM，仅仅销毁实例</li></ol><table><thead><tr><th align="center">生命周期</th><th align="center">描述</th><th align="right"></th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td><td align="right"></td></tr><tr><td align="center">created</td><td align="center">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td><td align="right"></td></tr><tr><td align="center">beforeMount</td><td align="center">未执行渲染、更新，dom 未创建</td><td align="right"></td></tr><tr><td align="center">mounted</td><td align="center">初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td><td align="right"></td></tr><tr><td align="center">beforeUpdate</td><td align="center">更新前，可用于获取更新前各种状态</td><td align="right"></td></tr><tr><td align="center">updated</td><td align="center">更新后，所有状态已是最新</td><td align="right"></td></tr><tr><td align="center">beforeDestroy</td><td align="center">销毁前，可用于一些定时器或订阅的取消</td><td align="right"></td></tr><tr><td align="center">destroyed</td><td align="center">组件已销毁，作用同上</td><td align="right"></td></tr></tbody></table><h3 id="题外话：数据请求在-created-和-mouted-的区别"><a href="#题外话：数据请求在-created-和-mouted-的区别" class="headerlink" title="题外话：数据请求在 created 和 mouted 的区别"></a>题外话：数据请求在 created 和 mouted 的区别</h3><p>created 是在组件实例一旦创建完成的时候立刻调用，这时候页面 dom 节点并未生成；<br><br>mounted 是在页面 dom 节点渲染完毕之后就立刻执行的。<br><br>两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在 mounted 中的请求有可能导致页面闪动（因为此时页面 dom 结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在 created 生命周期当中。</p><h2 id="8-Vue-常用的修饰符有哪些有什么应用场景"><a href="#8-Vue-常用的修饰符有哪些有什么应用场景" class="headerlink" title="8. Vue 常用的修饰符有哪些有什么应用场景"></a>8. Vue 常用的修饰符有哪些有什么应用场景</h2><blockquote><p>在 Vue 中，修饰符处理了许多 DOM 事件的细节:表单修饰符\事件修饰符\鼠标按键修饰符\键值修饰符\v-bind 修饰符</p></blockquote><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><ol><li>lazy<blockquote><p>在我们填完信息，光标离开标签的时候，才会将值赋予给 value，也就是在 change 事件之后再进行信息同步</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;</code></p><ol start="2"><li>trim<blockquote><p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;</code></p><ol start="3"><li>number<blockquote><p>自动将用户的输入值转为数值类型，但如果这个值无法被 parseFloat 解析，则会返回原来的值</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.number=&quot;value&quot;&gt;</code></p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ol><li>stop<blockquote><p>阻止了事件冒泡，相当于调用了 event.stopPropagation 方法</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>prevent<blockquote><p>阻止了事件的默认行为，相当于调用了 event.preventDefault 方法</p></blockquote></li></ol><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p><ol start="3"><li>self<blockquote><p>只当在 event.target 是当前元素自身时触发处理函数</p></blockquote></li></ol><p><code>&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code></p><ol start="4"><li>once<blockquote><p>绑定了事件以后只能触发一次，第二次就不会触发</p></blockquote></li></ol><p>&lt;button @click.once&#x3D;”shout(1)”&gt;ok</p><ol start="5"><li>capture<blockquote><p>使事件触发从包含这个元素的顶层开始往下触发</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;<br>    obj1<br>   &lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>         obj2<br>      &lt;div @click=<span class="hljs-string">&quot;shout(3)&quot;</span>&gt;<br>            obj3<br>            &lt;div @click=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;<br>               obj4<br>            &lt;/div&gt;<br>      &lt;/div&gt;<br>   &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>passive<blockquote><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发 onscroll 事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 onscroll 事件整了一个.lazy 修饰符</p></blockquote></li></ol><p><code>&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code></p><ol start="7"><li>native<blockquote><p>让组件变成像 html 内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</p></blockquote></li></ol><p><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></p><h3 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h3><blockquote><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p></blockquote><ol><li>left 左键点击</li><li>right 右键点击</li><li>middle 中键点击</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click.<span class="hljs-property">left</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.right</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.middle</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h3><blockquote><p>键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：</p></blockquote><ol><li>普通键（enter、tab、delete、space、esc、up…）</li><li>系统修饰键（ctrl、alt、meta、shift…）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只有按键为keyCode的时候才触发</span><br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> @keyup.<span class="hljs-property">keyCode</span>=<span class="hljs-string">&quot;shout()&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="v-bind-修饰符"><a href="#v-bind-修饰符" class="headerlink" title="v-bind 修饰符"></a>v-bind 修饰符</h3><ol><li>sync<blockquote><p>能对 props 进行一个双向绑定</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父组件</span><br>&lt;comp :myMessage.<span class="hljs-property">sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br><br><span class="hljs-comment">//父亲组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">:myMessage</span>=<span class="hljs-string">&quot;bar&quot;</span> @<span class="hljs-attr">update:myMessage</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span></span><br><span class="hljs-title function_">func</span>(<span class="hljs-params">e</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = e;<br>&#125;<br><span class="hljs-comment">//子组件js</span><br><span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>使用 sync 的时候，子组件传递的事件名格式必须为 update:value，其中 value 必须与子组件中 props 中声明的名称完全一致.</li><li>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync&#x3D;”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</li><li>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync&#x3D;”{ title: doc.title }”，是无法正常工作的.</li></ol><ol start="2"><li>props<blockquote><p>设置自定义标签属性，避免暴露数据，防止污染 HTML 结构</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input id=<span class="hljs-string">&quot;uid&quot;</span> title=<span class="hljs-string">&quot;title1&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span> :index.<span class="hljs-property">prop</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>camel<blockquote><p>将命名变为驼峰命名法，如将 view-Box 属性名转换为 viewBox</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;svg :viewBox=<span class="hljs-string">&quot;viewBox&quot;</span>&gt;&lt;/svg&gt;<br></code></pre></td></tr></table></figure><h2 id="9-Vue-组件间通信有哪些方式"><a href="#9-Vue-组件间通信有哪些方式" class="headerlink" title="9. Vue 组件间通信有哪些方式"></a>9. Vue 组件间通信有哪些方式</h2><h3 id="父子组件之间的通信"><a href="#父子组件之间的通信" class="headerlink" title="父子组件之间的通信"></a>父子组件之间的通信</h3><h4 id="props-传递数据"><a href="#props-传递数据" class="headerlink" title="props 传递数据"></a>props 传递数据</h4><blockquote><p>父组件通过 props 向子组件传递数据，子组件通过 props 接收数据</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件</span><br><span class="hljs-attr">props</span>:&#123;<br>    <span class="hljs-comment">// 字符串形式</span><br>   <span class="hljs-attr">name</span>:<span class="hljs-title class_">String</span>, <span class="hljs-comment">// 接收的类型参数</span><br>   <span class="hljs-comment">// 对象形式</span><br>   <span class="hljs-attr">age</span>:&#123;<br>      <span class="hljs-attr">type</span>:<span class="hljs-title class_">Number</span>, <span class="hljs-comment">// 接收的类型为数值</span><br>      <span class="hljs-attr">defaule</span>:<span class="hljs-number">18</span>,  <span class="hljs-comment">// 默认值为18</span><br>      <span class="hljs-attr">require</span>:<span class="hljs-literal">true</span> <span class="hljs-comment">// age属性必须传递</span><br>   &#125;<br>&#125;<br><br><span class="hljs-comment">// 父组件</span><br>&lt;child :name=<span class="hljs-string">&quot;name&quot;</span> :age=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/child&gt;<br></code></pre></td></tr></table></figure><h4 id="emit-触发自定义事件"><a href="#emit-触发自定义事件" class="headerlink" title="$emit 触发自定义事件"></a>$emit 触发自定义事件</h4><blockquote><p>子组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;父组件绑定监听器获取到子组件传递过来的参数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Chilfen.vue</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;add&#x27;</span>, good)<br><br><span class="hljs-comment">// Father.vue</span><br>&lt;<span class="hljs-title class_">Children</span> @add=<span class="hljs-string">&quot;cartAdd($event)&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h4 id="ref-获取子组件实例"><a href="#ref-获取子组件实例" class="headerlink" title="ref 获取子组件实例"></a>ref 获取子组件实例</h4><blockquote><p>父组件在使用子组件的时候设置 ref;父组件通过设置子组件 ref 来获取数据</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;childRef&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;callChildMethod&quot;</span>&gt;</span>Call Child Method<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">callChildMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    childRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">childMethod</span>();</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  &lt;!-- <span class="hljs-title class_">ChildComponent</span>.<span class="hljs-property">vue</span> --&gt;</span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">      Child Component</span></span><br><span class="language-xml"><span class="language-javascript">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-javascript">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">childMethod</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Method called from parent&#x27;</span>);</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript">  &#125;;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h3><h4 id="EventBus-中央事件总线"><a href="#EventBus-中央事件总线" class="headerlink" title="EventBus 中央事件总线"></a>EventBus 中央事件总线</h4><blockquote><p>创建一个中央事件总线 EventBus;兄弟组件通过$emit触发自定义事件，$emit 第二个参数为传递的数值;另一个兄弟组件通过$on 监听自定义事件</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//main.js</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>() <span class="hljs-comment">// Vue已经实现了Bus的功能</span><br><br><span class="hljs-comment">//Children1.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessage</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-comment">// 触发事件</span></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$emit(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from EventBus!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-comment">// Children2.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听事件</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$bus</span>.$on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// Output: Hello from EventBus!</span></span></span><br><span class="language-javascript"><span class="language-xml">&#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h4 id="parent-或-root"><a href="#parent-或-root" class="headerlink" title="$parent 或$root"></a>$parent 或$root</h4><blockquote><p>通过共同祖辈$parent或者$root 搭建通信桥连</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// &lt;!-- ParentComponent.vue --&gt;</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessageToChild</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  $parent.$emit(<span class="hljs-string">&#x27;messageToChild&#x27;</span>, <span class="hljs-string">&#x27;Hello from Parent!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">sendMessageToRoot</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  $root.$emit(<span class="hljs-string">&#x27;messageToRoot&#x27;</span>, <span class="hljs-string">&#x27;Hello from Parent!&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">&#123;<span class="hljs-comment">/* &lt;!-- ChildComponent.vue --&gt; */</span>&#125;</span></span><br><span class="language-javascript"><span class="language-xml">&lt;template&gt;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">    Child Component</span></span></span><br><span class="language-xml"><span class="language-javascript"><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></span></span><br><span class="language-javascript"><span class="language-xml">&lt;/template&gt;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听来自父组件的事件</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">$parent.$on(<span class="hljs-string">&#x27;messageToChild&#x27;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// Output: Hello from Parent!</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml"></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 监听来自根组件的事件</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">$root.$on(<span class="hljs-string">&#x27;messageToRoot&#x27;</span>, <span class="hljs-function"><span class="hljs-params">message</span> =&gt;</span> &#123;</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// Output: Hello from Parent!</span></span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml">&#125;);</span></span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="language-javascript"><span class="language-xml"></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br></code></pre></td></tr></table></figure><h3 id="祖孙与后代组件之间的通信"><a href="#祖孙与后代组件之间的通信" class="headerlink" title="祖孙与后代组件之间的通信"></a>祖孙与后代组件之间的通信</h3><h4 id="attrs-与-listeners"><a href="#attrs-与-listeners" class="headerlink" title="$attrs 与$listeners"></a>$attrs 与$listeners</h4><p>设置批量向下传属性$attrs和 $listeners<br>包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。<br>可以通过 v-bind&#x3D;”$attrs” 传⼊内部组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// child：并未在props中声明foo</span><br>&lt;p&gt;&#123;&#123;$attrs.<span class="hljs-property">foo</span>&#125;&#125;&lt;/p&gt;<br><br><span class="hljs-comment">// parent</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;foo&quot;</span>/&gt;</span></span><br><span class="hljs-comment">// 给Grandson隔代传值，communication/index.vue</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;lalala&quot;</span> @<span class="hljs-attr">some-event</span>=<span class="hljs-string">&quot;onSomeEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child2</span>&gt;</span></span><br><br><span class="hljs-comment">// Child2做展开</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Grandson</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Grandson</span>&gt;</span></span><br><br><span class="hljs-comment">// Grandson使⽤</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span></span><br><span class="language-xml">&#123;&#123;msg&#125;&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><blockquote><p>在祖先组件定义 provide 属性，返回传递的值;在后代组件通过 inject 接收组件传递过来的值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 祖先组件</span><br><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">foo</span>:<span class="hljs-string">&#x27;foo&#x27;</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 后代组件</span><br><span class="hljs-attr">inject</span>:[<span class="hljs-string">&#x27;foo&#x27;</span>] <span class="hljs-comment">// 获取到祖先组件传递过来的值</span><br></code></pre></td></tr></table></figure><h3 id="非关系组件间之间的通信"><a href="#非关系组件间之间的通信" class="headerlink" title="非关系组件间之间的通信"></a>非关系组件间之间的通信</h3><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ol><li>state 用来存放共享变量的地方</li><li>getter，可以增加一个 getter 派生状态，(相当于 store 中的计算属性），用来获得共享变量的值</li><li>mutations 用来存放修改 state 的方法。</li><li>actions 也是用来存放修改 state 的方法，不过 action 是在 mutations 的基础上进行。常用来做一些异步操作</li></ol><h2 id="10-keep-alive-的作用"><a href="#10-keep-alive-的作用" class="headerlink" title="10. keep-alive 的作用"></a>10. keep-alive 的作用</h2><blockquote><p>keep-alive 是 vue 中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染 DOM;keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p></blockquote><h3 id="keep-alive-可以设置以下-props-属性："><a href="#keep-alive-可以设置以下-props-属性：" class="headerlink" title="keep-alive 可以设置以下 props 属性："></a>keep-alive 可以设置以下 props 属性：</h3><ol><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存</li><li>max - 数字。最多可以缓存多少组件实例</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;keep-alive&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br>&lt;/keep-alive&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><br>&lt;!-- 正则表达式 (使用 <span class="hljs-string">`v-bind`</span>) --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><br>&lt;!-- 数组 (使用 <span class="hljs-string">`v-bind`</span>) --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span></span><br><br><span class="hljs-comment">// 在路由中设置keepAlive属性判断是否需要缓存</span><br>&#123;<br>   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;list&#x27;</span>,<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;itemList&#x27;</span>, <span class="hljs-comment">// 列表页</span><br>   component (resolve) &#123;<br>      <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;@/pages/item/list&#x27;</span>], resolve)<br>   &#125;,<br>   <span class="hljs-attr">meta</span>: &#123;<br>      <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;列表页&#x27;</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="keep-alive-的原理"><a href="#keep-alive-的原理" class="headerlink" title="keep-alive 的原理"></a>keep-alive 的原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>,<br><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],<br>    <span class="hljs-attr">exclude</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],<br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>  &#125;,<br><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []<br>  &#125;,<br><br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<br>      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>  &#125;,<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* 获取默认插槽中的第一个组件节点 */</span><br>    <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span><br>    <span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">getFirstComponentChild</span>(slot)<br>    <span class="hljs-comment">/* 获取该组件节点的componentOptions */</span><br>    <span class="hljs-keyword">const</span> componentOptions = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span><br><br>    <span class="hljs-keyword">if</span> (componentOptions) &#123;<br>      <span class="hljs-comment">/* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */</span><br>      <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">getComponentName</span>(componentOptions)<br><br>      <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span><br>      <span class="hljs-comment">/* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */</span><br>      <span class="hljs-keyword">if</span> (<br>        (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) ||<br>        <span class="hljs-comment">// excluded</span><br>        (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>      ) &#123;<br>        <span class="hljs-keyword">return</span> vnode<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span><br>      <span class="hljs-comment">/* 获取组件的key值 */</span><br>      <span class="hljs-keyword">const</span> key =<br>        vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span><br>          ? <span class="hljs-comment">// same constructor may get registered as different local components</span><br>            <span class="hljs-comment">// so cid alone is not enough (#3269)</span><br>            componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> +<br>            (componentOptions.<span class="hljs-property">tag</span> ? <span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>)<br>          : vnode.<span class="hljs-property">key</span><br>      <span class="hljs-comment">/*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */</span><br>      <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>        vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span><br>        <span class="hljs-comment">// make current key freshest</span><br>        <span class="hljs-title function_">remove</span>(keys, key)<br>        keys.<span class="hljs-title function_">push</span>(key)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* 如果没有命中缓存，则将其设置进缓存 */</span><br>        cache[key] = vnode<br>        keys.<span class="hljs-title function_">push</span>(key)<br>        <span class="hljs-comment">// prune oldest entry</span><br>        <span class="hljs-comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>          <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>)<br>        &#125;<br>      &#125;<br><br>      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>])<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>在组件渲染的时候会自动执行 render 函数;this.cache 是一个对象，用来存储需要缓存的组件</li><li>在组件销毁的时候执行 pruneCacheEntry 函数</li><li>在 mounted 钩子函数中观测 include 和 exclude 的变化，如下：</li><li>如果 include 或 exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行 pruneCache 函数</li></ol><h3 id="关于-keep-alive-的最强大缓存功能是在-render-函数中实现"><a href="#关于-keep-alive-的最强大缓存功能是在-render-函数中实现" class="headerlink" title="关于 keep-alive 的最强大缓存功能是在 render 函数中实现"></a>关于 keep-alive 的最强大缓存功能是在 render 函数中实现</h3><ol><li>首先获取组件的 key 值：</li><li>拿到 key 值后去 this.cache 对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存</li><li>直接从缓存中拿 vnode 的组件实例，此时重新调整该组件 key 的顺序，将其从原来的地方删掉并重新放在 this.keys 中最后一个</li><li>this.cache 对象中没有该 key 值的情况，表明该组件还没有被缓存过，则以该组件的 key 为键，组件 vnode 为值，将其存入 this.cache 中，并且把 key 存入 this.keys 中</li><li>此时再判断 this.keys 中缓存组件的数量是否超过了设置的最大缓存数量值 this.max，如果超过了，则把第一个缓存组件删掉</li></ol><h3 id="缓存后如何获取数据"><a href="#缓存后如何获取数据" class="headerlink" title="缓存后如何获取数据"></a>缓存后如何获取数据</h3><ol><li>beforeRouteEnter<br>每次组件渲染的时候，都会执行 beforeRouteEnter</li><li>actived<br>在 keep-alive 缓存的组件被激活的时候，都会执行 actived 钩子</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>interview-vue+H5C3-1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-js-2</title>
    <link href="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/"/>
    <url>/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-js"><a href="#🍭-面试-js" class="headerlink" title="🍭 面试-js"></a>🍭 面试-js</h1><h2 id="1-ajax-是什么？怎么实现的？有什么优缺点？-fetch-和-xmlhttprequest"><a href="#1-ajax-是什么？怎么实现的？有什么优缺点？-fetch-和-xmlhttprequest" class="headerlink" title="1.ajax 是什么？怎么实现的？有什么优缺点？(fetch 和 xmlhttprequest)"></a>1.ajax 是什么？怎么实现的？有什么优缺点？(fetch 和 xmlhttprequest)</h2><blockquote><p>AJAX（Asynchronous JavaScript and XML）是一种用于在浏览器和服务器之间进行异步数据交互的技术。它允许在不重新加载整个页面的情况下，通过在后台与服务器进行数据交换，更新部分页面内容。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>创建 ajax 对象（XMLHttpRequest&#x2F;ActiveXObject(Microsoft.XMLHttp)）</li><li>用 open()方法设置请求方式和请求地址连接服务器</li><li>用 send()方法发送请求</li><li>当 ajax 对象完成第四步（onreadystatechange）数据接收完成，判断 http 响应状态（status）200-300 之间或者 304（缓存）执行回调函数</li><li>通过 ajax 对象的 responseText 属性获取服务器返回的数据</li><li>处理数据更新页面</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>  &#125;<br>&#125;<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>)<br>xhr.<span class="hljs-title function_">send</span>()<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>异步通信： AJAX 支持异步通信，可以在不阻塞页面的情况下向服务器发起请求。</li><li>局部更新： 可以通过局部更新页面内容，而无需重新加载整个页面，提高用户体验。</li><li>减少带宽消耗： 只传输需要的数据，减少了不必要的带宽消耗。</li></ol><p><strong>缺点：</strong></p><ol><li>浏览器兼容性： 早期浏览器对 AJAX 的支持不一致，但随着现代浏览器的普及，这个问题逐渐减轻。</li><li>SEO 难度： 搜索引擎对于 AJAX 加载的内容的索引和处理相对复杂，可能影响搜索引擎优化。</li><li>安全性： 由于跨域请求的安全性问题，存在一些安全风险，需要注意跨站请求伪造（CSRF）等攻击。</li></ol><h2 id="2-get-和-post-的区别"><a href="#2-get-和-post-的区别" class="headerlink" title="2. get 和 post 的区别"></a>2. get 和 post 的区别</h2><blockquote><p>GET 用于从服务器获取数据<br><br>POST 用于向服务器提交数据</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>数据方面</strong></p><ol><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li></ol><p><strong>安全方面</strong></p><ol><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>POST 参数不会被保存在浏览器历史或 web 服务器日志中。</li></ol><p><strong>缓存方面</strong></p><ol><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li></ol><h2 id="3-promise-的内部原理和优缺点"><a href="#3-promise-的内部原理和优缺点" class="headerlink" title="3. promise 的内部原理和优缺点"></a>3. promise 的内部原理和优缺点</h2><h3 id="Promise-基本特性"><a href="#Promise-基本特性" class="headerlink" title="Promise 基本特性"></a>Promise 基本特性</h3><ol><li>Promise 有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)</li><li>Promise 对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调 resolve 和失败时的回调 reject；另外 resolve 的参数除了正常值以外， 还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例。</li><li>then 方法返回一个新的 Promise 实例，并接收两个参数 onResolved(fulfilled 状态的回调)；onRejected(rejected 状态的回调，该参数可选)</li><li>catch 方法返回一个新的 Promise 实例</li><li>finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数</li><li>Promise.all()方法将多个多个 Promise 实例，包装成一个新的 Promise 实例，该方法接受一个由 Promise 对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例)，注意参数中只要有一个实例触发 catch 方法，都会触发 Promise.all()方法返回的新的实例的 catch 方法，如果参数中的某个实例本身调用了 catch 方法，将不会触发 Promise.all()方法返回的新实例的 catch 方法</li><li>Promise.race()方法的参数与 Promise.all 方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给 Promise.race()方法，并将返回值作为 Promise.race()方法产生的 Promise 实例的返回值</li><li>Promise.resolve()将现有对象转为 Promise 对象，如果该方法的参数为一个 Promise 对象，Promise.resolve()将不做任何处理；如果参数 thenable 对象(即具有 then 方法)，Promise.resolve()将该对象转为 Promise 对象并立即执行 then 方法；如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 fulfilled，其参数将会作为 then 方法中 onResolved 回调函数的参数，如果 Promise.resolve 方法不带参数，会直接返回一个 fulfilled 状态的 Promise 对象。需要注意的是，立即 resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li><li>Promise.reject()同样返回一个新的 Promise 对象，状态为 rejected，无论传入任何参数都将作为 reject()的参数</li></ol><h3 id="Promise-优点"><a href="#Promise-优点" class="headerlink" title="Promise 优点"></a>Promise 优点</h3><ol><li>统一异步 API<br>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。</li><li>Promise 与事件对比<br>和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</li><li>Promise 与回调对比<br>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</li><li>Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。</li></ol><h3 id="Promise-缺点"><a href="#Promise-缺点" class="headerlink" title="Promise 缺点"></a>Promise 缺点</h3><ol><li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li><li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li><li>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。</li></ol><h3 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolvePromise</span> = (<span class="hljs-params">promise, x, resolve, reject</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (x === promise) &#123;<br>    <span class="hljs-comment">// If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;循环引用&#x27;</span>))<br>  &#125;<br>  <span class="hljs-comment">// if x is an object or function,</span><br>  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span><br>    <span class="hljs-keyword">let</span> called<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><br>      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span> <span class="hljs-comment">// Let then be x.then</span><br>      <span class="hljs-comment">// If then is a function, call it with x as this</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span><br>        <span class="hljs-comment">// If/when rejectPromise is called with a reason r, reject promise with r.</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            <span class="hljs-title function_">resolvePromise</span>(promise, y, resolve, reject)<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            <span class="hljs-title function_">reject</span>(r)<br>          &#125;<br>        )<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If then is not a function, fulfill promise with x.</span><br>        <span class="hljs-title function_">resolve</span>(x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>      called = <span class="hljs-literal">true</span><br>      <span class="hljs-title function_">reject</span>(e)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If x is not an object or function, fulfill promise with x</span><br>    <span class="hljs-title function_">resolve</span>(x)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">excutor</span>) &#123;<br>  <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span> <span class="hljs-comment">// 缓存当前promise实例例对象</span><br>  that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span> <span class="hljs-comment">// 初始状态</span><br>  that.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// fulfilled状态时 返回的信息</span><br>  that.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// rejected状态时 拒绝的原因</span><br>  that.<span class="hljs-property">onFulfilledCallbacks</span> = [] <span class="hljs-comment">// 存储fulfilled状态对应的onFulfilled函数</span><br>  that.<span class="hljs-property">onRejectedCallbacks</span> = [] <span class="hljs-comment">// 存储rejected状态对应的onRejected函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// value成功态时接收的终值</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject)<br>    &#125;<br>    <span class="hljs-comment">// 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 调⽤用resolve 回调对应onFulfilled函数</span><br>      <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 只能由pending状态 =&gt; fulfilled状态 (避免调⽤用多次resolve reject)</span><br>        that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span><br>        that.<span class="hljs-property">value</span> = value<br>        that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">value</span>))<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-comment">// reason失败态时接收的拒因</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 调⽤用reject 回调对应onRejected函数</span><br>      <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 只能由pending状态 =&gt; rejected状态 (避免调⽤用多次resolve reject)</span><br>        that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span><br>        that.<span class="hljs-property">reason</span> = reason<br>        that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">reason</span>))<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 捕获在excutor执⾏行行器器中抛出的异常</span><br>  <span class="hljs-comment">// new Promise((resolve, reject) =&gt; &#123;</span><br>  <span class="hljs-comment">//     throw new Error(&#x27;error in excutor&#x27;)</span><br>  <span class="hljs-comment">// &#125;)</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">excutor</span>(resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">reject</span>(e)<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>  <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">let</span> newPromise<br>  <span class="hljs-comment">// 处理理参数默认值 保证参数后续能够继续执⾏行行</span><br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> reason<br>        &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>    <span class="hljs-comment">// 成功态</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(that.<span class="hljs-property">value</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject) <span class="hljs-comment">//新的promise resolve 上⼀一个onFulfilled的返回值</span><br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e) <span class="hljs-comment">// 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);</span><br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-comment">// 失败态</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(that.<span class="hljs-property">reason</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-comment">// 等待态</span><br>    <span class="hljs-comment">// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(value)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>      that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(reason)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-promise-和-async-x2F-await-的区别"><a href="#4-promise-和-async-x2F-await-的区别" class="headerlink" title="4. promise 和 async&#x2F;await 的区别"></a>4. promise 和 async&#x2F;await 的区别</h2><h3 id="同"><a href="#同" class="headerlink" title="同"></a>同</h3><ol><li>都是处理异步请求</li><li>async 返回的是一个 promise 对象</li></ol><h3 id="异"><a href="#异" class="headerlink" title="异"></a>异</h3><ol><li>promise 是 es6,async&#x2F;await 是 es7</li><li>async&#x2F;await 是基于 promise 的，是 promise 的语法糖</li><li>async&#x2F;await 使得异步代码看起来像同步代码，避免了回调地狱</li><li>async&#x2F;await 可以捕获 promise 的异常，promise 需要使用 catch 捕获异常</li></ol><h2 id="5-浏览器的存储方式有哪些"><a href="#5-浏览器的存储方式有哪些" class="headerlink" title="5. 浏览器的存储方式有哪些"></a>5. 浏览器的存储方式有哪些</h2><blockquote><p>cookies,localStorage,sessionStorage,indexedDB</p></blockquote><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><blockquote><p>服务器发送到用户浏览器并保存在本地的一小块数据</p></blockquote><ol><li>特点： 小容量（通常限制在 4KB）、每个请求都会携带到服务器。</li><li>用途： 用于存储少量的文本数据，例如会话信息、用户偏好设置等。</li><li>生命周期： 可以设置失效时间，如果在浏览器没有设置失效时间，那么 cookie 将会在浏览器关闭时失效。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 document.cookie 进行读写。</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> =<br>  <span class="hljs-string">&#x27;username=John Doe; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>本地存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 除非被清除，否则永久保存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 localStorage 对象进行读写。</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p>会话存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 仅在当前会话下有效，关闭页面或浏览器后被清除。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 sessionStorage 对象进行读写。</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><blockquote><p>浏览器本地数据库</p></blockquote><ol><li>容量：相对较大，适用于存储大量结构化数据。</li><li>生命周期： 永久存储，不受会话影响。</li><li>用途： 用于存储大量结构化数据，例如浏览器端缓存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 indexedDB 对象进行读写。</span><br><span class="hljs-keyword">var</span> request = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;MyTestDatabase&#x27;</span>)<br>request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 错误处理逻辑</span><br>&#125;<br>request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span><br>  <span class="hljs-comment">// 成功处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="token-token-存储在哪里-token-怎么传递"><a href="#token-token-存储在哪里-token-怎么传递" class="headerlink" title="token,token 存储在哪里,token 怎么传递"></a>token,token 存储在哪里,token 怎么传递</h3><blockquote><p>Token（令牌）是在身份验证（Authentication）和授权（Authorization）过程中用于验证用户身份的一种方式。(访问资源对凭证)</p></blockquote><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ol><li>存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台</li><li>存储在 cookie 中，让它自动发送，不过缺点就是不能跨域</li><li>拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里面。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>用户登录： 用户提供用户名和密码进行登录。</li><li>认证服务器验证： 服务器验证用户提供的用户名和密码，如果验证通过，生成一个令牌。</li><li>令牌返回给客户端： 服务器将生成的令牌返回给客户端。</li><li>客户端存储令牌： 客户端通常将令牌存储在本地，如浏览器的 localStorage、sessionStorage 或者内存中。</li><li>后续请求携带令牌： 客户端在后续的请求中携带令牌，通常通过 HTTP 头部的 Authorization 字段或者其他方式。</li></ol><h2 id="6-页面渲染的过程"><a href="#6-页面渲染的过程" class="headerlink" title="6. 页面渲染的过程"></a>6. 页面渲染的过程</h2><h3 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1.DNS 查询"></a>1.DNS 查询</h3><p>DNS（Domain Name System）查询是将用户输入的域名转换为对应的 IP 地址的过程。当用户在浏览器中输入一个网址时，浏览器会向本地 DNS 服务器发起查询请求，如果本地 DNS 服务器缓存中没有对应的 IP 地址，它会依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询，最终获得目标域名对应的 IP 地址。</p><h3 id="2-TCP-三次握手"><a href="#2-TCP-三次握手" class="headerlink" title="2.TCP 三次握手"></a>2.TCP 三次握手</h3><ol><li>客户端向服务器发送 SYN 请求： 客户端发送一个带有 SYN（同步）标志的数据包，表明客户端希望建立连接。</li><li>服务器回应 SYN+ACK： 服务器收到客户端的 SYN 请求后，会回应一个带有 SYN 和 ACK（确认）标志的数据包，表明收到了客户端的请求并同意建立连接。</li><li>客户端发送 ACK： 客户端收到服务器的 SYN+ACK 后，会发送一个带有 ACK 标志的数据包，表示连接建立完成。</li></ol><h3 id="3-TLS-协商"><a href="#3-TLS-协商" class="headerlink" title="3.TLS 协商"></a>3.TLS 协商</h3><blockquote><p>TLS（Transport Layer Security）是一种加密通信协议，用于保护数据在网络上传输的<br>安全性。TLS 协商是在 TCP 连接建立后，进行安全传输配置的过程：</p></blockquote><ol><li>客户端发送 ClientHello： 客户端向服务器发送包含支持的加密算法等信息的 ClientHello 报文。</li><li>服务器回应 ServerHello： 服务器收到 ClientHello 后，选择合适的加密算法，并回应一个包含服务器证书的 ServerHello 报文。</li><li>双方协商密钥： 服务器发送一个包含公钥的证书，客户端验证证书的有效性，并生成一个预主秘密（pre-master secret），使用服务器公钥加密后发送给服务器。双方使用预主秘密生成共享的主秘密。</li><li>完成协商： 双方使用协商得到的密钥进行加密通信，握手过程完成。</li></ol><h3 id="4-页面渲染"><a href="#4-页面渲染" class="headerlink" title="4.页面渲染"></a>4.页面渲染</h3><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/reflow.png" class title="This is an test image"><ol><li>构建 DOM 树：<br>渲染引擎使用 HTML 解析器（调用 XML 解析器）解析 HTML 文档，将各个 HTML 元素逐个转化成 DOM 节点，从而生成 DOM 树；<br>HTML 标记被解析为 DOM 节点，形成树状结构，表示文档的层次结构。</li><li>构建 CSSOM 树：<br>CSS 解析器解析 CSS，并将其转化为 CSS 对象，将这些 CSS 对象组装起来，构建 CSSOM 树；<br>CSSOM 树表示文档中的样式信息，包括样式的规则和层次关系。</li><li>合并 DOM 和 CSSOM 树为渲染树：<br>将构建好的 DOM 树和 CSSOM 树合并，形成渲染树（Render Tree）。<br>渲染树包含了需要被渲染的节点和其样式信息，但不包含不可见的元素（例如 display: none 的元素）。</li><li>计算布局（Layout）：<br>根据渲染树的信息，计算每个节点在屏幕上的位置和大小。<br>计算布局过程也被称为“回流”（reflow）。</li><li>绘制（Paint）：<br>使用计算好的布局信息，将页面上的每个节点绘制到屏幕上。<br>绘制过程也被称为“重绘”（repaint）。</li><li>显示（Display）：<br>将绘制的内容显示在用户的屏幕上。</li></ol><h2 id="7-svg-格式了解"><a href="#7-svg-格式了解" class="headerlink" title="7. svg 格式了解"></a>7. svg 格式了解</h2><blockquote><p>可缩放矢量图形（Scalable Vector Graphics，SVG）基于 XML 标记语言，用于描述二维的矢量图形</p></blockquote><p><strong>特点：</strong><br>SVG 是一种灵活、可伸缩且强大的图形描述语言，特别适合用于 Web 开发中创建可交互的矢量图形</p><h2 id="8-JWT"><a href="#8-JWT" class="headerlink" title="8.JWT"></a>8.JWT</h2><blockquote><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络上以 JSON 格式安全地传输信息。JWT 可以被用于身份验证（Authentication）和信息传递，通常用于通过网络在用户和服务器之间传递信息，以便在系统之间进行身份验证。</p></blockquote><h3 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h3><blockquote><p>JWT 由三部分组成，它们通过点号（.）连接在一起：Header.Payload.Signature</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//JWT编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br>  .<span class="hljs-property">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br>  .<span class="hljs-property">UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q</span><br></code></pre></td></tr></table></figure><h4 id="header-头部"><a href="#header-头部" class="headerlink" title="header(头部)"></a>header(头部)</h4><p>jwt 的头部承载两部分信息：</p><ol><li>声明类型，这里是 jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;typ&#x27;</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,<br>  <span class="hljs-string">&#x27;alg&#x27;</span>: <span class="hljs-string">&#x27;HS256&#x27;</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br></code></pre></td></tr></table></figure><h4 id="playload-载荷"><a href="#playload-载荷" class="headerlink" title="playload(载荷)"></a>playload(载荷)</h4><p>有效信息包含三个部分</p><ol><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9<br></code></pre></td></tr></table></figure><h4 id="signature-签证"><a href="#signature-签证" class="headerlink" title="signature(签证)"></a>signature(签证)</h4><p>签证信息由三部分组成：</p><ol><li>header (base64 后的)</li><li>payload (base64 后的)</li><li>secret</li></ol><p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成的字符串(头部在前)，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UQmqAUhUrpDVV</span>2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q<br></code></pre></td></tr></table></figure><h3 id="JWT-认证流程"><a href="#JWT-认证流程" class="headerlink" title="JWT 认证流程"></a>JWT 认证流程</h3><ol><li>用户身份验证：<br>用户提供身份信息（例如用户名和密码）进行身份验证。<br>服务器验证用户身份，如果验证通过，生成 JWT。</li><li>生成 JWT：<br>服务器使用用户的信息创建一个包含用户标识的 JWT。<br>JWT 的结构为 Header.Payload.Signature。</li><li>返回 JWT：<br>服务器将生成的 JWT 返回给客户端。</li><li>客户端存储 JWT：<br>客户端通常将收到的 JWT 存储在本地，例如在浏览器的 localStorage、sessionStorage 中，或者在移动应用程序的本地存储中。</li><li>在后续请求中携带 JWT：<br>客户端在后续的请求中携带 JWT，通常通过在请求头中添加 Authorization 字段，值为 Bearer <JWT>。</JWT></li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">http<br>Copy code<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...<br></code></pre></td></tr></table></figure><ol><li>服务器验证 JWT：<br>服务器在接收到请求时，从请求头中提取 JWT。<br>服务器使用事先共享的密钥（或公钥，对于使用非对称加密的情况）验证 JWT 的签名，确保令牌的真实性。<br>如果签名验证通过，服务器解析 JWT 中的负载数据，获取用户信息。</li><li>处理请求：<br>服务器根据 JWT 中的用户信息处理请求，进行相应的操作。</li></ol><h2 id="9-NPM"><a href="#9-NPM" class="headerlink" title="9.NPM"></a>9.NPM</h2><blockquote><p>NPM（Node Package Manager）是 Node.js 的包管理工具，用于安装、共享、管理 Node.js 模块.</p></blockquote><p><strong>npm 由三个不同的组件组成：</strong></p><ol><li>网站</li><li>命令行界面 (CLI)</li><li>注册表</li></ol><h2 id="10-HTTP-请求头、协议头"><a href="#10-HTTP-请求头、协议头" class="headerlink" title="10.HTTP 请求头、协议头"></a>10.HTTP 请求头、协议头</h2><h3 id="HTTP-请求包括："><a href="#HTTP-请求包括：" class="headerlink" title="HTTP 请求包括："></a>HTTP 请求包括：</h3><ol><li>请求行：请求的 http 方法+URL+http 的版本号</li><li>请求头</li></ol><ol><li>Accept： 览器支持的 MIME 媒体类型, 比如 text&#x2F;html,application&#x2F;json,image&#x2F;webp,&#x2F; 等</li><li>Accept-Encoding: 浏览器发给服务器,声明浏览器支持的编码类型，gzip, deflate</li><li>Accept-Language: 客户端接受的语言格式,比如 zh-CN</li><li>Connection: keep-alive , 开启 HTTP 持久连接</li><li>Host：服务器的域名</li><li>Origin：告诉服务器请求从哪里发起的，仅包括协议和域名 CORS 跨域请求中可以看到 response 有对应的 header，Access-Control-Allow-Origin</li><li>Referer：告诉服务器请求的原始资源的 URI，其用于所有类型的请求，并且包括：协议+域名+查询参数； 很多抢购服务会用这个做限制，必须通过某个入来进来才有效</li><li>User-Agent: 服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等； 风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考</li><li>Cookie: 表示服务端给客户端传的 http 请求状态,也是多个 key&#x3D;value 形式组合，比如登录后的令牌等</li><li>Content-Type： HTTP 请求提交的内容类型，一般只有 post 提交时才需要设置，比如文件上传，表单提交等。用来指定不同格式的请求格式响应信息俗称 MIME 媒体类型</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/path/to/resource</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.9<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ol start="3"><li>请求体：（key&#x3D;value）</li></ol><h3 id="HTTP-响应包括："><a href="#HTTP-响应包括：" class="headerlink" title="HTTP 响应包括："></a>HTTP 响应包括：</h3><ol><li>状态行：http 协议的版本+状态码+描述</li><li>响应头</li></ol><ol><li>Allow: 服务器支持哪些请求方法</li><li>Content-Length: 响应体的字节长度</li><li>Content-Type: 响应体的 MIME 类型</li><li>Content-Encoding: 设置数据使用的编码类型</li><li>Date: 设置消息发送的日期和时间</li><li>Expires: 设置响应体的过期时间,一个 GMT 时间，表示该缓存的有效时间</li><li>cache-control: Expires 的作用一致，都是指明当前资源的有效期, 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,优先级高于 Expires,控制粒度更细，如 max-age&#x3D;240，即 4 分钟</li><li>Location：表示客户应当到哪里去获取资源，一般同时设置状态代码为 3xx</li><li>Server: 服务器名称</li><li>Transfer-Encoding：chunked 表示输出的内容长度不能确定，静态网页一般没，基本出现在动态网页里面</li><li>Access-Control-Allow-Origin: 定哪些站点可以参与跨站资源共享</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 14 Sep 2021 12:00:00 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.4.41 (Unix)<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1234<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ol start="3"><li>响应体：web 服务器把要发送给客户端的文档信息放在响应体</li></ol><h2 id="11-浏览器的缓存机制"><a href="#11-浏览器的缓存机制" class="headerlink" title="11.浏览器的缓存机制"></a>11.浏览器的缓存机制</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><blockquote><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</p></blockquote><h4 id="强制缓存的情况主要有三种-暂不分析协商缓存过程-，如下："><a href="#强制缓存的情况主要有三种-暂不分析协商缓存过程-，如下：" class="headerlink" title="强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下："></a>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</h4><ol><li><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q1.png" class title="This is an test image"></li><li><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q2.png" class title="This is an test image"></li><li><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q3.png" class title="This is an test image"></li></ol><h4 id="控制强制缓存的字段分别是-Expires-和-Cache-Control"><a href="#控制强制缓存的字段分别是-Expires-和-Cache-Control" class="headerlink" title="控制强制缓存的字段分别是 Expires 和 Cache-Control"></a>控制强制缓存的字段分别是 Expires 和 Cache-Control</h4><blockquote><p>其中 Cache-Control 优先级比 Expires 高</p></blockquote><ol><li>Expires: 缓存过期时间，用于指定资源的到期时间，是服务器端的具体的时间点，即到了这个时间点，缓存就会失效，需要重新请求</li><li>Cache-Control: 控制缓存的行为，比如缓存过期时间，是否需要重新验证，是否需要重新请求等</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=31536000<br></code></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p></blockquote><h4 id="主要有以下两种情况："><a href="#主要有以下两种情况：" class="headerlink" title="主要有以下两种情况："></a>主要有以下两种情况：</h4><ol><li><p>协商缓存生效，返回 304</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/x1.png" class title="This is an test image"></li><li><p>协商缓存失效，返回 200 和请求结果结果</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/x2.png" class title="This is an test image"></li></ol><h4 id="控制协商缓存的字段分别有：Last-Modified-x2F-If-Modified-Since-和-Etag-x2F-If-None-Match"><a href="#控制协商缓存的字段分别有：Last-Modified-x2F-If-Modified-Since-和-Etag-x2F-If-None-Match" class="headerlink" title="控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match"></a>控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match</h4><blockquote><p>其中 Etag &#x2F; If-None-Match 优先级比 Last-Modified &#x2F; If-Modified-Since 高</p></blockquote><ol><li>Last-Modified &#x2F; If-Modified-Since: 服务器在响应请求时，告诉浏览器资源的最后修改时间，浏览器下次请求时，通过请求头 If-Modified-Since 把这个时间发送给服务器，由服务器根据这个时间判断资源是否修改过</li><li>Etag &#x2F; If-None-Match: Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），浏览器下次请求时，通过请求头 If-None-Match 把这个唯一标识发送给服务器，由服务器根据这个唯一标识判断资源是否修改过</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>&quot;5f8d9e9e-2a4d&quot;<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;5f8d9e9e-2a4d&quot;<br></code></pre></td></tr></table></figure><h2 id="12-同源策略和跨域"><a href="#12-同源策略和跨域" class="headerlink" title="12.同源策略和跨域"></a>12.同源策略和跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互<br>如果两个 URL 的协议、端口（如果有指定的话）和主机都相同的话，则这两个 URL 是同源的</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">http://store.company.com/dir2/other.html<br>协议：http<br>主机：store.company.com<br>端口：80<br></code></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ol><li>原理：利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据.</li><li>缺点：只能发送 get 一种请求。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//原生JS</span><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span><br><br><span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br>script.<span class="hljs-property">src</span> =<br>  <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script)<br><br><span class="hljs-comment">// 回调执行函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res))<br>&#125;<br><br><span class="hljs-comment">//Vue axios</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span> = axios<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span><br>  .<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>  &#125;)<br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h4 id="CORS”跨域资源共享”（Cross-origin-resource-sharing）"><a href="#CORS”跨域资源共享”（Cross-origin-resource-sharing）" class="headerlink" title="CORS”跨域资源共享”（Cross-origin resource sharing）"></a>CORS”跨域资源共享”（Cross-origin resource sharing）</h4><ol><li>原理：它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制</li><li>方法：服务端需要设置响应头中的 Access-Control-Allow-Origin 字段来指定允许的源。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 服务端设置 CORS</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://yourdomain.com&#x27;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;GET, POST, PUT, DELETE&#x27;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, CORS!&#x27;</span> &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="代理服务器（Proxy）"><a href="#代理服务器（Proxy）" class="headerlink" title="代理服务器（Proxy）:"></a>代理服务器（Proxy）:</h4><p>在同域的服务器上设置一个代理，由代理服务器去请求其他域上的资源，再将结果返回给前端。这样，前端只需要请求同域的资源，就能避免跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;<br><span class="hljs-attr">proxy</span>:&#123;<br><span class="hljs-comment">// 请求前缀/api，只有加了/api前缀的请求才会走代理(前端自定义)</span><br><span class="hljs-string">&#x27;/api&#x27;</span>:&#123;<br><span class="hljs-attr">target</span>:<span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<br><span class="hljs-attr">pathReweite</span>:&#123;<span class="hljs-string">&#x27;^/api&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;,<span class="hljs-comment">//重写</span><br><span class="hljs-comment">//ws:true,//用于支持websocket</span><br><span class="hljs-attr">changeOrigin</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//用于控制请求头中的host值，默认true，react中默认false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WebSocket-协议跨域"><a href="#WebSocket-协议跨域" class="headerlink" title="WebSocket 协议跨域"></a>WebSocket 协议跨域</h4><blockquote><p>它实现了浏览器与服务器全双工通信，同时允许跨域通讯</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>user input：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 连接成功处理</span></span><br><span class="language-javascript">  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端消息</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data from server: ---&gt; &#x27;</span> + msg)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端关闭</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server socket has closed.&#x27;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">onblur</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="13-防抖和节流"><a href="#13-防抖和节流" class="headerlink" title="13.防抖和节流"></a>13.防抖和节流</h2><p><strong>作用：</strong><br>控制事件触发频率的前端优化技术，用于提高性能和避免过度频繁的函数调用。</p><h3 id="防抖-Debouncing"><a href="#防抖-Debouncing" class="headerlink" title="防抖(Debouncing)"></a>防抖(Debouncing)</h3><blockquote><p>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> debouncedFunction = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要防抖的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Debounced function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, debouncedFunction)<br></code></pre></td></tr></table></figure><h3 id="节流-Throttling"><a href="#节流-Throttling" class="headerlink" title="节流(Throttling)"></a>节流(Throttling)</h3><blockquote><p>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastExecTime = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br><br>    <span class="hljs-keyword">if</span> (now - lastExecTime &gt;= delay) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      lastExecTime = now<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> throttledFunction = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要节流的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Throttled function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, throttledFunction)<br></code></pre></td></tr></table></figure><h2 id="14-JSON"><a href="#14-JSON" class="headerlink" title="14.JSON"></a>14.JSON</h2><blockquote><p>一种轻量级的数据交换格式，用于在不同语言之间进行数据传输。</p></blockquote><p><strong>方法:</strong><br>在 JavaScript 中，可以使用 <code>JSON.parse()</code>方法将 JSON 字符串解析为 JavaScript 对象，使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为 JSON 字符串。</p><h2 id="15-数据还没有请求过来是该怎么办？"><a href="#15-数据还没有请求过来是该怎么办？" class="headerlink" title="15.数据还没有请求过来是该怎么办？"></a>15.数据还没有请求过来是该怎么办？</h2><ol><li>Loading 状态： 显示加载状态，告知用户数据正在加载中。这可以通过添加加载动画、文本或其他 UI 元素来实现。用户一般会理解在等待数据加载的过程中出现的短时期的加载状态。</li><li>占位符： 在页面上使用占位符元素，占位符元素的样式和布局应与最终加载的数据元素相似，但可以使用一些样式或文本提示来表示数据正在加载中。这可以防止页面在数据加载时发生剧烈的布局变化。</li><li>默认值： 提供默认值作为占位数据，以确保页面的一致性。当数据加载完成后，再用实际的数据替换默认值。这对于一些不是必需加载的数据项来说是一个不错的选择。</li><li>骨架屏（Skeleton Screen）： 使用骨架屏技术，以页面整体的形式展示数据加载中的状态。骨架屏是一个页面的灰度版本，用于模拟页面的布局结构，让用户感知到页面正在加载数据。</li></ol><h2 id="16-无感登录"><a href="#16-无感登录" class="headerlink" title="16.无感登录"></a>16.无感登录</h2><blockquote><p>前端需要实现 Token 的自动刷新来避免用户在使用过程中因 Token 过期而需要重新登录的情况</p></blockquote><h3 id="1-使用-setInterval-定时刷新-Token"><a href="#1-使用-setInterval-定时刷新-Token" class="headerlink" title="1. 使用 setInterval 定时刷新 Token"></a>1. 使用 setInterval 定时刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>&#125;, <span class="hljs-number">59</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h3 id="2-使用-setTimeout-延时刷新-Token"><a href="#2-使用-setTimeout-延时刷新-Token" class="headerlink" title="2. 使用 setTimeout 延时刷新 Token"></a>2. 使用 setTimeout 延时刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>&#125;, tokenExpireTime - <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h3 id="3-使用-axios-拦截器自动刷新-Token"><a href="#3-使用-axios-拦截器自动刷新-Token" class="headerlink" title="3. 使用 axios 拦截器自动刷新 Token"></a>3. 使用 axios 拦截器自动刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;&lt;http://example.com/api&gt;&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>&#125;)<br><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> tokenExpireTime = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;tokenExpireTime&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (tokenExpireTime &amp;&amp; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt; tokenExpireTime) &#123;<br>      <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> api<br></code></pre></td></tr></table></figure><h2 id="17-大文件上传"><a href="#17-大文件上传" class="headerlink" title="17.大文件上传"></a>17.大文件上传</h2><h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3><blockquote><p>先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可</p></blockquote><ol><li>方法 1: 使用 FormData 和 XMLHttpRequest</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, file)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传进度</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> progress = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload Progress: <span class="hljs-subst">$&#123;progress&#125;</span>%`</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">send</span>(formData)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法 2: 使用 Fetch API</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, file)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传进度</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> progress = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload Progress: <span class="hljs-subst">$&#123;progress&#125;</span>%`</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">send</span>(formData)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><blockquote><p>在一些暂停&#x2F;恢复的上传场景下，需要在上一次的位置接着上传</p></blockquote><ol><li>方法 1: 使用 Blob 和 Slice</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 每次上传的分片大小（1MB）</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">uploadChunk</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> chunk = file.<span class="hljs-title function_">slice</span>(start, start + chunkSize)</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, chunk)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">body</span>: formData,</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>, data)</span><br><span class="language-javascript">            start += chunkSize</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (start &lt; file.<span class="hljs-property">size</span>) &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">uploadChunk</span>() <span class="hljs-comment">// 继续上传下一分片</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Upload failed&#x27;</span>, error)</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-title function_">uploadChunk</span>() <span class="hljs-comment">// 开始上传第一个分片</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>interview-js-2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-js</title>
    <link href="/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/"/>
    <url>/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-js"><a href="#🍭-面试-js" class="headerlink" title="🍭 面试-js"></a>🍭 面试-js</h1><h2 id="1-字节题-2js"><a href="#1-字节题-2js" class="headerlink" title="1.字节题 2js"></a>1.字节题 2js</h2><h3 id="1-var"><a href="#1-var" class="headerlink" title="1.var"></a>1.var</h3><pre><code class="hljs">1.var声明的变量会挂载在window上，let和const不会2.var声明的变量会进行变量提升，let和const不会3.var声明的变量没有块级作用域，let和const有4.var声明的变量可以重复声明(覆盖)，let和const不可以</code></pre><h3 id="2-深拷贝和浅拷贝"><a href="#2-深拷贝和浅拷贝" class="headerlink" title="2.深拷贝和浅拷贝"></a>2.深拷贝和浅拷贝</h3><pre><code class="hljs">1.浅拷贝：arr = newArr1.5.浅拷贝：arr = newArr.slice()1.5.浅拷贝：arr = newArr.concat()1.5.浅拷贝：arr = [...newArr]2.深拷贝：arr = JSON.parse(JSON.stringify(newArr))//不支持函数，正则，undefined</code></pre><hr><pre><code class="hljs"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (source) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (source) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h2 id="2-知识点-js"><a href="#2-知识点-js" class="headerlink" title="2.知识点 js"></a>2.知识点 js</h2><h3 id="2-1-js-构成"><a href="#2-1-js-构成" class="headerlink" title="2.1 js 构成"></a>2.1 js 构成</h3><ol><li>ECMAScript：<br>定义：ECMAScript 是 JavaScript 的语言规范，规定了 JavaScript 的基本语法、数据类型、函数定义等<br>作用：提供了 JavaScript 的核心功能，确保不同浏览器和环境中都能保持一致的行为。ECMAScript 规范由 Ecma International 维护，目前最新的版本是 ES2022。</li><li>DOM<br>标准： W3C DOM 标准<br>定义： DOM 是一种表述和操作 HTML、XML 文档的方式。在 JavaScript 中，DOM 提供了一种结构化的表示，使程序可以动态地更新文档的内容、结构和样式。<br>作用： 允许 JavaScript 通过脚本动态地操作文档的内容，实现与用户的交互和动态改变页面。DOM 将文档表示为一个树状结构，每个节点代表文档中的一个元素、属性或文本。</li><li>BOM<br>标准： 各个浏览器厂商根据 DOM 在各自浏览器上的实现<br>定义： BOM 是 JavaScript 与浏览器交互的一部分，提供了访问和控制浏览器窗口、框架和其他浏览器特定功能的对象。<br>作用： 允许 JavaScript 与浏览器进行通信，获取和修改浏览器窗口的属性，弹出警告框、确认框等。BOM 不属于 ECMAScript 标准，因此它的实现可以因浏览器而异。<br>组成：BOM 是由 navigator、history、screen、location、document 五个对象组成的。</li></ol><h3 id="2-2-js-的内置对象"><a href="#2-2-js-的内置对象" class="headerlink" title="2.2 js 的内置对象"></a>2.2 js 的内置对象</h3><blockquote><p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象</p></blockquote><ol><li>值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</li><li>函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</li><li>基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</li><li>数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</li><li>字符串，用来表示和操作字符串的对象。例如 String、RegExp</li><li>可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。复制代码例如 Array</li><li>使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet</li><li>矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</li><li>结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</li><li>控制抽象对象例如 Promise、Generator 等</li><li>反射 例如 Reflect、Proxy</li><li>国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</li></ol><h3 id="2-3-操作数组的方法"><a href="#2-3-操作数组的方法" class="headerlink" title="2.3 操作数组的方法"></a>2.3 操作数组的方法</h3><p>at(),concat(),copyWithin(),every(),fill(),filter(),find(),findIndex(),flat(),forEach(),includes(),indexOf(),join(),keys(),lastIndexOf(),map(),pop(),push(),reduce(),reduceRight(),reverse(),shift(),slice(),some(),sort(),splice(),toString(),unshift(),values()</p><h4 id="可以改变原数组的方法"><a href="#可以改变原数组的方法" class="headerlink" title="可以改变原数组的方法"></a>可以改变原数组的方法</h4><p>copyWithin(),fill(),pop(),push(),reverse(),shift(),sort(),splice(),unshift()</p><h3 id="2-4-js-检测数据类型的方法"><a href="#2-4-js-检测数据类型的方法" class="headerlink" title="2.4 js 检测数据类型的方法"></a>2.4 js 检测数据类型的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. typeof</span><br><span class="hljs-comment">// 返回一个表示类型的字符串(基本数据类型)</span><br><span class="hljs-comment">// 对一些复杂类型（例如 null 和数组）的判断不够准确。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> val)<br><br><span class="hljs-comment">//2. instanceof</span><br><span class="hljs-comment">// 检测一个对象是否是某个构造函数的实例</span><br><span class="hljs-comment">// 不能检测基本数据类型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val <span class="hljs-keyword">instanceof</span> valObject)<br><br><span class="hljs-comment">//3. Object.prototype.toString.call()</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(val)<br>  <span class="hljs-comment">// .replace(/\[object\s(\w+)\]/)</span><br>  <span class="hljs-comment">// .toLowerCase()</span><br>&#125;<br><br><span class="hljs-comment">//4. constructor</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><span class="hljs-comment">// 基本可以检测基本数据类型和引用数据类型(如果没有重写原型的话)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val.<span class="hljs-property">constructor</span> === valObject) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="2-5-闭包"><a href="#2-5-闭包" class="headerlink" title="2.5 闭包"></a>2.5 闭包</h3><h4 id="1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"><a href="#1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？" class="headerlink" title="1.为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"></a>1.为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">1.闭包的本质：闭包是由函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。<br>一个拥有外层函数对象所对应的活跃对象引用的函数对象就被称为闭包。<br>2.闭包的作用：可以读取函数内部的变量，让这些变量的值始终保持在内存中，不会在函数调用后被自动清除（私有化变量）<br>3.闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏<br>4.闭包的应用场景：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>1.函数作为返回值、参数传递<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2.闭包可以实现封装，防止变量被全局污染 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3.闭包可以实现JS的模<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.闭包可以缓存变量(数据私有化) <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5.防抖、节流、库的封装、柯里化、高阶函数<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-闭包的实现原理-AO-GO"><a href="#2-闭包的实现原理-AO-GO" class="headerlink" title="2.闭包的实现原理 + AO + GO"></a>2.闭包的实现原理 + AO + GO</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">1.当函数执行完毕后，其作用域链会被销毁，但是闭包的作用域链不会被销毁，因为闭包的作用域链是在函数执行完毕后创建的。<br>2.当函数执行完毕后，其活动对象也会被销毁，但是闭包的活动对象不会被销毁，因为闭包的活动对象是在函数执行完毕后创建的。<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">AO:</span>活动对象 Activation <span class="hljs-type">Object</span>:函数上下文<br><br><span class="hljs-symbol">GO:</span>全局对象 <span class="hljs-keyword">Global</span> <span class="hljs-type">Object</span> :全局上下文<br></code></pre></td></tr></table></figure><h4 id="3-闭包例子"><a href="#3-闭包例子" class="headerlink" title="3. 闭包例子"></a>3. 闭包例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">a</span>) &#123;<br>    count += a<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(a)<br>    &#125;,<br>    <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(-a)<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count<br>    &#125;,<br>  &#125;<br>  <span class="hljs-keyword">return</span> compute<br>&#125;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">makeCount</span>()<br>counter.<span class="hljs-title function_">compute</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">del</span>(<span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="2-6-js-内存泄漏和垃圾回收机制"><a href="#2-6-js-内存泄漏和垃圾回收机制" class="headerlink" title="2.6 js 内存泄漏和垃圾回收机制"></a>2.6 js 内存泄漏和垃圾回收机制</h3><blockquote><p><strong>内存泄漏</strong>是指程序在使用动态分配内存时，由于某种原因未能释放已经不再使用的内存，导致系统的可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</p></blockquote><blockquote><p>为什么会发生内存泄漏：</p></blockquote><ol><li>引用未释放的对象： 对象被引用，但在后续的代码中没有被正确释放。</li><li>循环引用： 当两个或多个对象相互引用，形成一个循环引用时，即使这些对象没有被其他代码引用，它们也不会被垃圾回收。</li><li>未清理的定时器和事件监听器： 在页面关闭前未清理的定时器或事件监听器可能引发内存泄漏。</li><li>未释放的 DOM 引用： 对 DOM 元素的引用，如果没有被正确释放，可能导致内存泄漏。</li></ol><blockquote><p>导致内存泄漏的因素：</p></blockquote><ol><li>全局变量： 将对象或数据存储在全局变量中，而忘记在不需要时手动删除它们。</li><li>闭包： 在闭包中引用的变量不会被垃圾回收，直到闭包不存在。</li><li>不正确使用定时器： 未清理的定时器可能导致对对象的引用被保留。</li><li>未解绑事件监听器： 如果页面上的元素被销毁，但仍然保留有对其事件的引用，可能导致内存泄漏。</li></ol><blockquote><p>JavaScript 使用垃圾回收机制来自动管理内存。主要的垃圾回收算法有两种：</p></blockquote><ol><li>标记-清除算法：<ol><li>标记阶段： 垃圾回收器会从根对象开始遍历所有引用，标记所有能够访问到的对象。</li><li>清除阶段： 垃圾回收器会清除所有未被标记的对象，释放它们占用的内存。</li></ol></li><li>引用计数算法： 维护每个对象的引用计数，当引用计数为零时即可将其释放。<ol><li>优点：实时性强，一旦引用计数为零就可以立即释放内存。</li><li>缺点：无法解决循环引用的问题，不再被引用的对象，只有在垃圾回收器运行时才能被释放。</li></ol></li></ol><h3 id="2-7-js-事件委托"><a href="#2-7-js-事件委托" class="headerlink" title="2.7 js 事件委托"></a>2.7 js 事件委托</h3><blockquote><p><strong>事件委托</strong>利用事件冒泡的特性，将事件处理程序绑定在父元素上，触发执行效果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件委托的好处：可以减少内存消耗，减少事件注册，提高性能</span><br><span class="hljs-comment">// 事件委托的缺点：事件委托的事件处理程序不能获取事件对象，因为事件处理程序是在另外一个元素上执行的</span><br><span class="hljs-comment">// 事件委托的应用场景：1.动态添加的元素 2.大量元素绑定同一事件</span><br><span class="hljs-comment">// 事件委托的实现：1.利用事件冒泡 2.判断事件源</span><br><span class="hljs-comment">// 事件委托的实现步骤：1.获取事件源 2.判断事件源 3.处理事件</span><br><span class="hljs-comment">// 事件委托的实现代码：</span><br><span class="hljs-comment">// 1.获取事件源</span><br><span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)<br><span class="hljs-comment">// 2.判断事件源</span><br>ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span><br>  <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span><br>  <span class="hljs-comment">// 3.处理事件</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerHTML</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件委托的优点："><a href="#事件委托的优点：" class="headerlink" title="事件委托的优点："></a>事件委托的优点：</h4><ol><li>性能优化： 减少事件处理程序的数量，尤其在大量子元素存在的情况下，可以显著提高性能。</li><li>动态元素： 对于动态生成的元素，通过委托可以避免为每个新元素都绑定事件处理程序。</li><li>代码简洁： 可以通过在父元素上绑定一个事件处理程序，减少冗余的代码。</li></ol><blockquote><p><strong>事件冒泡</strong>：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 阻止事件冒泡</span><br>event.<span class="hljs-title function_">stopPropagation</span>()<br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,(),<span class="hljs-literal">true</span>)<span class="hljs-comment">//true表示捕获阶段，false表示冒泡阶段</span><br><br></code></pre></td></tr></table></figure><h3 id="2-8-js-数据类型"><a href="#2-8-js-数据类型" class="headerlink" title="2.8 js 数据类型"></a>2.8 js 数据类型</h3><blockquote><p>基本数据类型：Number、String、Boolean、Null、Undefined、Symbol</p></blockquote><blockquote><p>引用数据类型：Object、Array、Function、Date、RegExp、Error</p></blockquote><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>存储位置：<ol><li>基本数据类型： 存储在栈内存中。</li><li>引用数据类型： 存储在堆内存中，栈内存中保存的是引用。</li></ol></li><li>比较方式：<ol><li>基本数据类型： 比较的是值是否相等。</li><li>引用数据类型： 比较的是引用地址是否相等。</li></ol></li><li>传递方式：<ol><li>基本数据类型： 通过值传递（传递的是数据的副本）。</li><li>引用数据类型： 通过引用传递（传递的是内存地址）。</li></ol></li></ol><h3 id="2-9-js-原型和原型链"><a href="#2-9-js-原型和原型链" class="headerlink" title="2.9 js 原型和原型链"></a>2.9 js 原型和原型链</h3><h4 id="1-原型（Prototype）"><a href="#1-原型（Prototype）" class="headerlink" title="1.原型（Prototype）"></a>1.原型（Prototype）</h4><ol><li>定义： 每个 JavaScript 对象（除了 null）都有一个原型对象，它是一个指向另一个对象的引用。</li><li>构造函数的原型属性： 对象是通过构造函数创建的，每个构造函数都有一个特殊的属性叫做 prototype，这个属性指向该构造函数的原型对象。</li><li>实例的原型： 通过构造函数创建的对象（实例）会继承构造函数的原型对象。</li><li><strong>proto</strong>属性： 在浏览器环境中，每个对象都有一个 <strong>proto</strong> 属性，指向它的原型对象。</li></ol><h4 id="2-原型链（Prototype-Chain）"><a href="#2-原型链（Prototype-Chain）" class="headerlink" title="2.原型链（Prototype Chain）"></a>2.原型链（Prototype Chain）</h4><ol><li>定义： 当一个对象在查找属性或方法时，如果它自身没有找到，就会去它的原型对象中查找，如果原型对象中还有原型，就会一直往上查找，直到找到或者达到原型链的顶端（null）。</li><li>继承关系： 原型链实现了对象之间的继承关系，使得一个对象可以共享另一个对象的属性和方法。</li><li>Object.prototype： 所有对象的原型链的顶端是 Object.prototype。</li></ol><h3 id="2-10-js-的-new-操作符"><a href="#2-10-js-的-new-操作符" class="headerlink" title="2.10 js 的 new 操作符"></a>2.10 js 的 new 操作符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">1. 创建一个空对象，作为将要返回的对象实例 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2. 将这个空对象的原型，指向构造函数的prototype属性 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3. 将这个空对象赋值给函数内部的this关键字 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4. 开始执行构造函数内部的代码<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5. 返回新对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model</span>) &#123;<br>  <span class="hljs-comment">// 步骤 3：将构造函数的上下文绑定到新对象</span><br>  <span class="hljs-comment">// 步骤 4：执行构造函数代码</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model<br>&#125;<br><br><span class="hljs-comment">// 步骤 2：设置原型链</span><br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Driving a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.make&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">// 步骤 1：创建一个空对象</span><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>, <span class="hljs-string">&#x27;Camry&#x27;</span>)<br><br><span class="hljs-comment">// 步骤 5：返回新对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">make</span>) <span class="hljs-comment">// 输出 &#x27;Toyota&#x27;</span><br>myCar.<span class="hljs-title function_">drive</span>() <span class="hljs-comment">// 输出 &#x27;Driving a Toyota Camry&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2-11-js-继承和如何实现继承"><a href="#2-11-js-继承和如何实现继承" class="headerlink" title="2.11 js 继承和如何实现继承"></a>2.11 js 继承和如何实现继承</h3><h4 id="1-原型链继承（Prototype-Chain-Inheritance）"><a href="#1-原型链继承（Prototype-Chain-Inheritance）" class="headerlink" title="1.原型链继承（Prototype Chain Inheritance）"></a>1.原型链继承（Prototype Chain Inheritance）</h4><blockquote><p>原型链继承是通过将一个对象的原型指向另一个对象来实现的。子类的原型对象是父类的一个实例，从而继承了父类的属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>子类共享父类的原型对象》父类新增原型方法&#x2F;原型属性，子类都能访问<br>》实例是子类的实例也是父类的实例</li></ol><p><strong>缺点</strong>：</p><ol><li>为子类新增属性和方法，不能在构造函数中</li><li>无法实现多继承</li><li>创建子类实例时，不能向父类构造函数传参数</li><li>原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！</li></ol><h4 id="2-借用构造函数继承（Constructor-Borrowing-Inheritance）"><a href="#2-借用构造函数继承（Constructor-Borrowing-Inheritance）" class="headerlink" title="2.借用构造函数继承（Constructor Borrowing Inheritance）"></a>2.借用构造函数继承（Constructor Borrowing Inheritance）</h4><blockquote><p>构造函数继承是通过在子类构造函数中调用父类构造函数来实现的，借助 call 或 apply。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">name</span>) <span class="hljs-comment">// John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">childName</span>) <span class="hljs-comment">// Child</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>可以在子类构造函数中向父类构造函数传参</li><li>可以实现多继承(call 多个对象)</li><li>不需要修复构造函数指向</li></ol><p><strong>缺点</strong>：</p><ol><li>方法在构造函数中定义，无法复用</li><li>只能继承父类的实例属性，不能继承原型属性、方法</li><li>实例并不是父类的实例，而只是子类的实例</li></ol><h4 id="3-组合继承（Combination-Inheritance）"><a href="#3-组合继承（Combination-Inheritance）" class="headerlink" title="3.组合继承（Combination Inheritance）"></a>3.组合继承（Combination Inheritance）</h4><blockquote><p>组合继承结合了原型链继承和构造函数继承的优点，使用原型链继承实现方法的继承，使用构造函数继承实现实例属性的继承。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, childName</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>可以继承实例属性、方法，也可以继承原型属性、方法</li><li>可传参、可复用</li><li>实例既是子类的实例，也是父类的实例</li></ol><p><strong>缺点：</strong></p><ol><li>调用了两次父类构造函数，耗内存</li><li>需要修复构造函数指向</li></ol><h4 id="4-原型式继承（Prototype-Inheritance）"><a href="#4-原型式继承（Prototype-Inheritance）" class="headerlink" title="4.原型式继承（Prototype Inheritance）"></a>4.原型式继承（Prototype Inheritance）</h4><blockquote><p>原型式继承是通过复制现有对象的原型来创建新对象。它的基本思想是通过一个函数，将一个对象作为参数传入，然后返回一个新的对象，这个新对象的原型指向传入的对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent)<br>child.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br><br>child.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>简单易懂，不需要定义新的构造函数。</li><li>可以实现对象之间的共享，因为它们共享同一个原型。</li></ol><p><strong>缺点：</strong></p><ol start="3"><li>共享引用类型的属性，修改其中一个对象的属性会影响其他对象。</li><li>无法传递参数给构造函数，每个实例都共享相同的属性。</li></ol><h4 id="5-寄生式继承（Parasitic-Inheritance）"><a href="#5-寄生式继承（Parasitic-Inheritance）" class="headerlink" title="5.寄生式继承（Parasitic Inheritance）"></a>5.寄生式继承（Parasitic Inheritance）</h4><blockquote><p>寄生继承是在原型式继承的基础上进行的一种改进。它创建一个函数，该函数在内部以某种方式增强对象，然后返回这个对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original)<br><br>  <span class="hljs-comment">// 在原对象的基础上增强</span><br>  child.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> child<br>&#125;<br><br><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">createChild</span>(parent)<br>child.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br><br>child.<span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// Hi, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>可以在对象上增加一些额外的方法或属性。</li></ol><p><strong>缺点：</strong></p><ol><li>仍然存在引用类型共享的问题。</li></ol><h4 id="6-寄生组合式继承（Parasitic-Combination-Inheritance）"><a href="#6-寄生组合式继承（Parasitic-Combination-Inheritance）" class="headerlink" title="6.寄生组合式继承（Parasitic Combination Inheritance）"></a>6.寄生组合式继承（Parasitic Combination Inheritance）</h4><blockquote><p>寄生组合继承是一种结合了原型式继承和构造函数继承的方式，通过构造函数继承来继承属性，通过原型链继承来继承方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, childName</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>避免了构造函数继承和原型链继承各自的缺点。</li><li>避免了重复调用构造函数。</li></ol><p><strong>缺点：</strong></p><ol><li>复杂，相对于其他继承方式更复杂，可能不够直观。</li></ol><h4 id="7-ES6-继承"><a href="#7-ES6-继承" class="headerlink" title="7.ES6 继承"></a>7.ES6 继承</h4><blockquote><p>ES6 引入了 class 语法，使得面向对象编程更加直观，但实际上仍然是基于原型链的继承。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, childName</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><h3 id="2-12-js-设计原理"><a href="#2-12-js-设计原理" class="headerlink" title="2.12 js 设计原理"></a>2.12 js 设计原理</h3><blockquote><p>Js 引擎、运行上下文、调用栈、事件循环、回调。</p></blockquote><ol><li>Js 引擎：负责解析和执行 js 代码</li><li>运行上下文：js 代码执行的环境，分为全局上下文和函数上下文</li><li>调用栈：js 引擎在执行 js 代码时，会以栈的形式来管理函数的调用，栈底永远是全局上下文，栈顶是当前正在执行的函数上下文</li><li>事件循环：js 是单线程的，事件循环是 js 实现异步的一种机制</li><li>回调：回调是一种常用的异步编程方式，可以通过回调来实现异步编程</li></ol><h3 id="2-13-js-this-指向问题"><a href="#2-13-js-this-指向问题" class="headerlink" title="2.13 js this 指向问题"></a>2.13 js this 指向问题</h3><h4 id="1-全局对象、普通函数中的-this-指向-window"><a href="#1-全局对象、普通函数中的-this-指向-window" class="headerlink" title="1.全局对象、普通函数中的 this 指向 window"></a>1.全局对象、普通函数中的 this 指向 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.全局对象中的this指向window</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window】</span><br><br><span class="hljs-comment">//2.普通函数中的this指向window</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window</span><br></code></pre></td></tr></table></figure><h4 id="2-构造函数中的-this-指向实例对象"><a href="#2-构造函数中的-this-指向实例对象" class="headerlink" title="2.构造函数中的 this 指向实例对象"></a>2.构造函数中的 this 指向实例对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3.构造函数中的this指向实例对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-对象中的函数中的-this-指向上一级对象"><a href="#3-对象中的函数中的-this-指向上一级对象" class="headerlink" title="3.对象中的函数中的 this 指向上一级对象"></a>3.对象中的函数中的 this 指向上一级对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//4.对象中的函数中的this指向上一级对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;,<br>  &#125;,<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span><br>obj2.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="4-箭头函数中的-this-指向-window"><a href="#4-箭头函数中的-this-指向-window" class="headerlink" title="4.箭头函数中的 this 指向 window"></a>4.箭头函数中的 this 指向 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//5.箭头函数中的this继承自上一级作用域</span><br><span class="hljs-keyword">let</span> obj3 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj3.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window undefined</span><br></code></pre></td></tr></table></figure><h4 id="5-call-x2F-apply-x2F-bind"><a href="#5-call-x2F-apply-x2F-bind" class="headerlink" title="5.call&#x2F;apply&#x2F;bind"></a>5.call&#x2F;apply&#x2F;bind</h4><blockquote><p>call&#x2F;apply&#x2F;bind 可以改变 this 指向，但是箭头函数的 this 无法改变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span><br><span class="hljs-keyword">let</span> obj4 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj4) <span class="hljs-comment">// window undefined</span><br><br><span class="hljs-comment">//7.call/apply/bind可以改变this指向</span><br><span class="hljs-keyword">let</span> obj5 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// obj5</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj5.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj5) <span class="hljs-comment">// obj5 1</span><br></code></pre></td></tr></table></figure><h4 id="6-事件中的-this-指向触发事件的元素"><a href="#6-事件中的-this-指向触发事件的元素" class="headerlink" title="6.事件中的 this 指向触发事件的元素"></a>6.事件中的 this 指向触发事件的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//8.事件中的this指向触发事件的元素</span><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// btn</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-匿名函数中的-this-指向-window"><a href="#7-匿名函数中的-this-指向-window" class="headerlink" title="7.匿名函数中的 this 指向 window"></a>7.匿名函数中的 this 指向 window</h4><blockquote><p>匿名函数执行环境具有全局性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//9.匿名函数中的this指向window</span><br><span class="hljs-keyword">let</span> obj6 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// obj6.b</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 2</span><br>      ;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>      &#125;)()<br>    &#125;,<br>  &#125;,<br>&#125;<br>obj6.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj6.b 2 window undefined</span><br></code></pre></td></tr></table></figure><h3 id="2-14-script-标签的-defer-和-async-属性"><a href="#2-14-script-标签的-defer-和-async-属性" class="headerlink" title="2.14 script 标签的 defer 和 async 属性"></a>2.14 script 标签的 defer 和 async 属性</h3><blockquote><p>script 是会阻碍 HTML 解析的，只有下载好并执行完脚本才会继续解析 HTML</p></blockquote><h4 id="1-defer"><a href="#1-defer" class="headerlink" title="1. defer"></a>1. defer</h4><blockquote><p>defer 属性告诉浏览器不要等待脚本，浏览器会继续处理 HTML，构建 DOM。该脚本“在后台”加载，然后在文档解析完成后，DOMContentLoaded 事件触发前执行。脚本会按照在 HTML 中出现的顺序执行。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特点:</strong></p><ol><li>defer 脚本会按照在 HTML 中出现的顺序执行。</li><li>defer 脚本会在 DOMContentLoaded 事件触发前执行。</li></ol><h4 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h4><blockquote><p>async 表示脚本在下载完成后立即异步执行，不会等待其他脚本，也不会阻塞文档的解析。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特点:</strong></p><ol><li>async 不保证脚本的执行顺序，谁先下载完成谁先执行。</li><li>async 脚本的执行时机是在下载完成后立即执行，不会等待其他脚本或文档解析。</li></ol><img src="/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/js-2_13.png" class title="This is an test image"><h3 id="2-15-setTimeout-和-setInterval-的区别"><a href="#2-15-setTimeout-和-setInterval-的区别" class="headerlink" title="2.15 setTimeout 和 setInterval 的区别"></a>2.15 setTimeout 和 setInterval 的区别</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><ol><li>作用： setTimeout 用于在指定的延迟时间后执行一次指定的函数。</li><li>语法： setTimeout(callback, delay)，其中 callback 是要执行的函数，delay 是延迟的毫秒数。</li><li>执行次数： 只执行一次。</li><li>返回值：返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给 clearTimeout()来取消该定时器。</li><li>取消： 可以使用 clearTimeout 来取消计划中的执行。<br><strong>最小延迟时间：</strong> setTimeout 的最小延迟时间是 4 毫秒，如果指定的延迟时间小于 4 毫秒，那么会被自动调整为 4 毫秒。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will be executed once after 2000 milliseconds.&#x27;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// 取消执行</span><br><span class="hljs-built_in">clearTimeout</span>(timeoutId)<br></code></pre></td></tr></table></figure><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><ol><li>作用： setInterval 用于每隔一定的时间重复执行指定的函数。</li><li>语法： setInterval(callback, delay)，其中 callback 是要执行的函数，delay 是每次执行之间的间隔时间。</li><li>执行次数： 重复执行，直到被取消。</li><li>返回值：此返回值 intervalID 是一个非零数值，用来标识通过 setInterval()创建的计时器，这个值可以用来作为 clearInterval()的参数来清除对应的计时器 。</li><li>取消： 可以使用 clearInterval 来取消重复执行。<br><strong>最小延迟时间：</strong> setInterval 的最小延迟时间是 4 毫秒，如果指定的延迟时间小于 4 毫秒，那么会被自动调整为 4 毫秒。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will be executed every 2000 milliseconds.&#x27;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// 取消重复执行</span><br><span class="hljs-built_in">clearInterval</span>(intervalId)<br></code></pre></td></tr></table></figure><h3 id="2-16-es6-的新特性"><a href="#2-16-es6-的新特性" class="headerlink" title="2.16 es6 的新特性"></a>2.16 es6 的新特性</h3><h4 id="1-新增了-let-和-const-命令，用来声明变量。"><a href="#1-新增了-let-和-const-命令，用来声明变量。" class="headerlink" title="1. 新增了 let 和 const 命令，用来声明变量。"></a>1. 新增了 let 和 const 命令，用来声明变量。</h4><ol><li>不能重复声明</li><li>不存在变量提升</li><li>暂时性死区</li><li>块级作用域</li></ol><h4 id="2-新增了箭头函数"><a href="#2-新增了箭头函数" class="headerlink" title="2. 新增了箭头函数"></a>2. 新增了箭头函数</h4><ol><li>箭头函数没有自己的 this，它的 this 继承于上一级作用域的 this</li><li>箭头函数没有自己的 arguments，它的 arguments 继承于上一级作用域的 arguments</li><li>箭头函数不能作为构造函数，不能使用 new</li><li>箭头函数没有原型属性</li></ol><h4 id="3-新增了模板字符串"><a href="#3-新增了模板字符串" class="headerlink" title="3. 新增了模板字符串"></a>3. 新增了模板字符串</h4><blockquote><p>模板字符串使用反引号（&#96;）包裹，支持多行字符串和变量插值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;World&#x27;</span><br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span><br></code></pre></td></tr></table></figure><h4 id="4-新增了解构赋值"><a href="#4-新增了解构赋值" class="headerlink" title="4. 新增了解构赋值"></a>4. 新增了解构赋值</h4><blockquote><p>可以通过解构赋值语法从数组或对象中提取值并赋给变量。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">const</span> &#123; a, b &#125; = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="5-新增了-Promise"><a href="#5-新增了-Promise" class="headerlink" title="5. 新增了 Promise"></a>5. 新增了 Promise</h4><h4 id="6-新增默认参数值"><a href="#6-新增默认参数值" class="headerlink" title="6. 新增默认参数值"></a>6. 新增默认参数值</h4><blockquote><p>函数参数可以设置默认值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y = <span class="hljs-number">2</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> x * y<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-新增了-class"><a href="#7-新增了-class" class="headerlink" title="7. 新增了 class"></a>7. 新增了 class</h4><blockquote><p>ES6 引入了类和继承的概念，更接近传统面向对象的语法。</p></blockquote><h4 id="8-新增了模块化"><a href="#8-新增了模块化" class="headerlink" title="8. 新增了模块化"></a>8. 新增了模块化</h4><blockquote><p>ES6 引入了模块系统，通过 import 和 export 关键字实现模块的导入和导出。</p></blockquote><h4 id="9-新增了-Set-和-Map"><a href="#9-新增了-Set-和-Map" class="headerlink" title="9. 新增了 Set 和 Map"></a>9. 新增了 Set 和 Map</h4><blockquote><p>ES6 引入了 Set 和 Map 两种新的数据结构，Set 类似于数组，但是成员的值都是唯一的，没有重复的值。Map 类似于对象，但是键可以是任意类型的。</p></blockquote><h4 id="10-新增了-Symbol"><a href="#10-新增了-Symbol" class="headerlink" title="10. 新增了 Symbol"></a>10. 新增了 Symbol</h4><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></blockquote><ol><li>使用场景：Symbol 值可以作为对象属性的标识符，可以防止属性名的冲突。</li><li>Symbol 特点</li></ol><ol><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 值不能与其他数据进行运算</li><li>Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用 Reflect.ownKeys 来获对象的所有键名</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建 Symbol</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1, <span class="hljs-keyword">typeof</span> s1)<br><br><span class="hljs-comment">//添加标识的 Symbol</span><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-keyword">let</span> s2_2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2 === s2_2) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">//使用 Symbol for 定义</span><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-keyword">let</span> s3_2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3 === s3_2) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="11-新增了-Proxy"><a href="#11-新增了-Proxy" class="headerlink" title="11. 新增了 Proxy"></a>11. 新增了 Proxy</h4><h4 id="12-迭代器和生成器"><a href="#12-迭代器和生成器" class="headerlink" title="12. 迭代器和生成器"></a>12. 迭代器和生成器</h4><h3 id="2-17-call、apply、bind-的区别"><a href="#2-17-call、apply、bind-的区别" class="headerlink" title="2.17 call、apply、bind 的区别"></a>2.17 call、apply、bind 的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span><br><span class="hljs-keyword">let</span> obj4 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">// window undefined</span><br><br><span class="hljs-comment">//7.function中的call/apply/bind可以改变this指向</span><br><span class="hljs-comment">//call:&#123;&#125;,改变this指向，立即执行</span><br><span class="hljs-comment">//apply:[],改变this指向，立即执行</span><br><span class="hljs-comment">//bind:返回一个新的函数,改变this指向，不会立即执行</span><br><span class="hljs-comment">//this都指向第一个参数</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span><br>&#125;<br>foo.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &#123;a:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-18-深拷贝和浅拷贝"><a href="#2-18-深拷贝和浅拷贝" class="headerlink" title="2.18 深拷贝和浅拷贝"></a>2.18 深拷贝和浅拷贝</h3><pre><code class="hljs">1.浅拷贝：arr = newArr1.5.浅拷贝：arr = newArr.slice()1.5.浅拷贝：arr = newArr.concat()1.5.浅拷贝：arr = [...newArr]2.深拷贝：arr = JSON.parse(JSON.stringify(newArr))//不支持函数，正则，undefined</code></pre><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-19-js-的事件循环"><a href="#2-19-js-的事件循环" class="headerlink" title="2.19 js 的事件循环"></a>2.19 js 的事件循环</h3><blockquote><p>它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。</p></blockquote><h4 id="1-执行栈（Call-Stack）："><a href="#1-执行栈（Call-Stack）：" class="headerlink" title="1.执行栈（Call Stack）："></a>1.执行栈（Call Stack）：</h4><ol><li>JavaScript 是单线程执行的，所有的代码都执行在一个主线程上，这个主线程拥有一个执行栈（Call Stack）来记录执行的上下文。</li><li>函数调用会将执行上下文推入执行栈，函数执行完毕后将其从栈中弹出。</li></ol><h4 id="任务队列（Task-Queue）："><a href="#任务队列（Task-Queue）：" class="headerlink" title="任务队列（Task Queue）："></a>任务队列（Task Queue）：</h4><ol><li>任务队列用于存储异步任务的回调函数。</li><li>当异步任务完成时，其回调函数会被放入任务队列中等待执行。</li></ol><h4 id="事件循环（Event-Loop）："><a href="#事件循环（Event-Loop）：" class="headerlink" title="事件循环（Event Loop）："></a>事件循环（Event Loop）：</h4><p>事件循环执行过程：</p><ol><li>执行当前宏任务的全部同步代码，将它们推入执行栈。</li><li>执行栈为空时，检查微任务队列，依次执行所有微任务。</li><li>微任务执行完成后，检查是否有宏任务需要执行，如果有，执行宏任务的同步代码。</li><li>重复上述过程</li></ol><h4 id="宏任务和微任务队列（Microtask-Queue）："><a href="#宏任务和微任务队列（Microtask-Queue）：" class="headerlink" title="宏任务和微任务队列（Microtask Queue）："></a>宏任务和微任务队列（Microtask Queue）：</h4><blockquote><p>宏任务： script( 整体代码)、setTimeout、setInterval、I&#x2F;O、UI 交互事件、setImmediate(Node.js 环境)</p></blockquote><blockquote><p>微任务： Promise、MutaionObserver、process.nextTick(Node.js 环境)；</p></blockquote><ol><li>在事件循环中，微任务队列用于存储微任务。</li><li>微任务会在当前宏任务执行结束后、下一个宏任务开始之前执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Timeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上述代码中，首先输出 ‘Start’，然后执行同步代码，接着将 setTimeout 和 Promise 的回调函数分别放入宏任务队列和微任务队列。最后输出 ‘End’。当执行栈为空时，事件循环开始执行微任务队列，输出 ‘Promise’，然后执行宏任务队列，输出 ‘Timeout’。</p>]]></content>
    
    
    
    <tags>
      
      <tag>interview-js-1</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview-js-3</title>
    <link href="/2024/01/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview3-js%E9%AB%98%E9%A2%91%E5%BA%95%E5%B1%82%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview3-js%E9%AB%98%E9%A2%91%E5%BA%95%E5%B1%82%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-3-js-高频底层问题"><a href="#🍭-面试-3-js-高频底层问题" class="headerlink" title="🍭 面试 3-js 高频底层问题"></a>🍭 面试 3-js 高频底层问题</h1><h2 id="1-各场景下-this-的指向"><a href="#1-各场景下-this-的指向" class="headerlink" title="1.各场景下 this 的指向"></a>1.各场景下 this 的指向</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>普通函数<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//1.this指向window</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//2.普通函数中的this指向window</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//3.构造函数中的this指向实例对象</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-comment">// Foo &#123;&#125;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//4.对象中的函数中的this指向上一级对象</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj2 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span></span><br><span class="language-javascript">      obj2.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 2</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//5.箭头函数中的this指向window</span></span><br><span class="language-javascript">      <span class="hljs-comment">//因为箭头函数没有作用域，所以this指向window</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj3 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span></span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj3.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window undefined</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj4 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span></span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">// window undefined</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//7.function中的call/apply/bind可以改变this指向</span></span><br><span class="language-javascript">      <span class="hljs-comment">//call:&#123;&#125;,改变this指向，立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//apply:[],改变this指向，立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//bind:返回一个新的函数,改变this指向，不会立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//this都指向第一个参数</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      foo.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &#123;a:1&#125;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h2><h3 id="2-1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"><a href="#2-1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？" class="headerlink" title="2.1 为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"></a>2.1 为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">1.闭包的本质：闭包是由函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。<br>一个拥有外层函数对象所对应的活跃对象引用的函数对象就被称为闭包。<br>2.闭包的作用：可以读取函数内部的变量，让这些变量的值始终保持在内存中，不会在函数调用后被自动清除（私有化变量）<br>3.闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏<br>4.闭包的应用场景：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>1.函数作为返回值、参数传递<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2.闭包可以实现封装，防止变量被全局污染 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3.闭包可以实现JS的模<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.闭包可以缓存变量(数据私有化) <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5.防抖、节流、库的封装、柯里化、高阶函数<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-闭包的实现原理-AO-GO"><a href="#2-2-闭包的实现原理-AO-GO" class="headerlink" title="2.2 闭包的实现原理 + AO + GO"></a>2.2 闭包的实现原理 + AO + GO</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">1.当函数执行完毕后，其作用域链会被销毁，但是闭包的作用域链不会被销毁，因为闭包的作用域链是在函数执行完毕后创建的。<br>2.当函数执行完毕后，其活动对象也会被销毁，但是闭包的活动对象不会被销毁，因为闭包的活动对象是在函数执行完毕后创建的。<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">AO:</span>活动对象 Activation <span class="hljs-type">Object</span>:函数上下文<br><br><span class="hljs-symbol">GO:</span>全局对象 <span class="hljs-keyword">Global</span> <span class="hljs-type">Object</span> :全局上下文<br></code></pre></td></tr></table></figure><h3 id="2-3-闭包例子"><a href="#2-3-闭包例子" class="headerlink" title="2.3 闭包例子"></a>2.3 闭包例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">a</span>) &#123;<br>    count += a<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(a)<br>    &#125;,<br>    <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(-a)<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count<br>    &#125;,<br>  &#125;<br>  <span class="hljs-keyword">return</span> compute<br>&#125;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">makeCount</span>()<br>counter.<span class="hljs-title function_">compute</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">del</span>(<span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h2 id="3-原生-js-实现事件委托"><a href="#3-原生-js-实现事件委托" class="headerlink" title="3.原生 js 实现事件委托"></a>3.原生 js 实现事件委托</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>事件委托<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托含义和原理：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的好处：可以减少内存消耗，减少事件注册，提高性能</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的缺点：事件委托的事件处理程序不能获取事件对象，因为事件处理程序是在另外一个元素上执行的</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的应用场景：1.动态添加的元素 2.大量元素绑定同一事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现：1.利用事件冒泡 2.判断事件源</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现步骤：1.获取事件源 2.判断事件源 3.处理事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现代码：</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取事件源</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-comment">// 2.判断事件源</span></span><br><span class="language-javascript">      ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 3.处理事件</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerHTML</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-new-操作符做了什么"><a href="#4-new-操作符做了什么" class="headerlink" title="4.new 操作符做了什么"></a>4.new 操作符做了什么</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">1.创建一个空对象，作为将要返回的对象实例<br>2.将这个空对象的原型，指向构造函数的prototype属性<br>3.将这个空对象赋值给函数内部的this关键字 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.开始执行构造函数内部的代码 5.返回新对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model</span>) &#123;<br>  <span class="hljs-comment">// 步骤 3：将构造函数的上下文绑定到新对象</span><br>  <span class="hljs-comment">// 步骤 4：执行构造函数代码</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model<br>&#125;<br><br><span class="hljs-comment">// 步骤 2：设置原型链</span><br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Driving a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.make&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">// 步骤 1：创建一个空对象</span><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>, <span class="hljs-string">&#x27;Camry&#x27;</span>)<br><br><span class="hljs-comment">// 步骤 5：返回新对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">make</span>) <span class="hljs-comment">// 输出 &#x27;Toyota&#x27;</span><br>myCar.<span class="hljs-title function_">drive</span>() <span class="hljs-comment">// 输出 &#x27;Driving a Toyota Camry&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>interview-js-3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx部署</title>
    <link href="/2023/12/22/%E6%8A%80%E6%9C%AF/nginx%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/12/22/%E6%8A%80%E6%9C%AF/nginx%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-nginx-部署"><a href="#🍭-nginx-部署" class="headerlink" title="🍭 nginx 部署"></a>🍭 nginx 部署</h1><h2 id="1-购买服务器"><a href="#1-购买服务器" class="headerlink" title="1.购买服务器"></a>1.购买服务器</h2><h2 id="2-开放安全组端口-22-和-80"><a href="#2-开放安全组端口-22-和-80" class="headerlink" title="2.开放安全组端口 22 和 80"></a>2.开放安全组端口 22 和 80</h2><h2 id="3-远程连接服务器-安装-nginx"><a href="#3-远程连接服务器-安装-nginx" class="headerlink" title="3.远程连接服务器,安装 nginx"></a>3.远程连接服务器,安装 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装nginx</span><br>yum install nginx<br><span class="hljs-comment"># 2.启动nginx</span><br>systemctl start nginx<br><span class="hljs-comment"># 3.查看nginx状态</span><br>systemctl status nginx<br><span class="hljs-comment"># 4.关闭防火墙</span><br>systemctl stop firewalld<br><span class="hljs-comment"># 5.reload nginx</span><br>nginx -s reload<br><span class="hljs-comment"># 6.kill 占用80端口的进程</span><br>lsof -i:80<br><span class="hljs-built_in">kill</span> -9 pid<br></code></pre></td></tr></table></figure><h2 id="4-配置-nginx"><a href="#4-配置-nginx" class="headerlink" title="4.配置 nginx"></a>4.配置 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.进入nginx配置文件</span><br><span class="hljs-built_in">cd</span> /etc/nginx<br><span class="hljs-comment"># 2.查看conf.d目录下的配置文件</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><h3 id="1-配置反向代理"><a href="#1-配置反向代理" class="headerlink" title="1.配置反向代理"></a>1.配置反向代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.在http中添加server</span><br>server &#123;<br>    listen       80; <span class="hljs-comment">#端口</span><br>    server_name  localhost; <span class="hljs-comment">#域名(公网ip)</span><br>    location / &#123;<br>        proxy_pass http:// <span class="hljs-comment">#反向代理地址(项目文件);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-transmit-通过-SFPT-连接服务器"><a href="#5-transmit-通过-SFPT-连接服务器" class="headerlink" title="5.transmit 通过 SFPT 连接服务器"></a>5.transmit 通过 SFPT 连接服务器</h2><pre><code class="hljs">网址：公网ip端口：22用户名：root密码：自己设置的密码</code></pre><h3 id="5-1-上传项目文件到服务器"><a href="#5-1-上传项目文件到服务器" class="headerlink" title="5.1.上传项目文件到服务器"></a>5.1.上传项目文件到服务器</h3><pre><code class="hljs">将项目文件放置到nginx配置的反向代理地址location / &#123;    proxy_pass http:// #反向代理地址(项目文件);&#125;</code></pre><h2 id="6-重启-nginx"><a href="#6-重启-nginx" class="headerlink" title="6.重启 nginx"></a>6.重启 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.重启nginx</span><br>nginx -s reload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vite3+vue基础配置</title>
    <link href="/2023/12/19/vue/vite3-vue%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/19/vue/vite3-vue%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-vite3-vue-基础配置"><a href="#🍭-vite3-vue-基础配置" class="headerlink" title="🍭 vite3+vue 基础配置"></a>🍭 vite3+vue 基础配置</h1><h2 id="1-配置-scss-x2F-less-css编译"><a href="#1-配置-scss-x2F-less-css编译" class="headerlink" title="1.配置 scss&#x2F;less css编译"></a>1.配置 scss&#x2F;less css编译</h2><blockquote><p>1.安装依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">npm i -D sass sass-loader less less-loader<br></code></pre></td></tr></table></figure><blockquote><p>2.配置 vite.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-comment">// 配置scss/less</span><br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">scss</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;@/assets/scss/variables.scss&quot;;`</span>,<br>      &#125;,<br>      <span class="hljs-attr">less</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;@/assets/less/variables.less&quot;;`</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-配置-alias-路径"><a href="#2-配置-alias-路径" class="headerlink" title="2.配置 alias 路径"></a>2.配置 alias 路径</h2><blockquote><p>1.配置 vite.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-comment">//配置alias</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview2</title>
    <link href="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview2/"/>
    <url>/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-2"><a href="#🍭-面试-2" class="headerlink" title="🍭 面试 2"></a>🍭 面试 2</h1><h2 id="大厂"><a href="#大厂" class="headerlink" title="大厂"></a>大厂</h2><h3 id="0-https-www-baidu-com-80-abc-d-1-e"><a href="#0-https-www-baidu-com-80-abc-d-1-e" class="headerlink" title="0.https://www.baidu.com:80/abc?d=1#e"></a>0.<a href="https://www.baidu.com:80/abc?d=1#e">https://www.baidu.com:80/abc?d=1#e</a></h3><pre><code class="hljs">1. https: 协议 http和tcp的结合之间加了一层SSL或TSL安全层2. www.baidu.com 域名;www:三级域名 baidu:二级域名 com:顶级域名3. 80 端口号4. / 路径5. ? 后面是查询参数6. # 后面是锚点</code></pre><h3 id="1-在浏览器输入-url-到页面展示发生了什么"><a href="#1-在浏览器输入-url-到页面展示发生了什么" class="headerlink" title="1.在浏览器输入 url 到页面展示发生了什么"></a>1.在浏览器输入 url 到页面展示发生了什么</h3><pre><code class="hljs">1.浏览器根据DNS服务器得到域名的IP地址2.向这个IP的机器发送http请求3.服务器收到、处理并返回http请求(三次握手)4.浏览器得到返回内容5.浏览器解析渲染页面6.连接结束(四次挥手)</code></pre><h3 id="2-渲染页面"><a href="#2-渲染页面" class="headerlink" title="2.渲染页面"></a>2.渲染页面</h3><pre><code class="hljs">1.根据HTML结构生成DOM Tree2.根据CSS生成CSSOM3.将DOM和CSSOM整合形成RenderTree4.根据RenderTree开始渲染和展示5.遇到&lt;script&gt;时，会执行并阻塞渲染；遇到&lt;link&gt;不会阻塞渲染；遇到&lt;style&gt;会阻塞渲染；遇到&lt;img&gt;会阻塞渲染6.计算布局信息7.将RenderTree渲染到屏幕上</code></pre><h4 id="2-1-https-www-baidu-com-与-https-www-baidu-com-的区别"><a href="#2-1-https-www-baidu-com-与-https-www-baidu-com-的区别" class="headerlink" title="2.1 https://www.baidu.com/ 与 https://www.baidu.com 的区别"></a>2.1 <a href="https://www.baidu.com/">https://www.baidu.com/</a> 与 <a href="https://www.baidu.com/">https://www.baidu.com</a> 的区别</h4><pre><code class="hljs">1.前者会发送请求，后者不会2.前者会刷新页面，后者不会</code></pre><h3 id="3-浏览器性能优化"><a href="#3-浏览器性能优化" class="headerlink" title="3.浏览器性能优化"></a>3.浏览器性能优化</h3><pre><code class="hljs">a.加载页面    1.减少http请求(合并文件、雪碧图/精灵图、使用base64)    2.减小资源体积(压缩代码、压缩图片)    3.使用CDN(第三方资源库)    4.SSR(服务端渲染)    5.懒加载(图片懒加载、下拉加载更多)    6.app/小程序(分包加载)b.页面渲染    1.减少DOM操作(合并DOM、缓存DOM查询结果)    2.减少重绘和回流(使用transform替代top、left等)    3.使用requestAnimationFrame代替setTimeout    4.使用Web Worker    5.使用虚拟DOM</code></pre><h3 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4.图片懒加载"></a>4.图片懒加载</h3><pre><code class="hljs">1.图片懒加载的原理    1.图片不设置src属性，而是设置一个自定义属性，比如data-src    2.当图片进入可视区域时，再把自定义属性的值赋值给src2.图片懒加载的优点    1.减少http请求，提升页面加载速度    2.节省服务器的带宽    3.节省浏览器的内存3.图片懒加载的缺点    1.增加了代码复杂度    2.用户体验不好，用户可能会看到一张一张图片的显示</code></pre><h4 id="4-1-图片懒加载的实现"><a href="#4-1-图片懒加载的实现" class="headerlink" title="4.1 图片懒加载的实现"></a>4.1 图片懒加载的实现</h4><pre><code class="hljs"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default1.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default2.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default3.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target3.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>); <span class="hljs-comment">// 获取所有图片imgs=[img,img,img]</span><br><span class="hljs-keyword">var</span> num = imgs.<span class="hljs-property">length</span>; <span class="hljs-comment">// 图片的数量</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器</span><br><span class="hljs-title function_">lazyload</span>(); <span class="hljs-comment">// 首次加载别忘了显示图片</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload); <span class="hljs-comment">// 监听滚动事件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">// 可视区域的高度</span><br>    <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>; <span class="hljs-comment">// 滚动条距离顶部的高度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = count; i &lt; num; i++) &#123; <span class="hljs-comment">// 从计数器的值开始，遍历每个图片</span><br>        <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-property">offsetTop</span> &lt; viewHeight + scrollTop) &#123; <span class="hljs-comment">// 图片进入可视区域</span><br>            <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>) !== <span class="hljs-string">&#x27;default.jpg&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果图片已经加载过，则跳过</span><br>            imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>); <span class="hljs-comment">// 设置图片src为data-src(加载图片)</span><br>            count++; <span class="hljs-comment">// 计数器累加</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview1-css</title>
    <link href="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/"/>
    <url>/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-css"><a href="#🍭-面试-css" class="headerlink" title="🍭 面试-css"></a>🍭 面试-css</h1><h2 id="1-字节题-1css"><a href="#1-字节题-1css" class="headerlink" title="1. 字节题 1css"></a>1. 字节题 1css</h2><h3 id="1-盒居中"><a href="#1-盒居中" class="headerlink" title="1.盒居中"></a>1.盒居中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>居中<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-padding-与-margin"><a href="#2-padding-与-margin" class="headerlink" title="2.padding 与 margin"></a>2.padding 与 margin</h3><pre><code class="hljs">1.padding作用于元素内容，会撑大元素大小2.margin作用于元素外部，不会撑大元素大小</code></pre><h3 id="3-vw-和百分比"><a href="#3-vw-和百分比" class="headerlink" title="3.vw 和百分比"></a>3.vw 和百分比</h3><pre><code class="hljs">1.vw是相对于视口的宽度2.百分比会继承父元素的宽度，vw不会</code></pre><h3 id="4-行内元素与块级元素"><a href="#4-行内元素与块级元素" class="headerlink" title="4.行内元素与块级元素"></a>4.行内元素与块级元素</h3><pre><code class="hljs">1.行内元素不换行，行内元素不可以设置大小，行内元素大小由内容决定2.块级元素换行，块级元素可以设置大小，块级元素大小由父元素决定</code></pre><h3 id="5-使谷歌浏览器字体（清晰，更小）"><a href="#5-使谷歌浏览器字体（清晰，更小）" class="headerlink" title="5.使谷歌浏览器字体（清晰，更小）"></a>5.使谷歌浏览器字体（清晰，更小）</h3><pre><code class="hljs">1.清晰：-webkit-font-smoothing: antialiased;2.更小：-webkit-text-size-adjust: 50%; // scale(0.5)</code></pre><h2 id="2-知识点"><a href="#2-知识点" class="headerlink" title="2.知识点"></a>2.知识点</h2><h3 id="2-1-css-盒模型"><a href="#2-1-css-盒模型" class="headerlink" title="2.1 css 盒模型"></a>2.1 css 盒模型</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">HTML中的每个元素都可以看作一个盒子，<br>这个盒子由元素的内容(content)、内边距(padding)、边框(border)、外边距(margin)组成。<br></code></pre></td></tr></table></figure><blockquote><p>盒模型分为两种：标准盒模型和 IE 盒模型。</p></blockquote><p>1.<strong>标准盒模型</strong>：width &#x3D; margin + border + padding + content</p><p>2.<strong>IE 盒模型</strong>：width &#x3D; margin + content(包含 border 和 padding)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* IE 盒模型 */</span><br>    <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 标准盒模型(默认值) */</span><br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="2-2-css-选择器"><a href="#2-2-css-选择器" class="headerlink" title="2.2 css 选择器"></a>2.2 css 选择器</h3><blockquote><p>css 选择器分为五种：标签选择器、类&#x2F;伪类&#x2F;属性选择器、id 选择器、通配符选择器、行内样式、!important</p></blockquote><p>优先级：!important &gt; 行内样式 &gt; id 选择器 &gt; 类&#x2F;伪类&#x2F;属性选择器 &gt; 标签选择器 &gt; 通配符选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-comment">/* 标签选择器 */</span><br>  <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 类选择器 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 伪类选择器 */</span><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 属性选择器 */</span><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;text&#x27;</span>]</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* id选择器 */</span><br><span class="hljs-selector-id">#box</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 通配符选择器 */</span><br>* &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 行内样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">color</span>: red<span class="hljs-string">&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">  /* !important */</span><br><span class="hljs-string">  .box &#123;</span><br><span class="hljs-string">  color: red !important;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-隐藏元素的方法"><a href="#2-3-隐藏元素的方法" class="headerlink" title="2.3 隐藏元素的方法"></a>2.3 隐藏元素的方法</h3><blockquote><p>1.display:none 2.visibility:hidden 3.opacity:0 4.position:absolute;left:-9999px 5.transform:scale(0) 6.clip-path:polygon(0 0,0 0,0 0,0 0)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.display:none */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: none;<br>&#125;<br><span class="hljs-comment">/* 2.visibility:hidden */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-comment">/* 3.opacity:0 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 4.position:absolute;left:-9999px */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br><span class="hljs-comment">/* 5.transform:scale(0) */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">/* 6.clip-path:polygon(0 0,0 0,0 0,0 0) */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-px-和-rem-的区别"><a href="#2-4-px-和-rem-的区别" class="headerlink" title="2.4 px 和 rem 的区别"></a>2.4 px 和 rem 的区别</h3><blockquote><p>px 是相对长度单位，像素 px 是相对于显示器屏幕分辨率而言的</p></blockquote><blockquote><p>rem 是 CSS3 新增的一个相对单位,rem 相对于根元素 html 的 font-size 大小来计算的</p></blockquote><h3 id="2-5-重绘和重排的区别"><a href="#2-5-重绘和重排的区别" class="headerlink" title="2.5 重绘和重排的区别"></a>2.5 重绘和重排的区别</h3><blockquote><p>重绘 repaint：当盒子的颜色发生改变，那么浏览器将使用保存的位图，只需要对屏幕重新进行绘制，这个过程称为重绘(某些元素的外观被改变)</p></blockquote><blockquote><p>重排(回流)reflow：当盒子的位置、大小以及其他属性发生改变，浏览器需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树，这个过程称为重排(重新生成布局，重新排列元素)</p></blockquote><p><strong>重绘不一定会引发重排，重排一定会引发重绘</strong></p><h4 id="浏览器页面渲染过程"><a href="#浏览器页面渲染过程" class="headerlink" title="浏览器页面渲染过程"></a>浏览器页面渲染过程</h4><pre><code class="hljs">1.HTML 被 HTML 解析器解析成 DOM 树；2.CSS  被 CSS 解析器解析成 CSSOM 树；3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；5.将布局绘制(paint)在屏幕上，显示出整个页面。</code></pre><img src="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/reflow.png" class title="This is an test image"><h3 id="2-6-css-哪些属性可以继承，哪些不可以"><a href="#2-6-css-哪些属性可以继承，哪些不可以" class="headerlink" title="2.6 css 哪些属性可以继承，哪些不可以"></a>2.6 css 哪些属性可以继承，哪些不可以</h3><ol><li>字体系列的属性可以继承，如：font-family、font-size、font-weight、font-style 等</li><li>文本系列的属性可以继承，如：text-indent、text-align、line-height、word-spacing、letter-spacing、text-transform、color 等</li><li>元素可见性相关属性可以继承，如：visibility 和 cursor</li><li>表格布局属性可以继承，如：border-collapse</li><li>列表属性可以继承，如：list-style、list-style-type、list-style-position、list-style-image</li><li>元素尺寸相关属性不可以继承，如：width、height、margin、padding、border、top、right、bottom、left、position、overflow、display、float、clear、min-width、min-height、max-width、max-height、z-index、vertical-align</li></ol><h3 id="2-7-预处理器"><a href="#2-7-预处理器" class="headerlink" title="2.7 预处理器"></a>2.7 预处理器</h3><p>预处理器添加了一些例如变量、嵌套、混合、导入、函数。</p><blockquote><p>less<br>sass</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>interview-css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础内容总结</title>
    <link href="/2022/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%934/"/>
    <url>/2022/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%934/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>H5C3知识总结</title>
    <link href="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/"/>
    <url>/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-H5C3知识总结"><a href="#🍭-H5C3知识总结" class="headerlink" title="🍭 H5C3知识总结"></a>🍭 H5C3知识总结</h1><h2 id="HTML新增样式"><a href="#HTML新增样式" class="headerlink" title="HTML新增样式"></a>HTML新增样式</h2><h2 id="1，语义化标签"><a href="#1，语义化标签" class="headerlink" title="1，语义化标签"></a>1，语义化标签</h2><pre><code class="hljs">1.&lt;header&gt;&lt;/header&gt;  2.&lt;nav&gt;&lt;/nav&gt;  3.&lt;article&gt;&lt;/article&gt;   4&lt;section&gt;&lt;/section&gt;  5.&lt;aside&gt;&lt;/aside&gt; 6.&lt;footer&gt;&lt;/footer&gt;</code></pre><hr><h2 id="2-video标签"><a href="#2-video标签" class="headerlink" title="2.video标签"></a>2.video标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">‘文件地址’</span> <span class="hljs-attr">...</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">autoplay</td><td align="center">autoplay</td><td align="center">视频就绪自动播放 （谷歌浏览器需要添加muted来解 决自动播放问题）</td></tr><tr><td align="center">controls</td><td align="center">controls</td><td align="center">向用户显示播放控件</td></tr><tr><td align="center">width</td><td align="center">pixels（像素）</td><td align="center">设置播放器宽度</td></tr><tr><td align="center">height</td><td align="center">pixels（像素）</td><td align="center">设置播放器高度</td></tr><tr><td align="center">loop</td><td align="center">loop</td><td align="center">播放完是否继续播放该视频，循环播放</td></tr><tr><td align="center">preload</td><td align="center">auto（预先加载视频） none（不应加载视频）</td><td align="center">规定是否预加载视频（如果有了autoplay就忽略该属性）</td></tr><tr><td align="center">src</td><td align="center">url</td><td align="center">视频urt地址</td></tr><tr><td align="center">poster</td><td align="center">Imgurl</td><td align="center">加载等待的画面图片</td></tr><tr><td align="center">muted</td><td align="center">muted</td><td align="center">静音播放</td></tr></tbody></table><hr><h2 id="3-audio标签"><a href="#3-audio标签" class="headerlink" title="3.audio标签"></a>3.audio标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">‘文件地址’</span> <span class="hljs-attr">...</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其他属性：</p><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">autoplay</td><td align="center">autoplay</td><td align="center">如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td align="center">controls</td><td align="center">controls</td><td align="center">如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td align="center">loop</td><td align="center">loop</td><td align="center">如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td align="center">src</td><td align="center">url</td><td align="center">要播放的音频的URL。</td></tr></tbody></table><hr><h2 id="4-input类型"><a href="#4-input类型" class="headerlink" title="4.input类型"></a>4.input类型</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;...&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.type类属性：</p><table><thead><tr><th align="center">type值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">type&#x3D;”email”</td><td align="center">限制用户输入必须为Email类型</td></tr><tr><td align="center">type&#x3D;”url</td><td align="center">限制用户输入必须为URL类型</td></tr><tr><td align="center">type&#x3D;”date”</td><td align="center">限制用户输入必须为日期类型</td></tr><tr><td align="center">type&#x3D;”time”</td><td align="center">限制用户输入必须为时间类型</td></tr><tr><td align="center">type&#x3D;”month”</td><td align="center">限制用户输入必须为月类型</td></tr><tr><td align="center">type&#x3D;”week”</td><td align="center">限制用户输入必须为周类型</td></tr><tr><td align="center">type&#x3D;”number”</td><td align="center">限制用户输入必须为数字类型</td></tr><tr><td align="center">type&#x3D;”tel”</td><td align="center">手机号码</td></tr><tr><td align="center">type&#x3D;”search”</td><td align="center">搜索框</td></tr><tr><td align="center">type&#x3D;”color”</td><td align="center">生成一个颜色选择表单</td></tr></tbody></table><p>2.input表单属性</p><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">required</td><td align="center">required</td><td align="center">表单拥有该属性表示其内容不能为空</td></tr><tr><td align="center">placeholder</td><td align="center">提示文本</td><td align="center">表单的提示信息，存在默认值将不显示</td></tr><tr><td align="center">autofocus</td><td align="center">autofocus</td><td align="center">自动聚焦属性， 页面加载完成自动聚焦到指定表单</td></tr><tr><td align="center">autocomplete</td><td align="center">off&#x2F;on</td><td align="center">当用户在字段开始键入时， 浏览器基于之前键入过的值， 应该显示出在字段中填写的选项。默认已经打开，如 autocomplete&#x3D;”on”关闭autocomplete&#x3D;”off”需要放在表单内，同时加上 name 属性，同时成功提交</td></tr><tr><td align="center">multiple</td><td align="center">multiple</td><td align="center">可以多选文件提交</td></tr></tbody></table><hr><h2 id="CSS内容"><a href="#CSS内容" class="headerlink" title="CSS内容"></a>CSS内容</h2><h2 id="CSS新增选择器"><a href="#CSS新增选择器" class="headerlink" title="CSS新增选择器"></a>CSS新增选择器</h2><h4 id="1-属性选择器"><a href="#1-属性选择器" class="headerlink" title="1.属性选择器"></a>1.属性选择器</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">input[value]   <span class="hljs-comment">&lt;!-- input类里并包含value的input --&gt;</span><br>div[class^=?]  <span class="hljs-comment">&lt;!-- 选择div里class属性开头是？的div --&gt;</span><br>Div[class*=?]  <span class="hljs-comment">&lt;!-- 选择div里class属性包含？的div  --&gt;</span><br>input[value]   <span class="hljs-comment">&lt;!-- input类里并包含value的input --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-结构伪类选择器"><a href="#2-结构伪类选择器" class="headerlink" title="2.结构伪类选择器"></a>2.结构伪类选择器</h4><blockquote><p>选择父元素第n个子元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ul li : first-child     <span class="hljs-comment">&lt;!-- 选择ul li 第一个孩子 --&gt;</span><br>ul li : last-child      <span class="hljs-comment">&lt;!-- 选择ul li 最后一个孩子 --&gt;</span><br>ul li : nth-child(n)    <span class="hljs-comment">&lt;!-- 选择ul li 第n个孩子 --&gt;</span><br>ul li : nth-child(even) <span class="hljs-comment">&lt;!-- 偶数 --&gt;</span><br>ul li : nth-child(odd)  <span class="hljs-comment">&lt;!-- 奇数 --&gt;</span><br>ul li : nth-child(n)    <span class="hljs-comment">&lt;!-- 选择ul li 从1-n孩子 --&gt;</span><br><br>element：First-of-type   <span class="hljs-comment">&lt;!-- 选择第一个元素 --&gt;</span><br>element：Second-of-type  <span class="hljs-comment">&lt;!-- 选择第二个元素 --&gt;</span><br>element：Nth-of-type(n)  <span class="hljs-comment">&lt;!-- 选择第n个元素 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-伪元素选择器-行内元素"><a href="#3-伪元素选择器-行内元素" class="headerlink" title="3.伪元素选择器 (行内元素)"></a>3.伪元素选择器 (行内元素)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">1.E::before&#123;content:&#125;   <span class="hljs-comment">&lt;!-- 在元素内部的前面插入内容 --&gt;</span><br>2.E::after&#123;content:&#125;    <span class="hljs-comment">&lt;!-- 在元素内部的后面插入内容 --&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>伪元素清除浮动（尾部阻隔）</p></blockquote><img src="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/tailclear.png" class title="This is an test image"><blockquote><p>伪元素清除浮动（头部阻隔）</p></blockquote><img src="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/headclear.png" class title="This is an test image"><hr><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p>1.不撑开盒子大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Box-sizing:border-box<br></code></pre></td></tr></table></figure><p>2.模糊函数  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Filter:blur(?px)<br></code></pre></td></tr></table></figure><p>3.calc函数  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">width:calc(100% - 80px)  <span class="hljs-comment">&lt;!-- 比父盒子100% 小 80px --&gt;</span><br></code></pre></td></tr></table></figure><p>4.过渡 (谁做过渡给谁+) ，(多个属性，隔开)，(all属性全变)</p><pre><code class="hljs">transition：要过渡的属性 花费时间 运动曲线 何时开始；1.属性：想要变化的 css 属性，宽度高度 背景颜色 内外边距都可以。 如果想要所有的属性都变化过渡，写一个all 就可以。2.花费时间：单位是秒（必须写单位） 比如 0.5s 3.运动曲线：默认是 ease （可以省略）4.何时开始：单位是秒（必须写单位） 可以设置延迟触发时间 默认是 Os（可以省略）</code></pre><hr><h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><mark>注意：一般稳定的服务器都是需要收费的。比如：阿里云</mark><blockquote><p>这里给大家推荐一个免费的远程服务器(免费空间) <a href="http://free.3v.do/">http://free.3v.do/</a></p></blockquote><p>1.去免费空间网站注册账号。<br>2.记录下主机名、用户名、密码、域名。<br>3.利用cutftp软件上传网站到远程服务器。<br>4.在浏览器中输入域名，即可访问我们的网站了。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识总结</title>
    <link href="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/"/>
    <url>/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-CSS内容总结"><a href="#🍭-CSS内容总结" class="headerlink" title="🍭 CSS内容总结"></a>🍭 CSS内容总结</h1><h2 id="1-给定标签类型"><a href="#1-给定标签类型" class="headerlink" title="1.给定标签类型"></a>1.给定标签类型</h2><h4 id="1-1-class类型-（可以调用多次）"><a href="#1-1-class类型-（可以调用多次）" class="headerlink" title="1.1 .class类型   （可以调用多次）"></a>1.1 .class类型   （可以调用多次）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        .red &#123; color=”red”;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><mark>注释：class里可以有多个类名，必须以空格隔开class&#x3D;“first second third”</mark><br><strong>example:</strong><br><font color="red">red</font></p><h4 id="1-2-id类型-只能调用一次）"><a href="#1-2-id类型-只能调用一次）" class="headerlink" title="1.2 #id类型      (只能调用一次）"></a>1.2 #id类型      (只能调用一次）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        #red &#123; color=”red”;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong><br><font color="red">red</font></p><h4 id="1-3-通配符类型-所有都调用）"><a href="#1-3-通配符类型-所有都调用）" class="headerlink" title="1.3 * 通配符类型  (所有都调用）"></a>1.3 * 通配符类型  (所有都调用）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  * &#123;color=”red”;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong><br><font color="red">red</font><br><font color="red">red</font><br><font color="red">red</font></p><hr><h2 id="2-文字样式"><a href="#2-文字样式" class="headerlink" title="2.文字样式"></a>2.文字样式</h2><h4 id="1-Color（文字颜色）"><a href="#1-Color（文字颜色）" class="headerlink" title="1.Color（文字颜色）:"></a>1.Color（文字颜色）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">color: “red”/“#ff0000”/“rgb(255,0,0)”/“rgb(100%,0,0)”;<br></code></pre></td></tr></table></figure><h4 id="2-Background（背景颜色）"><a href="#2-Background（背景颜色）" class="headerlink" title="2. Background（背景颜色）:"></a>2. Background（背景颜色）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background: “red”/“#ff0000”/“rgb(255,0,0)”/“rgb(100%,0,0)”/rgba(100%,0,0,0.3);<br></code></pre></td></tr></table></figure><h4 id="3-font-size（字体大小）"><a href="#3-font-size（字体大小）" class="headerlink" title="3. font-size（字体大小）:"></a>3. font-size（字体大小）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-size: 18px；  //(18像素)<br></code></pre></td></tr></table></figure><h4 id="4-font-family（字体类型）"><a href="#4-font-family（字体类型）" class="headerlink" title="4.font-family（字体类型）:"></a>4.font-family（字体类型）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-family: &quot;icomoon&quot;;    //icomoon字体<br></code></pre></td></tr></table></figure><h4 id="5-font-weight（字体粗细）"><a href="#5-font-weight（字体粗细）" class="headerlink" title="5.font-weight（字体粗细）:"></a>5.font-weight（字体粗细）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-weight:  “normal（400）/bold（700）;”   //(不跟单位)<br></code></pre></td></tr></table></figure><h4 id="6-font-style-（字体样式）"><a href="#6-font-style-（字体样式）" class="headerlink" title="6.font-style （字体样式）:"></a>6.font-style （字体样式）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-style:  “italic（斜体）/normal（正常）;”<br></code></pre></td></tr></table></figure><h4 id="7-复合属性："><a href="#7-复合属性：" class="headerlink" title="7.复合属性："></a>7.复合属性：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font: font-style font-weight font-size/line-height/font-family;<br><span class="hljs-comment">&lt;!-- font-size 和 font-family 不能少 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-行高"><a href="#8-行高" class="headerlink" title="8. 行高:"></a>8. 行高:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">line-height= ?px  ;<br><span class="hljs-comment">&lt;!-- 当行高等于总高度则文字垂直居中 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-文字位置"><a href="#9-文字位置" class="headerlink" title="9. 文字位置:"></a>9. 文字位置:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">text-align: center  / left  /  right  ;  <br></code></pre></td></tr></table></figure><h4 id="10-划线位置"><a href="#10-划线位置" class="headerlink" title="10.划线位置:"></a>10.划线位置:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Text-decoration : underline(下划线) / line-through(贯穿线) / overline(上划线) / none  ;<br></code></pre></td></tr></table></figure><h3 id="11-首行缩进"><a href="#11-首行缩进" class="headerlink" title="11.首行缩进:"></a>11.首行缩进:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Text-indent: 10px / 2em  ;  <br></code></pre></td></tr></table></figure><h4 id="12-文字阴影："><a href="#12-文字阴影：" class="headerlink" title="12.文字阴影："></a>12.文字阴影：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">text-shadow：  h-shadow   v-shadow  blur   spread  color  insert;<br></code></pre></td></tr></table></figure><hr><h2 id="3-行-x2F-块-元素"><a href="#3-行-x2F-块-元素" class="headerlink" title="3.行&#x2F;块 元素"></a>3.行&#x2F;块 元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">display: block;  <span class="hljs-comment">&lt;!--把行内元素改成块级元素--&gt;</span><br>display：inline；<span class="hljs-comment">&lt;!--把块级元素改成行内元素--&gt;</span><br>display：inline-block；<span class="hljs-comment">&lt;!--行内块元素--&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-背景元素"><a href="#4-背景元素" class="headerlink" title="4.背景元素"></a>4.背景元素</h2><h4 id="4-1背景颜色"><a href="#4-1背景颜色" class="headerlink" title="4.1背景颜色"></a>4.1背景颜色</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-color:  transparent(透明) /  red红）  /...;<br></code></pre></td></tr></table></figure><h4 id="4-2背景图片"><a href="#4-2背景图片" class="headerlink" title="4.2背景图片"></a>4.2背景图片</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-image: none (空)/ url(url)  （图片地址）;<br></code></pre></td></tr></table></figure><h4 id="4-3背景图片铺方式"><a href="#4-3背景图片铺方式" class="headerlink" title="4.3背景图片铺方式"></a>4.3背景图片铺方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-repeat: no-repeat(不平铺)/ repeat（平铺）/repeat-x（水平平铺）;<br></code></pre></td></tr></table></figure><h4 id="4-4背景图片位置"><a href="#4-4背景图片位置" class="headerlink" title="4.4背景图片位置"></a>4.4背景图片位置</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">backrgound-position:x y;  <br>x , y = center top left right(方位词)  <br></code></pre></td></tr></table></figure><h4 id="4-5背景颜色透明度"><a href="#4-5背景颜色透明度" class="headerlink" title="4.5背景颜色透明度"></a>4.5背景颜色透明度</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background: rgba(r,g,b,a) ; <span class="hljs-comment">&lt;!-- a取值0-1 --&gt;</span><br>opcity: .5  <span class="hljs-comment">&lt;!-- opcity透明度 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-6背景移动方式"><a href="#4-6背景移动方式" class="headerlink" title="4.6背景移动方式"></a>4.6背景移动方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Background-attachment : scroll / fixed;<br></code></pre></td></tr></table></figure><h4 id="4-7css背景属性整合写法"><a href="#4-7css背景属性整合写法" class="headerlink" title="4.7css背景属性整合写法"></a>4.7css背景属性整合写法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background:  color   url(url)  no-repeat  fixed  center  top;<br></code></pre></td></tr></table></figure><hr><h2 id="5-css三大特性（层叠性，继承性，优先级）"><a href="#5-css三大特性（层叠性，继承性，优先级）" class="headerlink" title="5.css三大特性（层叠性，继承性，优先级）"></a>5.css三大特性（层叠性，继承性，优先级）</h2><pre><code class="hljs">层叠性: 样式冲突覆盖  继承性: 子继承父  优先级: 权重</code></pre><p><mark>权重大小</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/css%E6%9D%83%E9%87%8D.png" class title="This is an test image"><p><mark>注意:复合选择器有权重叠加问题</mark></p><hr><h2 id="6-css书写顺序"><a href="#6-css书写顺序" class="headerlink" title="6.css书写顺序"></a>6.css书写顺序</h2><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/css%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F.png" class title="This is an test image"><hr><h2 id="7-选择器"><a href="#7-选择器" class="headerlink" title="7.选择器"></a>7.选择器</h2><h4 id="7-1-后代选择器："><a href="#7-1-后代选择器：" class="headerlink" title="7.1 后代选择器："></a>7.1 后代选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ol li &#123; color: pink;&#125;  <span class="hljs-comment">&lt;!--改变ol下li中文字颜色--&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-2-子选择器："><a href="#7-2-子选择器：" class="headerlink" title="7.2 子选择器："></a>7.2 子选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ol&gt;li&#123;&#125;  <span class="hljs-comment">&lt;!-- 只改变ol下一级li --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-3-并集选择器："><a href="#7-3-并集选择器：" class="headerlink" title="7.3 并集选择器："></a>7.3 并集选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">div,p&#123;&#125;  <span class="hljs-comment">&lt;!-- 改变div和p --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-4-伪类选择器："><a href="#7-4-伪类选择器：" class="headerlink" title="7.4 伪类选择器："></a>7.4 伪类选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">a:link&#123;color: &#125;      // (未访问链接）  <br>a:visited&#123;color: &#125;   //（访问过的链接）<br>a:hover&#123;color:&#125;      //（鼠标经过的链接）  <br>a:active&#123;color:&#125;     //（鼠标按下未弹起的链接）<br></code></pre></td></tr></table></figure><mark>注意：1.按照顺序写伪类选择器       2.链接要单独指定样式</mark><h4 id="7-5-focus伪类选择器"><a href="#7-5-focus伪类选择器" class="headerlink" title="7.5 focus伪类选择器"></a>7.5 focus伪类选择器</h4><p>选取焦点的表单元素谁获得光标谁改变样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Input :focus&#123;&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-盒子"><a href="#8-盒子" class="headerlink" title="8.盒子"></a>8.盒子</h2><h4 id="8-1-border边框设置"><a href="#8-1-border边框设置" class="headerlink" title="8.1 border边框设置"></a>8.1 border边框设置</h4><p>8.1.1边框粗细</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-width: ?;<br></code></pre></td></tr></table></figure><p>8.1.2边框样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-style: solid(实线) | dashed(虚线) | dotted(点线);<br></code></pre></td></tr></table></figure><p>8.1.3边框颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-color: ?;<br></code></pre></td></tr></table></figure><p>8.1.4复合属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">boeder(border-top/border-bottom/..)  : width   style   color ;<br></code></pre></td></tr></table></figure><p>8.1.5边框重合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-collapse:collapse;<br></code></pre></td></tr></table></figure><h4 id="8-2-padding-内边距"><a href="#8-2-padding-内边距" class="headerlink" title="8.2 padding 内边距"></a>8.2 padding 内边距</h4><pre><code class="hljs">padding-top / padding-left / padding-right / padding-bottom: ;</code></pre><p>复合属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">padding: top right left bottom; <br></code></pre></td></tr></table></figure><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/padding.png" class title="This is an test image"><h4 id="8-3-margin外边距"><a href="#8-3-margin外边距" class="headerlink" title="8.3 margin外边距"></a>8.3 margin外边距</h4><pre><code class="hljs">margin-top / margin-left / margin-right / margin-bottom;</code></pre><p>复合属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">margin: top right left bottom; <br></code></pre></td></tr></table></figure><h4 id="8-4-盒子阴影"><a href="#8-4-盒子阴影" class="headerlink" title="8.4 盒子阴影"></a>8.4 盒子阴影</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Box-shadow:  h-shadow  v-shadow blur   spread  color  insert;<br></code></pre></td></tr></table></figure><p><mark>详细内容</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/box-shadow.png" class title="This is an test image"><h4 id="8-5-图形圆角边框"><a href="#8-5-图形圆角边框" class="headerlink" title="8.5 图形圆角边框"></a>8.5 图形圆角边框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-radius：10px  (圆角矩形）/  50%（宽度高度一半）<br>border-radius：10px 20px 30px 40px(左上，右上，右下，左下)<br></code></pre></td></tr></table></figure><h2 id="9-浮动"><a href="#9-浮动" class="headerlink" title="9.浮动"></a>9.浮动</h2><h4 id="9-1-浮动属性"><a href="#9-1-浮动属性" class="headerlink" title="9.1 浮动属性"></a>9.1 浮动属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">float : none / left / right;<br></code></pre></td></tr></table></figure><h4 id="9-2清除浮动"><a href="#9-2清除浮动" class="headerlink" title="9.2清除浮动"></a>9.2清除浮动</h4><pre><code class="hljs">1&gt; clear : 属性值(left / right / both) 2&gt; 父级添加overflow ： hidden3&gt; 父级添加 ：after 伪元素   ：after &#123;content:””; display:block;height:0  ;  clear : both; visibility : hidden;</code></pre><p><mark>推荐语法css</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/clearfloat.png" class title="This is an test image"><h2 id="10-定位"><a href="#10-定位" class="headerlink" title="10.定位"></a>10.定位</h2><p><mark>1.定位&#x3D;定位模式+边偏移</mark><br><mark>2.定位元素必须添加top&#x2F;left&#x2F;right&#x2F;bottom 值</mark><br><mark>子绝父相：绝对定位不占格子，父只能用相对定位</mark></p><h4 id="10-1-定位属性"><a href="#10-1-定位属性" class="headerlink" title="10.1 定位属性"></a>10.1 定位属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&#123;<br>    position:relative / <br>             static(无定位) / <br>             relative(以自己原来的位置移动) / <br>             absolute(没父元素或父元素无定位,以浏览器为准定位,高级浮动) / <br>             fixed(页面内固定不动)  (在浏览器可视窗口）/ <br>             Sticky(粘性定位 = 绝对定位+相对定位)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-2-绝对定位盒子居中语法"><a href="#10-2-绝对定位盒子居中语法" class="headerlink" title="10.2 绝对定位盒子居中语法"></a>10.2 绝对定位盒子居中语法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">left:50%(父容器一半) <br>margin-left:-50%(盒子宽度一半)<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">transform:translate(-50%,-50%)<br></code></pre></td></tr></table></figure><p><mark>定位属性详细介绍</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/position.png" class title="This is an test image"><h2 id="11-元素的显示与隐藏"><a href="#11-元素的显示与隐藏" class="headerlink" title="11.元素的显示与隐藏"></a>11.元素的显示与隐藏</h2><h4 id="11-1-display属性"><a href="#11-1-display属性" class="headerlink" title="11.1 display属性"></a>11.1 display属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">display:none(隐藏不占位子) / block (转换为块元素/显示元素);<br></code></pre></td></tr></table></figure><h4 id="11-2-visibility属性"><a href="#11-2-visibility属性" class="headerlink" title="11.2 visibility属性"></a>11.2 visibility属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Visibility:visible(元素显示) / hidden(元素隐藏，占位子);<br></code></pre></td></tr></table></figure><h4 id="11-3-Overflow（溢出）属性"><a href="#11-3-Overflow（溢出）属性" class="headerlink" title="11.3 Overflow（溢出）属性"></a>11.3 Overflow（溢出）属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">overflow: visible(默认属性，溢出显示)   <br>overflow: hidden(慎用溢出隐藏)<br>Overflow: scroll(滚动条显示)    <br>overflow: auto (在需要的时候添加滚动条)<br></code></pre></td></tr></table></figure><h2 id="12-精灵图和字体图标"><a href="#12-精灵图和字体图标" class="headerlink" title="12.精灵图和字体图标"></a>12.精灵图和字体图标</h2><h4 id="12-1-精灵图"><a href="#12-1-精灵图" class="headerlink" title="12.1 精灵图"></a>12.1 精灵图</h4><p>目的：把每个小图整合成一个大图减少访问次数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Background:url(?.img) no-repeat -?(x方向)px -?(y方向)px ;<br></code></pre></td></tr></table></figure><h4 id="12-2-字体图标"><a href="#12-2-字体图标" class="headerlink" title="12.2 字体图标"></a>12.2 字体图标</h4><p><mark>字体图标资源网址</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/icomoon.png" class title="This is an test image"><p><mark>方法步骤：</mark><br>1.下载所需字体图标<br>2.把下载的font文件夹移动到对应目录下<br>3.在css里引入声明 如下图</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/font-family.png" class title="This is an test image"><p>4.生效代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-keyword">@font-face</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;icomoon&#x27;</span>;</span><br><span class="language-css">  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?53gexo&#x27;</span>);</span><br><span class="language-css">  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?53gexo#iefix&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.ttf?53gexo&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.woff?53gexo&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.svg?53gexo#icomoon&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;svg&#x27;</span>);</span><br><span class="language-css">  <span class="hljs-attribute">font-weight</span>: normal;</span><br><span class="language-css">  <span class="hljs-attribute">font-style</span>: normal;</span><br><span class="language-css">  <span class="hljs-attribute">font-display</span>: block;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">Font-family</span>:’icomoon’</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>[]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="13-css小三角形案例"><a href="#13-css小三角形案例" class="headerlink" title="13.css小三角形案例"></a>13.css小三角形案例</h2><h4 id="13-1-等腰直角"><a href="#13-1-等腰直角" class="headerlink" title="13.1 等腰直角"></a>13.1 等腰直角</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">.box&#123;<br>    width: 0;<br>    height: 0;<br>    margin: 100px auto;<br>    border: 50px solid transparent;<br>    border-top-color:pink ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-2-30-x2F-x2F-60-x2F-90三角形"><a href="#13-2-30-x2F-x2F-60-x2F-90三角形" class="headerlink" title="13.2 30&#x2F;&#x2F;60&#x2F;90三角形"></a>13.2 30&#x2F;&#x2F;60&#x2F;90三角形</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/sanjiaoxing.png" class title="This is an test image"><h2 id="14-用户界面样式"><a href="#14-用户界面样式" class="headerlink" title="14.用户界面样式"></a>14.用户界面样式</h2><h4 id="14-1-鼠标样式"><a href="#14-1-鼠标样式" class="headerlink" title="14.1 鼠标样式"></a>14.1 鼠标样式</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/cursor.png" class title="This is an test image"><h4 id="14-2-表单轮廓"><a href="#14-2-表单轮廓" class="headerlink" title="14.2 表单轮廓"></a>14.2 表单轮廓</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Input &#123;outline:none;&#125;<br>Textarea &#123;resize:none&#125;<br></code></pre></td></tr></table></figure><h4 id="14-3-vertical-align"><a href="#14-3-vertical-align" class="headerlink" title="14.3 vertical-align:"></a>14.3 vertical-align:</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/vertical.png" class title="This is an test image"><h4 id="14-4-文字溢出显示"><a href="#14-4-文字溢出显示" class="headerlink" title="14.4 文字溢出显示"></a>14.4 文字溢出显示</h4><p>单行文字</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/one.png" class title="This is an test image"><p>多行文字</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/two.png" class title="This is an test image"><p><mark>多行文字溢出显示后台做更简单</mark></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTML内容总结</title>
    <link href="/2022/09/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931/"/>
    <url>/2022/09/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-HTML内容总结"><a href="#🍭-HTML内容总结" class="headerlink" title="🍭 HTML内容总结"></a>🍭 HTML内容总结</h1><h2 id="1-基础元素："><a href="#1-基础元素：" class="headerlink" title="1.基础元素："></a>1.基础元素：</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML">1.1 <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>斜体字<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br>1.2 <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>加强粗体<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>1.3 <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>粗体<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>1.4 <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>下划线<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br>1.5 <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>1.6 <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>1.7 <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>1.8 <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>1.9 <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>1.10 <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span>   <br>1.11 回车  <span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>   <br>1.12 空格   &amp;nbps<br>1.13 小于号 &amp;lt<br>1.14 大于号 &amp;gt<br></code></pre></td></tr></table></figure><p><strong>example</strong>:</p><p>1.1 <em>斜体字</em><br>1.2 <strong>加强粗体</strong><br>1.3 <b>粗体</b><br>1.4 <u>下划线</u><br>1.5 </p><h1>一级标题</h1><br>1.6 <h2>二级标题</h2><br>1.7 <h3>三级标题</h3><br>1.8 <h4>四级标题</h4><br>1.9 <h5>五级标题</h5><br>1.10 <h6>六级标题</h6><p></p><hr><h3 id="1-2-图片-x2F-链接-x2F-注释"><a href="#1-2-图片-x2F-链接-x2F-注释" class="headerlink" title="1.2 图片&#x2F;链接&#x2F;注释"></a>1.2 图片&#x2F;链接&#x2F;注释</h3><p>1.图片设置: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">”图片地址”alt</span>=<span class="hljs-string">”未显示图片是提示文字”title</span>=<span class="hljs-string">”鼠标上显示”width</span>=<span class="hljs-string">？</span> <span class="hljs-attr">height</span>=<span class="hljs-string">？</span>  <span class="hljs-attr">border</span>=<span class="hljs-string">？（边框宽度）</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.超链接设置: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">”链接地址”</span> <span class="hljs-attr">title</span>=<span class="hljs-string">”鼠标放置时出现字”</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank（将在新标签页中打开。如果你希望在当前页面打开，忽略这个属性即可“_self”。）&quot;</span>&gt;</span>链接文字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">2.1 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”#”</span>&gt;</span>空链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.2 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”....html”</span>&gt;</span>链接到同一文件夹下的文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.3 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”....zip”</span>&gt;</span>下载的文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.4 锚点链接<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”#id”</span>&gt;</span>目标标签<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”id”</span>&gt;</span>目标<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.注释:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-comment">&lt;!-- 我在注释内！ --&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-1列表"><a href="#3-1列表" class="headerlink" title="3.1列表"></a>3.1列表</h2><p>3.1 排在一行内的无序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      <br>    豆浆<br>    油条<br>    豆汁<br>    焦圈<br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:</p><ul>          豆浆    油条    豆汁    焦圈</ul><hr><p>3.2 每个单独一行的无序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>豆浆<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>油条<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>豆汁<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>焦圈<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:  </p><ul>  <li>豆浆</li>  <li>油条</li>  <li>豆汁</li>  <li>焦圈</li></ul><hr><p>3.3 有序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沿着条路走到头<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>右转<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>直行穿过第一个十字路口<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>在第三个十字路口处左转<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>继续走 300 米，学校就在你的右手边<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:   </p><ol>    <li>沿着条路走到头</li>    <li>右转</li>    <li>直行穿过第一个十字路口</li>    <li>在第三个十字路口处左转</li>    <li>继续走 300 米，学校就在你的右手边</li></ol><hr><h2 id="4-标签-基础标签"><a href="#4-标签-基础标签" class="headerlink" title="4 标签 (基础标签)"></a>4 标签 (基础标签)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">4.1 <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  块元素（大盒子）  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>4.2 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  行内元素（小盒子）  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-表格"><a href="#5-表格" class="headerlink" title="5 表格"></a>5 表格</h2><p>5.1 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>  <span class="hljs-attr">align</span>(<span class="hljs-attr">页面对齐方式</span>) = <span class="hljs-string">“left”/”right”/”center”/</span>    <span class="hljs-attr">Border</span>(<span class="hljs-attr">边框大小</span>)  = <span class="hljs-string">1</span>   <span class="hljs-attr">Cellpadding</span>(<span class="hljs-attr">字和边框的距离大小</span>) =<span class="hljs-string">1</span>    <span class="hljs-attr">Cellspacing</span>(<span class="hljs-attr">单元格之间距离</span>) =<span class="hljs-string">0</span>     <span class="hljs-attr">Width</span>(<span class="hljs-attr">宽度</span>&gt;</span>表格容器)=？<br></code></pre></td></tr></table></figure><p>5.2 一行表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头单元格(加粗)<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>每行的小格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>5.3 合并单元格：</p><pre><code class="hljs">rolspan跨行合并(最上一个单元格写)   colspan跨列合并（最左一个单元格写）</code></pre><p>5.4 代码展示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><table border="1">    <tr>        <th>姓名</th>        <th>年龄</th>    </tr>    <tr>        <td>张三</td>        <td>18</td>    </tr></table><hr><h2 id="6-表单"><a href="#6-表单" class="headerlink" title="6.表单"></a>6.表单</h2><p>6.1 表单域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">”url(传递信息的地址)”</span> <span class="hljs-attr">method</span>=<span class="hljs-string">”post/get”</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”name”</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>6.2 表单元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">”text(文本）/password（密码框）/radio（单选按钮）/checkbox（多选按钮）”</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">”表单id”(相同name才能实现单选)</span>   <span class="hljs-attr">value</span>=<span class="hljs-string">”方框内的文字提示”</span>   <span class="hljs-attr">checked</span>=<span class="hljs-string">“checked”（单选/多选自动选择）</span> </span><br><span class="hljs-tag"><span class="hljs-attr">Maxlength</span>=<span class="hljs-string">“”最长字符</span>&gt;</span>   <br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><p>6.2.1 type&#x3D;”text”<br><input type="text" name="fist" value="请输入"></p><p>6.2.2 type&#x3D;”password”<br><input type="password" name="second" value></p><p>6.2.3 type&#x3D;”radio”<br><input type="radio" name="third" value="check">男<br><input type="radio" name="third" value="check">女</p><p>6.2.4 type&#x3D;”checkbox”<br><input type="checkbox" name="fourth" value="check" checked="checked"><br><input type="checkbox" name="fourth" value="check"></p><p>6.3 label标签 </p><pre><code class="hljs">label标签点击标签自动定位到input里</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">”text”</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><p><label for="text">…</label><input type="text" id="text"></p><p>6.4select 下拉表单元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">select</span>=<span class="hljs-string">”selected”(默认选择)</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><select>    <option select="”selected”(默认选择)">0</option>    <option>1</option>    <option>2</option>    <option>3</option>    <option>4</option></select><p>6.5textare 文本域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">textare</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textare</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-head容器中内容"><a href="#7-head容器中内容" class="headerlink" title="7.head容器中内容"></a>7.head容器中内容</h2><p>7.1 设置utf-8格式 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">“utf-8”</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7.2网页标题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7.3设置主语言：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span> = <span class="hljs-string">“zh-CN”</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown语法</title>
    <link href="/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-Markdown语法示例"><a href="#🍭-Markdown语法示例" class="headerlink" title="🍭 Markdown语法示例"></a>🍭 Markdown语法示例</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题[ # ]"></a>1.标题[ # ]</h2><pre><code class="hljs"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p><em>example:</em></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="2-强调-或-包围"><a href="#2-强调-或-包围" class="headerlink" title="2.强调[ ** 或 __ 包围 ]"></a>2.强调[ ** 或 __ 包围 ]</h2><pre><code class="hljs">**强调字体**__强调字体__</code></pre><p><em>example:</em><br><strong>强调字体</strong><br><strong>强调字体</strong></p><hr><h2 id="3-斜体-或-包围"><a href="#3-斜体-或-包围" class="headerlink" title="3.斜体 [ * 或 _ 包围 ]"></a>3.斜体 [ * 或 _ 包围 ]</h2><pre><code class="hljs">*斜体字体*_斜体字体_</code></pre><p><em>example:</em><br><em>斜体字体</em><br><em>斜体字体</em></p><hr><h2 id="4-删除线-包围"><a href="#4-删除线-包围" class="headerlink" title="4.删除线 [ ~~包围 ]"></a>4.删除线 [ ~~包围 ]</h2><pre><code class="hljs">~~删除的文字~~</code></pre><p><em>example:</em><br><del>删除的文字</del></p><hr><h2 id="5-高亮-x3D-x3D-包围"><a href="#5-高亮-x3D-x3D-包围" class="headerlink" title="5.高亮  [ &#x3D;&#x3D; 包围 ]"></a>5.高亮  [ &#x3D;&#x3D; 包围 ]</h2><pre><code class="hljs">==高亮字体==&lt;mark&gt;高亮字体&lt;/mark&gt;</code></pre><p><em>example:</em><br>&#x3D;&#x3D;高亮字体&#x3D;&#x3D;<br><mark>高亮字体</mark></p><hr><h2 id="6-代码行-96-包围"><a href="#6-代码行-96-包围" class="headerlink" title="6.代码行 [ &#96; 包围 ]"></a>6.代码行 [ &#96; 包围 ]</h2><pre><code class="hljs">`print(&#39;a&#39;)`</code></pre><p><em>example:</em><br><code>printf(&#39;a&#39;)</code></p><hr><h2 id="7-代码块-‘’’-包围"><a href="#7-代码块-‘’’-包围" class="headerlink" title="7.代码块 [ ‘’’ 包围 ]"></a>7.代码块 [ ‘’’ 包围 ]</h2><p><em>example:</em></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-built_in">int</span> mian() &#123;<br>    printf（“Hello, world!\n<span class="hljs-string">&quot;）;</span><br><span class="hljs-string">    retrun O;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-引用-gt-并且-gt-gt-前置"><a href="#8-引用-gt-并且-gt-gt-前置" class="headerlink" title="8.引用 [ &gt; 并且 &gt; &gt; 前置]"></a>8.引用 [ &gt; 并且 &gt; &gt; 前置]</h2><pre><code class="hljs">&gt; 一级引用&gt; &gt; 二级引用</code></pre><p><em>example:</em></p><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><hr><h2 id="9-无序列表-或-或-前置"><a href="#9-无序列表-或-或-前置" class="headerlink" title="9.无序列表[ - 或 + 或 * 前置]"></a>9.无序列表[ - 或 + 或 * 前置]</h2><pre><code class="hljs">- 无序列表+ 无序列表* 无序列表</code></pre><p><em>example:</em></p><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><hr><h2 id="10-有序列表-数字-前置"><a href="#10-有序列表-数字-前置" class="headerlink" title="10.有序列表 [ 数字 + . 前置 ]"></a>10.有序列表 [ 数字 + . 前置 ]</h2><pre><code class="hljs">1. 有序列表2. 有序列表3. 有序列表</code></pre><p><em>example:</em></p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h2 id="11-注释-后置"><a href="#11-注释-后置" class="headerlink" title="11. 注释 [ [^] 后置]"></a>11. 注释 [ [^] 后置]</h2><pre><code class="hljs">这是注释&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;注释的解释&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;</code></pre><p><em>example:</em><br>这是注释<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="注释的解释">[1]</span></a></sup></p><hr><h2 id="12-链接-常用-“-”-“-”-分别包围文本与链接"><a href="#12-链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="12. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>12. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h2><pre><code class="hljs">[正文](链接)</code></pre><hr><h2 id="13-任务列表-“-”-空格-前置"><a href="#13-任务列表-“-”-空格-前置" class="headerlink" title="13.任务列表 [“- [ ]” + 空格 前置]"></a>13.任务列表 [“- [ ]” + 空格 前置]</h2><pre><code class="hljs">&quot;- [ ] 刷B站&quot;&quot;- [ ] 写代码&quot;&quot;- [x] 起床&quot;</code></pre><p><em>example:</em></p><ul><li><input disabled type="checkbox"> 刷B站</li><li><input disabled type="checkbox"> 写代码</li><li><input checked disabled type="checkbox"> 起床</li></ul><hr><h2 id="14-表格-用-“-”-绘制表格边框"><a href="#14-表格-用-“-”-绘制表格边框" class="headerlink" title="14.表格 [用 “|” 绘制表格边框]"></a>14.表格 [用 “|” 绘制表格边框]</h2><pre><code class="hljs">学号|姓名|年龄:---|:---:|---:  (引号的位置代表着 左对齐, 居中, 右对齐)1|b|242|b|25</code></pre><p><em>example:</em></p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">b</td><td align="right">24</td></tr><tr><td align="left">2</td><td align="center">b</td><td align="right">25</td></tr></tbody></table><hr><h2 id="15-图片-“-图片-图片地址-”"><a href="#15-图片-“-图片-图片地址-”" class="headerlink" title="15.图片 [ “! [图片] (图片地址)” ]"></a>15.图片 [ “! [图片] (图片地址)” ]</h2><pre><code class="hljs">&#123;% asset_img example.png This is an test image %&#125;</code></pre><p><em>example:</em></p><img src="/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/example.png" class title="This is an test image"><hr><h2 id="16-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#16-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="16.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>16.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h2><pre><code class="hljs">***---___</code></pre><p><em>example:</em></p><ol><li></li></ol><hr><ol start="2"><li></li></ol><hr><ol start="3"><li></li></ol><hr><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p><strong>不断总结markdown实用语法</strong><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>注释的解释<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>注释的解释<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>hello world</p><h2 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h2><hr><h2 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h2><hr><p>end结束</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/12/hello-world/"/>
    <url>/2022/09/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
