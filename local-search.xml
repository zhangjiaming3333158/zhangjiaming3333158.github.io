<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>腾讯微信一面-id2</title>
    <link href="/2024/02/04/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E8%85%BE%E8%AE%AF%E5%BE%AE%E4%BF%A1%E4%B8%80%E9%9D%A2-id2/"/>
    <url>/2024/02/04/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E8%85%BE%E8%AE%AF%E5%BE%AE%E4%BF%A1%E4%B8%80%E9%9D%A2-id2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-腾讯微信一面-id2"><a href="#🍭-腾讯微信一面-id2" class="headerlink" title="🍭 腾讯微信一面-id2"></a>🍭 腾讯微信一面-id2</h1><h2 id="1-项目-45-分钟"><a href="#1-项目-45-分钟" class="headerlink" title="1. 项目 45 分钟"></a>1. 项目 45 分钟</h2><h2 id="2-浏览器底层（V8）核心原理"><a href="#2-浏览器底层（V8）核心原理" class="headerlink" title="2. 浏览器底层（V8）核心原理"></a>2. 浏览器底层（V8）核心原理</h2><blockquote><p>V8 引擎的核心在于其采用了<code>即时编译（JIT）</code>技术，通过动态地将 JavaScript 代码编译成机器码来提升性能。同时，V8 引擎还采用了<code>垃圾回收机制</code>、<code>内联缓存优化</code>等措施，使得其在处理代码时能够更快速、更高效。</p></blockquote><h3 id="构成原理"><a href="#构成原理" class="headerlink" title="构成原理"></a>构成原理</h3><blockquote><p>V8 引擎的核心由两部分组成：解释器和编译器。其执行过程如下图所示：</p></blockquote><img src="/2024/02/04/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E8%85%BE%E8%AE%AF%E5%BE%AE%E4%BF%A1%E4%B8%80%E9%9D%A2-id2/v8.png" class><ol><li>解释器：解释器负责将 JavaScript 代码解释成字节码，然后交给编译器处理。</li><li>编译器：编译器负责将字节码编译成机器码，然后交给处理器执行。</li></ol><p>当我们在浏览器中输入一个网址后，V8 引擎首先会使用解释器对 JavaScript 代码进行解析，并生成一种被称为“抽象语法树”（AST）的数据结构。接着，V8 引擎利用编译器对该 AST 进行优化，并生成机器码。最后，V8 引擎再直接运行机器码。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><blockquote><p>V8 引擎采用了一种叫做“标记-清除”（Mark-Sweep）的垃圾回收机制。该机制将 JavaScript 对象分为两类：可达对象和不可达对象。当一个对象不再被引用时，V8 引擎会将其标记为不可达对象，并在后续的清除过程中将其从内存中删除。</p></blockquote><h3 id="内联缓存优化"><a href="#内联缓存优化" class="headerlink" title="内联缓存优化"></a>内联缓存优化</h3><blockquote><p>首先，V8 引擎会对常见的函数调用进行缓存。当函数被再次调用时，V8 引擎会检查缓存并直接使用已经生成的机器码，而不是再次进行动态分派。这样的做法可以大大减少函数调用的时间开销，显著提升 JavaScript 代码的执行效率。</p></blockquote><h3 id="JIT-编译器"><a href="#JIT-编译器" class="headerlink" title="JIT 编译器"></a>JIT 编译器</h3><blockquote><p>它采用了一种称为“热点代码优化”（Hot code optimization）的技术，可以将 JavaScript 代码动态地编译成机器码，并且只对那些经常被执行的代码进行优化。</p></blockquote><ol><li>过程：当 V8 引擎执行到一个 JavaScript 函数时，它会将该函数的字节码交给解释器进行解释执行。同时，如果该函数被执行的次数较多，V8 引擎会将该函数的字节码交给 JIT 编译器进行优化，生成相应的机器码，以提升该函数的执行速度。</li></ol><h2 id="3-AST-抽象语法树如何生成"><a href="#3-AST-抽象语法树如何生成" class="headerlink" title="3. AST 抽象语法树如何生成"></a>3. AST 抽象语法树如何生成</h2><h2 id="4-AST-x3D-gt-DOM-树的具体过程"><a href="#4-AST-x3D-gt-DOM-树的具体过程" class="headerlink" title="4. AST &#x3D;&gt; DOM 树的具体过程"></a>4. AST &#x3D;&gt; DOM 树的具体过程</h2><h2 id="5-JIT-的原理——ignition-过程"><a href="#5-JIT-的原理——ignition-过程" class="headerlink" title="5. JIT 的原理——ignition 过程"></a>5. JIT 的原理——ignition 过程</h2><h2 id="6-从我写的代码到用户看到的界面这个过程中发生了什么事情（主要考察-React-和-webpack）"><a href="#6-从我写的代码到用户看到的界面这个过程中发生了什么事情（主要考察-React-和-webpack）" class="headerlink" title="6. 从我写的代码到用户看到的界面这个过程中发生了什么事情（主要考察 React 和 webpack）"></a>6. 从我写的代码到用户看到的界面这个过程中发生了什么事情（主要考察 React 和 webpack）</h2><h2 id="7-JSX-怎么转换的"><a href="#7-JSX-怎么转换的" class="headerlink" title="7. JSX 怎么转换的"></a>7. JSX 怎么转换的</h2><h2 id="8-webpack-帮我们做了什么事情"><a href="#8-webpack-帮我们做了什么事情" class="headerlink" title="8. webpack 帮我们做了什么事情"></a>8. webpack 帮我们做了什么事情</h2><p>作者：不想当切图仔<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/b7368cbcc4ae4fa2a5ae2d7b8f6f7c3e">https://www.nowcoder.com/feed/main/detail/b7368cbcc4ae4fa2a5ae2d7b8f6f7c3e</a><br>来源：牛客网</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview-vue+H5C3</title>
    <link href="/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/"/>
    <url>/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-Vue-H5C3"><a href="#🍭-面试-Vue-H5C3" class="headerlink" title="🍭 面试-Vue+H5C3"></a>🍭 面试-Vue+H5C3</h1><h2 id="1-语义化的理解"><a href="#1-语义化的理解" class="headerlink" title="1. 语义化的理解"></a>1. 语义化的理解</h2><blockquote><p>语义化是指使用合适的 HTML 标签来描述文档结构和内容，使得页面结构和内容更加清晰、易读，并对搜索引擎和开发者友好。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 头部 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 导航栏 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 区块（有语义化的div） --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 主要区域 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 主要内容 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aside</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">aside</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 侧边栏 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 底部 --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-1-语义化的优点"><a href="#1-1-语义化的优点" class="headerlink" title="1.1 语义化的优点"></a>1.1 语义化的优点</h3><ol><li>有利于搜索引擎优化</li><li>有利于开发者阅读和维护</li></ol><h2 id="2-H5C3-新特性"><a href="#2-H5C3-新特性" class="headerlink" title="2. H5C3 新特性"></a>2. H5C3 新特性</h2><h3 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h3><ol><li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li><li>音频、视频 API(audio,video)</li><li>画布(Canvas) API</li><li>数据存储 localStorage、sessionStorage</li><li>拖拽释放(Drag and drop) API</li><li>新的表单元素： 引入了新的表单元素，如<code>&lt;input&gt;</code>的 type 属性中的 email、url、tel 等，以及<code>&lt;datalist&gt;</code>元素，提供更丰富的表单功能。</li></ol><h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><ol start="0"><li>flex 和 grid 布局</li><li>新增选择器:属性选择器、伪类选择器、伪元素选择器</li><li>媒体查询： 允许根据设备的特性和屏幕尺寸来应用不同的样式，实现响应式设计。</li><li>阴影、边框: 提供了<code>box-shadow</code>和<code>border-radius</code>等属性，</li><li>盒模型: 提供了<code>box-sizing</code>属性，可以更好的控制盒模型。</li><li>渐变: 提供了<code>linear-gradient</code>和<code>radial-gradient</code>等属性，可以实现更丰富的渐变效果。</li><li>过渡和动画： 引入了过渡（transition）和动画（animation）属性，使得页面元素的状态变化更加平滑和具有动态效果。</li><li>背景: 提供了<code>background-size</code>、<code>background-origin</code>、<code>background-clip</code>等属性，可以更好的控制背景图片的显示效果。</li></ol><h2 id="3-rem-如何实现适配"><a href="#3-rem-如何实现适配" class="headerlink" title="3. rem 如何实现适配"></a>3. rem 如何实现适配</h2><blockquote><p>rem 是相对于根元素的字体大小(html&gt;font-size)的单位，通过设置根元素的字体大小，可以实现页面的适配。</p></blockquote><ol><li>rem 定义</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>; //根元素字体大小，此时<span class="hljs-number">1rem</span> = <span class="hljs-number">16px</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>rem 适配<br>以电脑 1920px 设计宽度为例，根据实际屏幕宽度设置 html 根元素 font-size 大小<br>rem &#x3D; 屏幕宽度 &#x2F; 设计稿宽度(1920px) *100<br>若屏幕宽度为 1920px，即 1rem &#x3D; 100px，</li></ol><h2 id="4-v-if-和-v-show-的区别"><a href="#4-v-if-和-v-show-的区别" class="headerlink" title="4. v-if 和 v-show 的区别"></a>4. v-if 和 v-show 的区别</h2><h3 id="共同点：控制元素在页面是否显示"><a href="#共同点：控制元素在页面是否显示" class="headerlink" title="共同点：控制元素在页面是否显示"></a>共同点：控制元素在页面是否显示</h3><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li><p>控制和编译：<br><br>v-show 只是简单的基于 css 切换、隐藏则是为该元素添加 css–display:none，dom 元素依旧还在。<br><br>v-if 显示隐藏是将 dom 元素整个添加或删除，v-if 切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；</p></li><li><p>生命周期：<br><br>v-show 由 false 变为 true 的时候不会触发组件的生命周期<br><br>v-if 由 false 变为 true 的时候，触发组件的 beforeCreate、create、beforeMount、mounted 钩子，由 true 变为 false 的时候触发组件的 beforeDestory、destoryed 方法</p></li><li><p>性能消耗：v-if 有更高的切换消耗；v-show 有更高的初始渲染消耗；</p></li></ol><h2 id="5-Vue"><a href="#5-Vue" class="headerlink" title="5. Vue"></a>5. Vue</h2><blockquote><p>创建用户界面的开源 JavaScript 框架，也是一个创建单页应用的 Web 应用框架</p></blockquote><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="数据驱动-MVVM"><a href="#数据驱动-MVVM" class="headerlink" title="数据驱动(MVVM)"></a>数据驱动(MVVM)</h4><ol><li>Model：模型层，负责处理业务逻辑以及和服务器端进行交互</li><li>View：视图层：负责将数据模型转化为 UI 展示出来，可以简单的理解为 HTML 页面</li><li>ViewModel：视图模型层，用来连接 Model 和 View，是 Model 和 View 之间的通信桥梁</li></ol><ol><li>它有两个方向：一是将模型转化成视图，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将视图转化成模型，即将所看到的页面转化成后端的数据。</li><li>实现的方式是：DOM 事件监听。这两个方向都实现的，我们称之为数据的双向绑定。</li></ol><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><blockquote><p>在 Vue 中每一个.vue 文件都可以视为一个组件<br><strong>优点：</strong></p></blockquote><ol><li>降低整个系统的耦合度</li><li>提高可维护性</li></ol><h4 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h4><ol><li>指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li></ol><h4 id="Vue-x2F-React"><a href="#Vue-x2F-React" class="headerlink" title="Vue&#x2F;React"></a>Vue&#x2F;React</h4><p><strong>相同点</strong></p><ol><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有 Virtual DOM（虚拟 dom）</li><li>数据驱动视图</li><li>都有支持 native 的方案：Vue 的 weex、React 的 React native</li><li>都有自己的构建工具：Vue 的 vue-cli、React 的 Create React App<br><strong>区别</strong></li><li>数据流向的不同。react 从诞生开始就推崇单向数据流，而 Vue 是双向数据流</li><li>数据变化的实现原理不同。react 使用的是不可变数据，而 Vue 使用的是可变的数据</li><li>组件化通信的不同。react 中我们通过使用回调函数来进行通信的，而 Vue 中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff 算法不同。react 主要使用 diff 队列保存需要更新哪些 DOM，得到 patch 树，再统一操作批量更新 DOM。Vue 使用双向指针，边对比，边更新 DOM</li></ol><h2 id="6-v-for-中的-key-是什么作用？"><a href="#6-v-for-中的-key-是什么作用？" class="headerlink" title="6. v-for 中的 key 是什么作用？"></a>6. v-for 中的 key 是什么作用？</h2><h3 id="官方的解释："><a href="#官方的解释：" class="headerlink" title="官方的解释："></a>官方的解释：</h3><ol><li><p>key 属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比（使用到 diff 算法）时辨识 VNodes；</p></li><li><p>如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改&#x2F;复用相同类型元素的算法；</p><img src="/2024/02/03/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-vue-H5C3/diff0.png" class></li><li><p>而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除&#x2F;销毁 key 不存在的元素。</p></li></ol><h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><blockquote><p>diff 算法是一种通过同层的树节点进行比较的高效算法</p></blockquote><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol><li>比较只会在同层级进行, 不会跨层级比较</li><li>在 diff 比较的过程中，循环从两边向中间比较</li></ol><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><blockquote><p>当数据发生改变时，set 方法会调用 Dep.notify 通知所有订阅者 Watcher，订阅者就会调用 patch 给真实的 DOM 打补丁，更新相应的视图</p></blockquote><ol><li><p>patch 函数前两个参数位为 oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断：</p><ol><li>没有新节点，直接触发旧节点的 destory 钩子</li><li>没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm</li><li>旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode 去处理这两个节点，子节点不完全一致，则调用 updateChildren</li><li>旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点</li></ol></li><li><p>patchVnode 主要做了几个判断：</p><ol><li>新节点是否是文本节点，如果是，则直接更新 dom 的文本内容为新节点的文本内容<br>新节点和旧节点如果都有子节点，则处理比较更新子节点</li><li>只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新 DOM，并且添加进父节点</li><li>只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把 DOM 删除</li></ol></li><li><p>子节点不完全一致，则调用 updateChildren</p><ol><li>当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1</li><li>当新老 VNode 节点的 end 相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1</li><li>当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1</li><li>当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1</li><li>如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况：<br>从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行 patchVnode，同时将这个真实 dom 移动到 oldStartVnode 对应的真实 dom 的前面<br>调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置</li></ol></li></ol><h2 id="7-请描述下你对-vue-生命周期的理解"><a href="#7-请描述下你对-vue-生命周期的理解" class="headerlink" title="7. 请描述下你对 vue 生命周期的理解"></a>7. 请描述下你对 vue 生命周期的理解</h2><blockquote><p>Vue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期(activated:keep-alive 缓存的组件激活时<br>deactivated:keep-alive 缓存的组件停用时调用)</p></blockquote><ol><li>beforeCreate -&gt; created<br>初始化 vue 实例，进行数据观测</li><li>created<br>完成数据观测，属性与方法的运算，watch、event 事件回调的配置<br>可调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 dom，可通过 computed 和 watch 完成数据计算<br>此时 vm.$el 并没有被创建</li><li>created -&gt; beforeMount<br>判断是否存在 el 选项，若不存在则停止编译，直到调用 vm.$mount(el)才会继续编译<br>优先级：render &gt; template &gt; outerHTML<br>vm.el 获取到的是挂载 DOM 的</li><li>beforeMount<br>在此阶段可获取到 vm.el<br>此阶段 vm.el 虽已完成 DOM 初始化，但并未挂载在 el 选项上</li><li>beforeMount -&gt; mounted<br>此阶段 vm.el 完成挂载，vm.$el 生成的 DOM 替换了 el 选项所对应的 DOM</li><li>mounted<br>vm.el 已完成 DOM 的挂载与渲染，此刻打印 vm.$el，发现之前的挂载点及内容已被替换成新的 DOM</li><li>beforeUpdate<br>更新的数据必须是被渲染在模板上的（el、template、render 之一）<br>此时 view 层还未更新<br>若在 beforeUpdate 中再次修改数据，不会再次触发更新方法</li><li>updated<br>完成 view 层的更新<br>若在 updated 中再次修改数据，会再次触发更新方法（beforeUpdate、updated）</li><li>beforeDestroy<br>实例被销毁前调用，此时实例属性与方法仍可访问</li><li>destroyed<br>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器<br>并不能清除 DOM，仅仅销毁实例</li></ol><table><thead><tr><th align="center">生命周期</th><th align="center">描述</th><th align="right"></th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td><td align="right"></td></tr><tr><td align="center">created</td><td align="center">组件初始化完毕，各种数据可以使用，常用于异步数据获取</td><td align="right"></td></tr><tr><td align="center">beforeMount</td><td align="center">未执行渲染、更新，dom 未创建</td><td align="right"></td></tr><tr><td align="center">mounted</td><td align="center">初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td><td align="right"></td></tr><tr><td align="center">beforeUpdate</td><td align="center">更新前，可用于获取更新前各种状态</td><td align="right"></td></tr><tr><td align="center">updated</td><td align="center">更新后，所有状态已是最新</td><td align="right"></td></tr><tr><td align="center">beforeDestroy</td><td align="center">销毁前，可用于一些定时器或订阅的取消</td><td align="right"></td></tr><tr><td align="center">destroyed</td><td align="center">组件已销毁，作用同上</td><td align="right"></td></tr></tbody></table><h3 id="题外话：数据请求在-created-和-mouted-的区别"><a href="#题外话：数据请求在-created-和-mouted-的区别" class="headerlink" title="题外话：数据请求在 created 和 mouted 的区别"></a>题外话：数据请求在 created 和 mouted 的区别</h3><p>created 是在组件实例一旦创建完成的时候立刻调用，这时候页面 dom 节点并未生成；<br><br>mounted 是在页面 dom 节点渲染完毕之后就立刻执行的。<br><br>两者的相同点：都能拿到实例对象的属性和方法。 讨论这个问题本质就是触发的时机，放在 mounted 中的请求有可能导致页面闪动（因为此时页面 dom 结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在 created 生命周期当中。</p><h2 id="8-Vue-常用的修饰符有哪些有什么应用场景"><a href="#8-Vue-常用的修饰符有哪些有什么应用场景" class="headerlink" title="8. Vue 常用的修饰符有哪些有什么应用场景"></a>8. Vue 常用的修饰符有哪些有什么应用场景</h2><blockquote><p>在 Vue 中，修饰符处理了许多 DOM 事件的细节:表单修饰符\事件修饰符\鼠标按键修饰符\键值修饰符\v-bind 修饰符</p></blockquote><h3 id="表单修饰符"><a href="#表单修饰符" class="headerlink" title="表单修饰符"></a>表单修饰符</h3><ol><li>lazy<blockquote><p>在我们填完信息，光标离开标签的时候，才会将值赋予给 value，也就是在 change 事件之后再进行信息同步</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;</code></p><ol start="2"><li>trim<blockquote><p>自动过滤用户输入的首空格字符，而中间的空格不会过滤</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt;</code></p><ol start="3"><li>number<blockquote><p>自动将用户的输入值转为数值类型，但如果这个值无法被 parseFloat 解析，则会返回原来的值</p></blockquote></li></ol><p><code>&lt;input type=&quot;text&quot; v-model.number=&quot;value&quot;&gt;</code></p><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><ol><li>stop<blockquote><p>阻止了事件冒泡，相当于调用了 event.stopPropagation 方法</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>prevent<blockquote><p>阻止了事件的默认行为，相当于调用了 event.preventDefault 方法</p></blockquote></li></ol><p><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code></p><ol start="3"><li>self<blockquote><p>只当在 event.target 是当前元素自身时触发处理函数</p></blockquote></li></ol><p><code>&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</code></p><ol start="4"><li>once<blockquote><p>绑定了事件以后只能触发一次，第二次就不会触发</p></blockquote></li></ol><p>&lt;button @click.once&#x3D;”shout(1)”&gt;ok</p><ol start="5"><li>capture<blockquote><p>使事件触发从包含这个元素的顶层开始往下触发</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;<br>    obj1<br>   &lt;div @click.<span class="hljs-property">capture</span>=<span class="hljs-string">&quot;shout(2)&quot;</span>&gt;<br>         obj2<br>      &lt;div @click=<span class="hljs-string">&quot;shout(3)&quot;</span>&gt;<br>            obj3<br>            &lt;div @click=<span class="hljs-string">&quot;shout(4)&quot;</span>&gt;<br>               obj4<br>            &lt;/div&gt;<br>      &lt;/div&gt;<br>   &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>passive<blockquote><p>在移动端，当我们在监听元素滚动事件的时候，会一直触发 onscroll 事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给 onscroll 事件整了一个.lazy 修饰符</p></blockquote></li></ol><p><code>&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</code></p><ol start="7"><li>native<blockquote><p>让组件变成像 html 内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件</p></blockquote></li></ol><p><code>&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</code></p><h3 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h3><blockquote><p>鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下：</p></blockquote><ol><li>left 左键点击</li><li>right 右键点击</li><li>middle 中键点击</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button @click.<span class="hljs-property">left</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;ok&lt;/button&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.right</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.middle</span>=<span class="hljs-string">&quot;shout(1)&quot;</span>&gt;</span>ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="键值修饰符"><a href="#键值修饰符" class="headerlink" title="键值修饰符"></a>键值修饰符</h3><blockquote><p>键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下：</p></blockquote><ol><li>普通键（enter、tab、delete、space、esc、up…）</li><li>系统修饰键（ctrl、alt、meta、shift…）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 只有按键为keyCode的时候才触发</span><br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> @keyup.<span class="hljs-property">keyCode</span>=<span class="hljs-string">&quot;shout()&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="v-bind-修饰符"><a href="#v-bind-修饰符" class="headerlink" title="v-bind 修饰符"></a>v-bind 修饰符</h3><ol><li>sync<blockquote><p>能对 props 进行一个双向绑定</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//父组件</span><br>&lt;comp :myMessage.<span class="hljs-property">sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;&lt;/comp&gt;<br><span class="hljs-comment">//子组件</span><br><span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br><br><span class="hljs-comment">//父亲组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">:myMessage</span>=<span class="hljs-string">&quot;bar&quot;</span> @<span class="hljs-attr">update:myMessage</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span></span><br><span class="hljs-title function_">func</span>(<span class="hljs-params">e</span>)&#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = e;<br>&#125;<br><span class="hljs-comment">//子组件js</span><br><span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:myMessage&#x27;</span>,params);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>使用 sync 的时候，子组件传递的事件名格式必须为 update:value，其中 value 必须与子组件中 props 中声明的名称完全一致.</li><li>注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync&#x3D;”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 v-model。</li><li>将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync&#x3D;”{ title: doc.title }”，是无法正常工作的.</li></ol><ol start="2"><li>props<blockquote><p>设置自定义标签属性，避免暴露数据，防止污染 HTML 结构</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;input id=<span class="hljs-string">&quot;uid&quot;</span> title=<span class="hljs-string">&quot;title1&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span> :index.<span class="hljs-property">prop</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;<br></code></pre></td></tr></table></figure><ol start="3"><li>camel<blockquote><p>将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;svg :viewBox=<span class="hljs-string">&quot;viewBox&quot;</span>&gt;&lt;/svg&gt;<br></code></pre></td></tr></table></figure><h2 id="9-Vue组件间通信有哪些方式"><a href="#9-Vue组件间通信有哪些方式" class="headerlink" title="9. Vue组件间通信有哪些方式"></a>9. Vue组件间通信有哪些方式</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>腾讯前端一面-id1</title>
    <link href="/2024/02/01/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E4%B8%80%E9%9D%A2-id1/"/>
    <url>/2024/02/01/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E4%B8%80%E9%9D%A2-id1/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-腾讯前端校招一面"><a href="#🍭-面试-腾讯前端校招一面" class="headerlink" title="🍭 面试-腾讯前端校招一面"></a>🍭 面试-腾讯前端校招一面</h1><h2 id="1-介绍一下你的项目"><a href="#1-介绍一下你的项目" class="headerlink" title="1. 介绍一下你的项目"></a>1. 介绍一下你的项目</h2><h2 id="2-如何实现身份鉴权"><a href="#2-如何实现身份鉴权" class="headerlink" title="2. 如何实现身份鉴权"></a>2. 如何实现身份鉴权</h2><blockquote><p>在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在网络安全领域，身份鉴别是指通过某种方式确认用户的身份，以确定用户是否有权访问某个系统或资源。</p></blockquote><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><blockquote><p>服务器通过 Set-Cookie 头将一个唯一的标识符（cookie）发送给客户端，客户端保存在浏览器中。在后续的每个请求中，浏览器都会自动携带这个 cookie，从而服务器可以识别用户。</p></blockquote><ol><li>流程：<br>用户登录时，服务器生成一个包含用户信息的 Cookie，并返回给浏览器。<br>浏览器保存 Cookie。<br>在后续请求中，浏览器自动携带 Cookie，服务器通过解析 Cookie 中的信息验证用户身份。</li><li>优点：<br>操作简单</li><li>缺点：<br>cookie 缺点：安全性低、容量小、性能低、无法跨域</li></ol><h3 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session+cookie"></a>session+cookie</h3><ol><li>流程：</li></ol><ol><li>用户登录时，服务器生成一个唯一的 Session ID，并将用户信息存储在服务器端的 Session 中。</li><li>服务器返回 Session ID 给浏览器，并设置一个对应的 Cookie。</li><li>浏览器保存 Cookie。在后续请求中，浏览器自动携带 Cookie，服务器通过解析 Cookie 中的 Session ID，并在服务器端查找对应的用户信息来验证用户身份。</li></ol><ol start="2"><li><p>优点</p><blockquote><p><strong>session 优点：</strong></p></blockquote><ol><li>安全性较高，客户端拿到的只是 sessionId，没有具体的用户信息</li><li>用户信息保存在服务器进程中，减少了查询数据库的次数</li><li>可以设置 session 的过期时间，不受 cookie 过期时间的影响</li><li>存储的数据类型不受限制</li></ol></li><li><p>缺点：</p></li></ol><ol><li>占用服务器内存资源，用户量很大时，内容消耗不起</li></ol><h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><ol><li>流程：</li></ol><ol><li>用户登录时，服务器将用户信息通过密钥生成令牌（Access Token），并返回给浏览器</li><li>浏览器保存 Token。在后续请求中，浏览器自动携带 Token，服务器通过验证 Token 的签名和有效期来验证用户身份。</li></ol><ol start="2"><li><p>优点：</p><blockquote><p><strong>token 优点：</strong></p></blockquote><ol><li>无状态可以减轻服务器压力，减少频繁查询数据库</li><li>没有同源策略的限制，方便第三方平台或者开发时的接口调用</li><li>安全性较高，token 的解密密钥只有服务端知道，即使客户端暴露出来，别人也无法解密</li></ol></li><li><p>缺点：</p></li><li><p>token 过期时间较短，往往需要配合 refresh token 一起使用，refresh token 是在 access token 过期时用来重新获取 token 的</p></li></ol><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><blockquote><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络上以 JSON 格式安全地传输信息。JWT 可以被用于身份验证（Authentication）和信息传递，通常用于通过网络在用户和服务器之间传递信息，以便在系统之间进行身份验证。</p></blockquote><h4 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h4><blockquote><p>JWT 由三部分组成，它们通过点号（.）连接在一起：Header.Payload.Signature</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//JWT编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br>  .<span class="hljs-property">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br>  .<span class="hljs-property">UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q</span><br></code></pre></td></tr></table></figure><h5 id="header-头部"><a href="#header-头部" class="headerlink" title="header(头部)"></a>header(头部)</h5><p>jwt 的头部承载两部分信息：</p><ol><li>声明类型，这里是 jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;typ&#x27;</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,<br>  <span class="hljs-string">&#x27;alg&#x27;</span>: <span class="hljs-string">&#x27;HS256&#x27;</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br></code></pre></td></tr></table></figure><h5 id="playload-载荷"><a href="#playload-载荷" class="headerlink" title="playload(载荷)"></a>playload(载荷)</h5><p>有效信息包含三个部分</p><ol><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9<br></code></pre></td></tr></table></figure><h5 id="signature-签证"><a href="#signature-签证" class="headerlink" title="signature(签证)"></a>signature(签证)</h5><p>签证信息由三部分组成：</p><ol><li>header (base64 后的)</li><li>payload (base64 后的)</li><li>secret</li></ol><p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成的字符串(头部在前)，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UQmqAUhUrpDVV</span>2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q<br></code></pre></td></tr></table></figure><h4 id="JWT-认证流程"><a href="#JWT-认证流程" class="headerlink" title="JWT 认证流程"></a>JWT 认证流程</h4><ol><li>用户身份验证：<br>用户提供身份信息（例如用户名和密码）进行身份验证。<br>服务器验证用户身份，如果验证通过，生成 JWT。</li><li>生成 JWT：<br>服务器使用用户的信息创建一个包含用户标识的 JWT。<br>JWT 的结构为 Header.Payload.Signature。</li><li>返回 JWT：<br>服务器将生成的 JWT 返回给客户端。</li><li>客户端存储 JWT：<br>客户端通常将收到的 JWT 存储在本地，例如在浏览器的 localStorage、sessionStorage 中，或者在移动应用程序的本地存储中。</li><li>在后续请求中携带 JWT：<br>客户端在后续的请求中携带 JWT，通常通过在请求头中添加 Authorization 字段，值为 Bearer <JWT>。</JWT></li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">http<br>Copy code<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...<br></code></pre></td></tr></table></figure><ol><li>服务器验证 JWT：<br>服务器在接收到请求时，从请求头中提取 JWT。<br>服务器使用事先共享的密钥（或公钥，对于使用非对称加密的情况）验证 JWT 的签名，确保令牌的真实性。<br>如果签名验证通过，服务器解析 JWT 中的负载数据，获取用户信息。</li><li>处理请求：<br>服务器根据 JWT 中的用户信息处理请求，进行相应的操作。</li></ol><h2 id="3-JWT-如何进行身份鉴权"><a href="#3-JWT-如何进行身份鉴权" class="headerlink" title="3. JWT 如何进行身份鉴权"></a>3. JWT 如何进行身份鉴权</h2><blockquote><p>见 2 的 JWT 认证流程</p></blockquote><h2 id="4-JWT-比-sessionid-有什么优势"><a href="#4-JWT-比-sessionid-有什么优势" class="headerlink" title="4. JWT 比 sessionid 有什么优势"></a>4. JWT 比 sessionid 有什么优势</h2><ol><li>跨域： JWT 可以更轻松地在不同域之间传递，因为它是一个基于标准的跨域解决方案。在前后端分离的架构中，前端应用通常运行在一个不同的域或子域上，而 JWT 可以通过 HTTP 头或请求参数轻松传递给服务器。</li><li>无状态： JWT 是无状态的，所有需要的信息都包含在 token 本身中。相比之下，Session ID 通常需要在服务端进行存储，从而引入了服务端的状态维护成本。JWT 的无状态性使其更容易在分布式环境中扩展。</li><li>可扩展性： JWT 本身是一个开放标准，支持自定义声明和附加信息。这使得它更具有灵活性和可扩展性，可以适应各种场景的需求。Session ID 则可能需要更多的定制实现。</li></ol><p>面试官问到这里的时候说看来你准备的挺充分的，我们直接上手写代码吧-_-……</p><h2 id="后面手撕题目："><a href="#后面手撕题目：" class="headerlink" title="后面手撕题目："></a>后面手撕题目：</h2><h2 id="5-找到一句英文句子中最长的单词，这里需要考虑到特殊字符的情况"><a href="#5-找到一句英文句子中最长的单词，这里需要考虑到特殊字符的情况" class="headerlink" title="5. 找到一句英文句子中最长的单词，这里需要考虑到特殊字符的情况"></a>5. 找到一句英文句子中最长的单词，这里需要考虑到特殊字符的情况</h2><h2 id="6-将英文句子中的单词进行翻转"><a href="#6-将英文句子中的单词进行翻转" class="headerlink" title="6. 将英文句子中的单词进行翻转"></a>6. 将英文句子中的单词进行翻转</h2><h2 id="7-场景题：如何设计一个类似多级菜单页面的文件操作系统页面"><a href="#7-场景题：如何设计一个类似多级菜单页面的文件操作系统页面" class="headerlink" title="7. 场景题：如何设计一个类似多级菜单页面的文件操作系统页面"></a>7. 场景题：如何设计一个类似多级菜单页面的文件操作系统页面</h2><p>作者：给我一个 offer 又能怎样<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/0cb225a2d66747bf8bd00e8c33e966cc">https://www.nowcoder.com/feed/main/detail/0cb225a2d66747bf8bd00e8c33e966cc</a><br>来源：牛客网</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview-js-2</title>
    <link href="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/"/>
    <url>/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-js"><a href="#🍭-面试-js" class="headerlink" title="🍭 面试-js"></a>🍭 面试-js</h1><h2 id="1-ajax-是什么？怎么实现的？有什么优缺点？-fetch-和-xmlhttprequest"><a href="#1-ajax-是什么？怎么实现的？有什么优缺点？-fetch-和-xmlhttprequest" class="headerlink" title="1.ajax 是什么？怎么实现的？有什么优缺点？(fetch 和 xmlhttprequest)"></a>1.ajax 是什么？怎么实现的？有什么优缺点？(fetch 和 xmlhttprequest)</h2><blockquote><p>AJAX（Asynchronous JavaScript and XML）是一种用于在浏览器和服务器之间进行异步数据交互的技术。它允许在不重新加载整个页面的情况下，通过在后台与服务器进行数据交换，更新部分页面内容。</p></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li>创建 ajax 对象（XMLHttpRequest&#x2F;ActiveXObject(Microsoft.XMLHttp)）</li><li>用 open()方法设置请求方式和请求地址连接服务器</li><li>用 send()方法发送请求</li><li>当 ajax 对象完成第四步（onreadystatechange）数据接收完成，判断 http 响应状态（status）200-300 之间或者 304（缓存）执行回调函数</li><li>通过 ajax 对象的 responseText 属性获取服务器返回的数据</li><li>处理数据更新页面</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> == <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)<br>  &#125;<br>&#125;<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;example.com/api/data&#x27;</span>, <span class="hljs-literal">true</span>)<br>xhr.<span class="hljs-title function_">send</span>()<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>异步通信： AJAX 支持异步通信，可以在不阻塞页面的情况下向服务器发起请求。</li><li>局部更新： 可以通过局部更新页面内容，而无需重新加载整个页面，提高用户体验。</li><li>减少带宽消耗： 只传输需要的数据，减少了不必要的带宽消耗。</li></ol><p><strong>缺点：</strong></p><ol><li>浏览器兼容性： 早期浏览器对 AJAX 的支持不一致，但随着现代浏览器的普及，这个问题逐渐减轻。</li><li>SEO 难度： 搜索引擎对于 AJAX 加载的内容的索引和处理相对复杂，可能影响搜索引擎优化。</li><li>安全性： 由于跨域请求的安全性问题，存在一些安全风险，需要注意跨站请求伪造（CSRF）等攻击。</li></ol><h2 id="2-get-和-post-的区别"><a href="#2-get-和-post-的区别" class="headerlink" title="2. get 和 post 的区别"></a>2. get 和 post 的区别</h2><blockquote><p>GET 用于从服务器获取数据<br><br>POST 用于向服务器提交数据</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>数据方面</strong></p><ol><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li></ol><p><strong>安全方面</strong></p><ol><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>POST 参数不会被保存在浏览器历史或 web 服务器日志中。</li></ol><p><strong>缓存方面</strong></p><ol><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。</li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li></ol><h2 id="3-promise-的内部原理和优缺点"><a href="#3-promise-的内部原理和优缺点" class="headerlink" title="3. promise 的内部原理和优缺点"></a>3. promise 的内部原理和优缺点</h2><h3 id="Promise-基本特性"><a href="#Promise-基本特性" class="headerlink" title="Promise 基本特性"></a>Promise 基本特性</h3><ol><li>Promise 有三种状态：pending(进行中)、fulfilled(已成功)、rejected(已失败)</li><li>Promise 对象接受一个回调函数作为参数, 该回调函数接受两个参数，分别是成功时的回调 resolve 和失败时的回调 reject；另外 resolve 的参数除了正常值以外， 还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例。</li><li>then 方法返回一个新的 Promise 实例，并接收两个参数 onResolved(fulfilled 状态的回调)；onRejected(rejected 状态的回调，该参数可选)</li><li>catch 方法返回一个新的 Promise 实例</li><li>finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数</li><li>Promise.all()方法将多个多个 Promise 实例，包装成一个新的 Promise 实例，该方法接受一个由 Promise 对象组成的数组作为参数(Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例)，注意参数中只要有一个实例触发 catch 方法，都会触发 Promise.all()方法返回的新的实例的 catch 方法，如果参数中的某个实例本身调用了 catch 方法，将不会触发 Promise.all()方法返回的新实例的 catch 方法</li><li>Promise.race()方法的参数与 Promise.all 方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给 Promise.race()方法，并将返回值作为 Promise.race()方法产生的 Promise 实例的返回值</li><li>Promise.resolve()将现有对象转为 Promise 对象，如果该方法的参数为一个 Promise 对象，Promise.resolve()将不做任何处理；如果参数 thenable 对象(即具有 then 方法)，Promise.resolve()将该对象转为 Promise 对象并立即执行 then 方法；如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 fulfilled，其参数将会作为 then 方法中 onResolved 回调函数的参数，如果 Promise.resolve 方法不带参数，会直接返回一个 fulfilled 状态的 Promise 对象。需要注意的是，立即 resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</li><li>Promise.reject()同样返回一个新的 Promise 对象，状态为 rejected，无论传入任何参数都将作为 reject()的参数</li></ol><h3 id="Promise-优点"><a href="#Promise-优点" class="headerlink" title="Promise 优点"></a>Promise 优点</h3><ol><li>统一异步 API<br>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和手法。</li><li>Promise 与事件对比<br>和事件相比较， Promise 更适合处理一次性的结果。在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。 Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</li><li>Promise 与回调对比<br>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</li><li>Promise 带来的额外好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步的工具，比如 Array.prototype.map() ）。</li></ol><h3 id="Promise-缺点"><a href="#Promise-缺点" class="headerlink" title="Promise 缺点"></a>Promise 缺点</h3><ol><li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li><li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li><li>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经走完了，所以 Promise 的报错堆栈上下文不太友好。</li></ol><h3 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&#x27;rejected&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">resolvePromise</span> = (<span class="hljs-params">promise, x, resolve, reject</span>) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (x === promise) &#123;<br>    <span class="hljs-comment">// If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;循环引用&#x27;</span>))<br>  &#125;<br>  <span class="hljs-comment">// if x is an object or function,</span><br>  <span class="hljs-keyword">if</span> ((x !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;object&#x27;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-comment">// If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span><br>    <span class="hljs-keyword">let</span> called<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><br>      <span class="hljs-keyword">let</span> then = x.<span class="hljs-property">then</span> <span class="hljs-comment">// Let then be x.then</span><br>      <span class="hljs-comment">// If then is a function, call it with x as this</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// If/when resolvePromise is called with a value y, run [[Resolve]](promise, y)</span><br>        <span class="hljs-comment">// If/when rejectPromise is called with a reason r, reject promise with r.</span><br>        then.<span class="hljs-title function_">call</span>(<br>          x,<br>          <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            <span class="hljs-title function_">resolvePromise</span>(promise, y, resolve, reject)<br>          &#125;,<br>          <span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>            called = <span class="hljs-literal">true</span><br>            <span class="hljs-title function_">reject</span>(r)<br>          &#125;<br>        )<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// If then is not a function, fulfill promise with x.</span><br>        <span class="hljs-title function_">resolve</span>(x)<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-keyword">if</span> (called) <span class="hljs-keyword">return</span><br>      called = <span class="hljs-literal">true</span><br>      <span class="hljs-title function_">reject</span>(e)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// If x is not an object or function, fulfill promise with x</span><br>    <span class="hljs-title function_">resolve</span>(x)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">excutor</span>) &#123;<br>  <span class="hljs-keyword">let</span> that = <span class="hljs-variable language_">this</span> <span class="hljs-comment">// 缓存当前promise实例例对象</span><br>  that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">PENDING</span> <span class="hljs-comment">// 初始状态</span><br>  that.<span class="hljs-property">value</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// fulfilled状态时 返回的信息</span><br>  that.<span class="hljs-property">reason</span> = <span class="hljs-literal">undefined</span> <span class="hljs-comment">// rejected状态时 拒绝的原因</span><br>  that.<span class="hljs-property">onFulfilledCallbacks</span> = [] <span class="hljs-comment">// 存储fulfilled状态对应的onFulfilled函数</span><br>  that.<span class="hljs-property">onRejectedCallbacks</span> = [] <span class="hljs-comment">// 存储rejected状态对应的onRejected函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// value成功态时接收的终值</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject)<br>    &#125;<br>    <span class="hljs-comment">// 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 调⽤用resolve 回调对应onFulfilled函数</span><br>      <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 只能由pending状态 =&gt; fulfilled状态 (避免调⽤用多次resolve reject)</span><br>        that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span><br>        that.<span class="hljs-property">value</span> = value<br>        that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">value</span>))<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>) &#123;<br>    <span class="hljs-comment">// reason失败态时接收的拒因</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 调⽤用reject 回调对应onRejected函数</span><br>      <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 只能由pending状态 =&gt; rejected状态 (避免调⽤用多次resolve reject)</span><br>        that.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECTED</span><br>        that.<span class="hljs-property">reason</span> = reason<br>        that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(that.<span class="hljs-property">reason</span>))<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 捕获在excutor执⾏行行器器中抛出的异常</span><br>  <span class="hljs-comment">// new Promise((resolve, reject) =&gt; &#123;</span><br>  <span class="hljs-comment">//     throw new Error(&#x27;error in excutor&#x27;)</span><br>  <span class="hljs-comment">// &#125;)</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">excutor</span>(resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-title function_">reject</span>(e)<br>  &#125;<br>&#125;<br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>  <span class="hljs-keyword">const</span> that = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">let</span> newPromise<br>  <span class="hljs-comment">// 处理理参数默认值 保证参数后续能够继续执⾏行行</span><br>  onFulfilled =<br>    <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ? onFulfilled : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value<br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span><br>      ? onRejected<br>      : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">throw</span> reason<br>        &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">FULFILLED</span>) &#123;<br>    <span class="hljs-comment">// 成功态</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(that.<span class="hljs-property">value</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject) <span class="hljs-comment">//新的promise resolve 上⼀一个onFulfilled的返回值</span><br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e) <span class="hljs-comment">// 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);</span><br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-comment">// 失败态</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(that.<span class="hljs-property">reason</span>)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>  <span class="hljs-keyword">if</span> (that.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-comment">// 等待态</span><br>    <span class="hljs-comment">// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br>    <span class="hljs-keyword">return</span> (newPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      that.<span class="hljs-property">onFulfilledCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onFulfilled</span>(value)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>      that.<span class="hljs-property">onRejectedCallbacks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">let</span> x = <span class="hljs-title function_">onRejected</span>(reason)<br>          <span class="hljs-title function_">resolvePromise</span>(newPromise, x, resolve, reject)<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          <span class="hljs-title function_">reject</span>(e)<br>        &#125;<br>      &#125;)<br>    &#125;))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-promise-和-async-x2F-await-的区别"><a href="#4-promise-和-async-x2F-await-的区别" class="headerlink" title="4. promise 和 async&#x2F;await 的区别"></a>4. promise 和 async&#x2F;await 的区别</h2><h3 id="同"><a href="#同" class="headerlink" title="同"></a>同</h3><ol><li>都是处理异步请求</li><li>async 返回的是一个 promise 对象</li></ol><h3 id="异"><a href="#异" class="headerlink" title="异"></a>异</h3><ol><li>promise 是 es6,async&#x2F;await 是 es7</li><li>async&#x2F;await 是基于 promise 的，是 promise 的语法糖</li><li>async&#x2F;await 使得异步代码看起来像同步代码，避免了回调地狱</li><li>async&#x2F;await 可以捕获 promise 的异常，promise 需要使用 catch 捕获异常</li></ol><h2 id="5-浏览器的存储方式有哪些"><a href="#5-浏览器的存储方式有哪些" class="headerlink" title="5. 浏览器的存储方式有哪些"></a>5. 浏览器的存储方式有哪些</h2><blockquote><p>cookies,localStorage,sessionStorage,indexedDB</p></blockquote><h3 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h3><blockquote><p>服务器发送到用户浏览器并保存在本地的一小块数据</p></blockquote><ol><li>特点： 小容量（通常限制在 4KB）、每个请求都会携带到服务器。</li><li>用途： 用于存储少量的文本数据，例如会话信息、用户偏好设置等。</li><li>生命周期： 可以设置失效时间，如果在浏览器没有设置失效时间，那么 cookie 将会在浏览器关闭时失效。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 document.cookie 进行读写。</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> =<br>  <span class="hljs-string">&#x27;username=John Doe; expires=Thu, 18 Dec 2022 12:00:00 UTC; path=/&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><blockquote><p>本地存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 除非被清除，否则永久保存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 localStorage 对象进行读写。</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><blockquote><p>会话存储空间</p></blockquote><ol><li>特点： 大容量（通常限制在 5MB）。</li><li>用途： 用于存储本地数据，例如用户信息等。</li><li>生命周期： 仅在当前会话下有效，关闭页面或浏览器后被清除。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 sessionStorage 对象进行读写。</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="indexedDB"><a href="#indexedDB" class="headerlink" title="indexedDB"></a>indexedDB</h3><blockquote><p>浏览器本地数据库</p></blockquote><ol><li>容量：相对较大，适用于存储大量结构化数据。</li><li>生命周期： 永久存储，不受会话影响。</li><li>用途： 用于存储大量结构化数据，例如浏览器端缓存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// API： 通过 indexedDB 对象进行读写。</span><br><span class="hljs-keyword">var</span> request = indexedDB.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;MyTestDatabase&#x27;</span>)<br>request.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-comment">// 错误处理逻辑</span><br>&#125;<br>request.<span class="hljs-property">onsuccess</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>  <span class="hljs-keyword">var</span> db = event.<span class="hljs-property">target</span>.<span class="hljs-property">result</span><br>  <span class="hljs-comment">// 成功处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="token-token-存储在哪里-token-怎么传递"><a href="#token-token-存储在哪里-token-怎么传递" class="headerlink" title="token,token 存储在哪里,token 怎么传递"></a>token,token 存储在哪里,token 怎么传递</h3><blockquote><p>Token（令牌）是在身份验证（Authentication）和授权（Authorization）过程中用于验证用户身份的一种方式。(访问资源对凭证)</p></blockquote><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><ol><li>存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台</li><li>存储在 cookie 中，让它自动发送，不过缺点就是不能跨域</li><li>拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里面。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>用户登录： 用户提供用户名和密码进行登录。</li><li>认证服务器验证： 服务器验证用户提供的用户名和密码，如果验证通过，生成一个令牌。</li><li>令牌返回给客户端： 服务器将生成的令牌返回给客户端。</li><li>客户端存储令牌： 客户端通常将令牌存储在本地，如浏览器的 localStorage、sessionStorage 或者内存中。</li><li>后续请求携带令牌： 客户端在后续的请求中携带令牌，通常通过 HTTP 头部的 Authorization 字段或者其他方式。</li></ol><h2 id="6-页面渲染的过程"><a href="#6-页面渲染的过程" class="headerlink" title="6. 页面渲染的过程"></a>6. 页面渲染的过程</h2><h3 id="1-DNS-查询"><a href="#1-DNS-查询" class="headerlink" title="1.DNS 查询"></a>1.DNS 查询</h3><p>DNS（Domain Name System）查询是将用户输入的域名转换为对应的 IP 地址的过程。当用户在浏览器中输入一个网址时，浏览器会向本地 DNS 服务器发起查询请求，如果本地 DNS 服务器缓存中没有对应的 IP 地址，它会依次向根域名服务器、顶级域名服务器、权威域名服务器发起查询，最终获得目标域名对应的 IP 地址。</p><h3 id="2-TCP-三次握手"><a href="#2-TCP-三次握手" class="headerlink" title="2.TCP 三次握手"></a>2.TCP 三次握手</h3><ol><li>客户端向服务器发送 SYN 请求： 客户端发送一个带有 SYN（同步）标志的数据包，表明客户端希望建立连接。</li><li>服务器回应 SYN+ACK： 服务器收到客户端的 SYN 请求后，会回应一个带有 SYN 和 ACK（确认）标志的数据包，表明收到了客户端的请求并同意建立连接。</li><li>客户端发送 ACK： 客户端收到服务器的 SYN+ACK 后，会发送一个带有 ACK 标志的数据包，表示连接建立完成。</li></ol><h3 id="3-TLS-协商"><a href="#3-TLS-协商" class="headerlink" title="3.TLS 协商"></a>3.TLS 协商</h3><blockquote><p>TLS（Transport Layer Security）是一种加密通信协议，用于保护数据在网络上传输的<br>安全性。TLS 协商是在 TCP 连接建立后，进行安全传输配置的过程：</p></blockquote><ol><li>客户端发送 ClientHello： 客户端向服务器发送包含支持的加密算法等信息的 ClientHello 报文。</li><li>服务器回应 ServerHello： 服务器收到 ClientHello 后，选择合适的加密算法，并回应一个包含服务器证书的 ServerHello 报文。</li><li>双方协商密钥： 服务器发送一个包含公钥的证书，客户端验证证书的有效性，并生成一个预主秘密（pre-master secret），使用服务器公钥加密后发送给服务器。双方使用预主秘密生成共享的主秘密。</li><li>完成协商： 双方使用协商得到的密钥进行加密通信，握手过程完成。</li></ol><h3 id="4-页面渲染"><a href="#4-页面渲染" class="headerlink" title="4.页面渲染"></a>4.页面渲染</h3><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/reflow.png" class title="This is an test image"><ol><li>构建 DOM 树：<br>渲染引擎使用 HTML 解析器（调用 XML 解析器）解析 HTML 文档，将各个 HTML 元素逐个转化成 DOM 节点，从而生成 DOM 树；<br>HTML 标记被解析为 DOM 节点，形成树状结构，表示文档的层次结构。</li><li>构建 CSSOM 树：<br>CSS 解析器解析 CSS，并将其转化为 CSS 对象，将这些 CSS 对象组装起来，构建 CSSOM 树；<br>CSSOM 树表示文档中的样式信息，包括样式的规则和层次关系。</li><li>合并 DOM 和 CSSOM 树为渲染树：<br>将构建好的 DOM 树和 CSSOM 树合并，形成渲染树（Render Tree）。<br>渲染树包含了需要被渲染的节点和其样式信息，但不包含不可见的元素（例如 display: none 的元素）。</li><li>计算布局（Layout）：<br>根据渲染树的信息，计算每个节点在屏幕上的位置和大小。<br>计算布局过程也被称为“回流”（reflow）。</li><li>绘制（Paint）：<br>使用计算好的布局信息，将页面上的每个节点绘制到屏幕上。<br>绘制过程也被称为“重绘”（repaint）。</li><li>显示（Display）：<br>将绘制的内容显示在用户的屏幕上。</li></ol><h2 id="7-svg-格式了解"><a href="#7-svg-格式了解" class="headerlink" title="7. svg 格式了解"></a>7. svg 格式了解</h2><blockquote><p>可缩放矢量图形（Scalable Vector Graphics，SVG）基于 XML 标记语言，用于描述二维的矢量图形</p></blockquote><p><strong>特点：</strong><br>SVG 是一种灵活、可伸缩且强大的图形描述语言，特别适合用于 Web 开发中创建可交互的矢量图形</p><h2 id="8-JWT"><a href="#8-JWT" class="headerlink" title="8.JWT"></a>8.JWT</h2><blockquote><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络上以 JSON 格式安全地传输信息。JWT 可以被用于身份验证（Authentication）和信息传递，通常用于通过网络在用户和服务器之间传递信息，以便在系统之间进行身份验证。</p></blockquote><h3 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h3><blockquote><p>JWT 由三部分组成，它们通过点号（.）连接在一起：Header.Payload.Signature</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//JWT编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br>  .<span class="hljs-property">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br>  .<span class="hljs-property">UQmqAUhUrpDVV2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q</span><br></code></pre></td></tr></table></figure><h4 id="header-头部"><a href="#header-头部" class="headerlink" title="header(头部)"></a>header(头部)</h4><p>jwt 的头部承载两部分信息：</p><ol><li>声明类型，这里是 jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&#x27;typ&#x27;</span>: <span class="hljs-string">&#x27;JWT&#x27;</span>,<br>  <span class="hljs-string">&#x27;alg&#x27;</span>: <span class="hljs-string">&#x27;HS256&#x27;</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9<br></code></pre></td></tr></table></figure><h4 id="playload-载荷"><a href="#playload-载荷" class="headerlink" title="playload(载荷)"></a>playload(载荷)</h4><p>有效信息包含三个部分</p><ol><li>标准中注册的声明</li><li>公共的声明</li><li>私有的声明</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//base64编码</span><br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9<br></code></pre></td></tr></table></figure><h4 id="signature-签证"><a href="#signature-签证" class="headerlink" title="signature(签证)"></a>signature(签证)</h4><p>签证信息由三部分组成：</p><ol><li>header (base64 后的)</li><li>payload (base64 后的)</li><li>secret</li></ol><p>这个部分需要 base64 加密后的 header 和 base64 加密后的 payload 使用.连接组成的字符串(头部在前)，然后通过 header 中声明的加密方式进行加盐 secret 组合加密，然后就构成了 jwt 的第三部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">UQmqAUhUrpDVV</span>2ST7mZKyLTomVfg7sYkEjmdDI5XF8Q<br></code></pre></td></tr></table></figure><h3 id="JWT-认证流程"><a href="#JWT-认证流程" class="headerlink" title="JWT 认证流程"></a>JWT 认证流程</h3><ol><li>用户身份验证：<br>用户提供身份信息（例如用户名和密码）进行身份验证。<br>服务器验证用户身份，如果验证通过，生成 JWT。</li><li>生成 JWT：<br>服务器使用用户的信息创建一个包含用户标识的 JWT。<br>JWT 的结构为 Header.Payload.Signature。</li><li>返回 JWT：<br>服务器将生成的 JWT 返回给客户端。</li><li>客户端存储 JWT：<br>客户端通常将收到的 JWT 存储在本地，例如在浏览器的 localStorage、sessionStorage 中，或者在移动应用程序的本地存储中。</li><li>在后续请求中携带 JWT：<br>客户端在后续的请求中携带 JWT，通常通过在请求头中添加 Authorization 字段，值为 Bearer <JWT>。</JWT></li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http">http<br>Copy code<br><span class="hljs-keyword">GET</span> <span class="hljs-string">/api/data</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...<br></code></pre></td></tr></table></figure><ol><li>服务器验证 JWT：<br>服务器在接收到请求时，从请求头中提取 JWT。<br>服务器使用事先共享的密钥（或公钥，对于使用非对称加密的情况）验证 JWT 的签名，确保令牌的真实性。<br>如果签名验证通过，服务器解析 JWT 中的负载数据，获取用户信息。</li><li>处理请求：<br>服务器根据 JWT 中的用户信息处理请求，进行相应的操作。</li></ol><h2 id="9-NPM"><a href="#9-NPM" class="headerlink" title="9.NPM"></a>9.NPM</h2><blockquote><p>NPM（Node Package Manager）是 Node.js 的包管理工具，用于安装、共享、管理 Node.js 模块.</p></blockquote><p><strong>npm 由三个不同的组件组成：</strong></p><ol><li>网站</li><li>命令行界面 (CLI)</li><li>注册表</li></ol><h2 id="10-HTTP-请求头、协议头"><a href="#10-HTTP-请求头、协议头" class="headerlink" title="10.HTTP 请求头、协议头"></a>10.HTTP 请求头、协议头</h2><h3 id="HTTP-请求包括："><a href="#HTTP-请求包括：" class="headerlink" title="HTTP 请求包括："></a>HTTP 请求包括：</h3><ol><li>请求行：请求的 http 方法+URL+http 的版本号</li><li>请求头</li></ol><ol><li>Accept： 览器支持的 MIME 媒体类型, 比如 text&#x2F;html,application&#x2F;json,image&#x2F;webp,&#x2F; 等</li><li>Accept-Encoding: 浏览器发给服务器,声明浏览器支持的编码类型，gzip, deflate</li><li>Accept-Language: 客户端接受的语言格式,比如 zh-CN</li><li>Connection: keep-alive , 开启 HTTP 持久连接</li><li>Host：服务器的域名</li><li>Origin：告诉服务器请求从哪里发起的，仅包括协议和域名 CORS 跨域请求中可以看到 response 有对应的 header，Access-Control-Allow-Origin</li><li>Referer：告诉服务器请求的原始资源的 URI，其用于所有类型的请求，并且包括：协议+域名+查询参数； 很多抢购服务会用这个做限制，必须通过某个入来进来才有效</li><li>User-Agent: 服务器通过这个请求头判断用户的软件的应用类型、操作系统、软件开发商以及版本号、浏览器内核信息等； 风控系统、反作弊系统、反爬虫系统等基本会采集这类信息做参考</li><li>Cookie: 表示服务端给客户端传的 http 请求状态,也是多个 key&#x3D;value 形式组合，比如登录后的令牌等</li><li>Content-Type： HTTP 请求提交的内容类型，一般只有 post 提交时才需要设置，比如文件上传，表单提交等。用来指定不同格式的请求格式响应信息俗称 MIME 媒体类型</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/path/to/resource</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US,en;q=0.9<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ol start="3"><li>请求体：（key&#x3D;value）</li></ol><h3 id="HTTP-响应包括："><a href="#HTTP-响应包括：" class="headerlink" title="HTTP 响应包括："></a>HTTP 响应包括：</h3><ol><li>状态行：http 协议的版本+状态码+描述</li><li>响应头</li></ol><ol><li>Allow: 服务器支持哪些请求方法</li><li>Content-Length: 响应体的字节长度</li><li>Content-Type: 响应体的 MIME 类型</li><li>Content-Encoding: 设置数据使用的编码类型</li><li>Date: 设置消息发送的日期和时间</li><li>Expires: 设置响应体的过期时间,一个 GMT 时间，表示该缓存的有效时间</li><li>cache-control: Expires 的作用一致，都是指明当前资源的有效期, 控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据,优先级高于 Expires,控制粒度更细，如 max-age&#x3D;240，即 4 分钟</li><li>Location：表示客户应当到哪里去获取资源，一般同时设置状态代码为 3xx</li><li>Server: 服务器名称</li><li>Transfer-Encoding：chunked 表示输出的内容长度不能确定，静态网页一般没，基本出现在动态网页里面</li><li>Access-Control-Allow-Origin: 定哪些站点可以参与跨站资源共享</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 14 Sep 2021 12:00:00 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.4.41 (Unix)<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>1234<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br></code></pre></td></tr></table></figure><ol start="3"><li>响应体：web 服务器把要发送给客户端的文档信息放在响应体</li></ol><h2 id="11-浏览器的缓存机制"><a href="#11-浏览器的缓存机制" class="headerlink" title="11.浏览器的缓存机制"></a>11.浏览器的缓存机制</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><blockquote><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</p></blockquote><h4 id="强制缓存的情况主要有三种-暂不分析协商缓存过程-，如下："><a href="#强制缓存的情况主要有三种-暂不分析协商缓存过程-，如下：" class="headerlink" title="强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下："></a>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</h4><ol><li><p>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q1.png" class title="This is an test image"></li><li><p>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q2.png" class title="This is an test image"></li><li><p>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/q3.png" class title="This is an test image"></li></ol><h4 id="控制强制缓存的字段分别是-Expires-和-Cache-Control"><a href="#控制强制缓存的字段分别是-Expires-和-Cache-Control" class="headerlink" title="控制强制缓存的字段分别是 Expires 和 Cache-Control"></a>控制强制缓存的字段分别是 Expires 和 Cache-Control</h4><blockquote><p>其中 Cache-Control 优先级比 Expires 高</p></blockquote><ol><li>Expires: 缓存过期时间，用于指定资源的到期时间，是服务器端的具体的时间点，即到了这个时间点，缓存就会失效，需要重新请求</li><li>Cache-Control: 控制缓存的行为，比如缓存过期时间，是否需要重新验证，是否需要重新请求等</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=31536000<br></code></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><blockquote><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</p></blockquote><h4 id="主要有以下两种情况："><a href="#主要有以下两种情况：" class="headerlink" title="主要有以下两种情况："></a>主要有以下两种情况：</h4><ol><li><p>协商缓存生效，返回 304</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/x1.png" class title="This is an test image"></li><li><p>协商缓存失效，返回 200 和请求结果结果</p><img src="/2024/01/30/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js-2/x2.png" class title="This is an test image"></li></ol><h4 id="控制协商缓存的字段分别有：Last-Modified-x2F-If-Modified-Since-和-Etag-x2F-If-None-Match"><a href="#控制协商缓存的字段分别有：Last-Modified-x2F-If-Modified-Since-和-Etag-x2F-If-None-Match" class="headerlink" title="控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match"></a>控制协商缓存的字段分别有：Last-Modified &#x2F; If-Modified-Since 和 Etag &#x2F; If-None-Match</h4><blockquote><p>其中 Etag &#x2F; If-None-Match 优先级比 Last-Modified &#x2F; If-Modified-Since 高</p></blockquote><ol><li>Last-Modified &#x2F; If-Modified-Since: 服务器在响应请求时，告诉浏览器资源的最后修改时间，浏览器下次请求时，通过请求头 If-Modified-Since 把这个时间发送给服务器，由服务器根据这个时间判断资源是否修改过</li><li>Etag &#x2F; If-None-Match: Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成），浏览器下次请求时，通过请求头 If-None-Match 把这个唯一标识发送给服务器，由服务器根据这个唯一标识判断资源是否修改过</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Wed, 21 Oct 2021 07:28:00 GMT<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>&quot;5f8d9e9e-2a4d&quot;<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;5f8d9e9e-2a4d&quot;<br></code></pre></td></tr></table></figure><h2 id="12-同源策略和跨域"><a href="#12-同源策略和跨域" class="headerlink" title="12.同源策略和跨域"></a>12.同源策略和跨域</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><blockquote><p>同源策略是一个重要的安全策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互<br>如果两个 URL 的协议、端口（如果有指定的话）和主机都相同的话，则这两个 URL 是同源的</p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">http://store.company.com/dir2/other.html<br>协议：http<br>主机：store.company.com<br>端口：80<br></code></pre></td></tr></table></figure><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><ol><li>原理：利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签 src 属性，发送带有 callback 参数的 GET 请求，服务端将接口返回数据拼凑到 callback 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据.</li><li>缺点：只能发送 get 一种请求。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//原生JS</span><br><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)<br>script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span><br><br><span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span><br>script.<span class="hljs-property">src</span> =<br>  <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script)<br><br><span class="hljs-comment">// 回调执行函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res))<br>&#125;<br><br><span class="hljs-comment">//Vue axios</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span> = axios<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span><br>  .<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>  &#125;)<br><br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h4 id="CORS”跨域资源共享”（Cross-origin-resource-sharing）"><a href="#CORS”跨域资源共享”（Cross-origin-resource-sharing）" class="headerlink" title="CORS”跨域资源共享”（Cross-origin resource sharing）"></a>CORS”跨域资源共享”（Cross-origin resource sharing）</h4><ol><li>原理：它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制</li><li>方法：服务端需要设置响应头中的 Access-Control-Allow-Origin 字段来指定允许的源。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 服务端设置 CORS</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()<br><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://yourdomain.com&#x27;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;GET, POST, PUT, DELETE&#x27;</span>)<br>  res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type&#x27;</span>)<br>  <span class="hljs-title function_">next</span>()<br>&#125;)<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/data&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, CORS!&#x27;</span> &#125;)<br>&#125;)<br><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="代理服务器（Proxy）"><a href="#代理服务器（Proxy）" class="headerlink" title="代理服务器（Proxy）:"></a>代理服务器（Proxy）:</h4><p>在同域的服务器上设置一个代理，由代理服务器去请求其他域上的资源，再将结果返回给前端。这样，前端只需要请求同域的资源，就能避免跨域问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">devServer</span>:&#123;<br><span class="hljs-attr">proxy</span>:&#123;<br><span class="hljs-comment">// 请求前缀/api，只有加了/api前缀的请求才会走代理(前端自定义)</span><br><span class="hljs-string">&#x27;/api&#x27;</span>:&#123;<br><span class="hljs-attr">target</span>:<span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<br><span class="hljs-attr">pathReweite</span>:&#123;<span class="hljs-string">&#x27;^/api&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;,<span class="hljs-comment">//重写</span><br><span class="hljs-comment">//ws:true,//用于支持websocket</span><br><span class="hljs-attr">changeOrigin</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//用于控制请求头中的host值，默认true，react中默认false</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="WebSocket-协议跨域"><a href="#WebSocket-协议跨域" class="headerlink" title="WebSocket 协议跨域"></a>WebSocket 协议跨域</h4><blockquote><p>它实现了浏览器与服务器全双工通信，同时允许跨域通讯</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>user input：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">var</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 连接成功处理</span></span><br><span class="language-javascript">  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端消息</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data from server: ---&gt; &#x27;</span> + msg)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端关闭</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server socket has closed.&#x27;</span>)</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">onblur</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="13-防抖和节流"><a href="#13-防抖和节流" class="headerlink" title="13.防抖和节流"></a>13.防抖和节流</h2><p><strong>作用：</strong><br>控制事件触发频率的前端优化技术，用于提高性能和避免过度频繁的函数调用。</p><h3 id="防抖-Debouncing"><a href="#防抖-Debouncing" class="headerlink" title="防抖(Debouncing)"></a>防抖(Debouncing)</h3><blockquote><p>n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    &#125;, delay)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> debouncedFunction = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要防抖的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Debounced function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, debouncedFunction)<br></code></pre></td></tr></table></figure><h3 id="节流-Throttling"><a href="#节流-Throttling" class="headerlink" title="节流(Throttling)"></a>节流(Throttling)</h3><blockquote><p>n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> lastExecTime = <span class="hljs-number">0</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br><br>    <span class="hljs-keyword">if</span> (now - lastExecTime &gt;= delay) &#123;<br>      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      lastExecTime = now<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用例子</span><br><span class="hljs-keyword">const</span> throttledFunction = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 执行需要节流的操作</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Throttled function executed&#x27;</span>)<br>&#125;, <span class="hljs-number">300</span>)<br><br><span class="hljs-comment">// 在事件处理中使用</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, throttledFunction)<br></code></pre></td></tr></table></figure><h2 id="14-JSON"><a href="#14-JSON" class="headerlink" title="14.JSON"></a>14.JSON</h2><blockquote><p>一种轻量级的数据交换格式，用于在不同语言之间进行数据传输。</p></blockquote><p><strong>方法:</strong><br>在 JavaScript 中，可以使用 <code>JSON.parse()</code>方法将 JSON 字符串解析为 JavaScript 对象，使用 <code>JSON.stringify()</code> 方法将 JavaScript 对象转换为 JSON 字符串。</p><h2 id="15-数据还没有请求过来是该怎么办？"><a href="#15-数据还没有请求过来是该怎么办？" class="headerlink" title="15.数据还没有请求过来是该怎么办？"></a>15.数据还没有请求过来是该怎么办？</h2><ol><li>Loading 状态： 显示加载状态，告知用户数据正在加载中。这可以通过添加加载动画、文本或其他 UI 元素来实现。用户一般会理解在等待数据加载的过程中出现的短时期的加载状态。</li><li>占位符： 在页面上使用占位符元素，占位符元素的样式和布局应与最终加载的数据元素相似，但可以使用一些样式或文本提示来表示数据正在加载中。这可以防止页面在数据加载时发生剧烈的布局变化。</li><li>默认值： 提供默认值作为占位数据，以确保页面的一致性。当数据加载完成后，再用实际的数据替换默认值。这对于一些不是必需加载的数据项来说是一个不错的选择。</li><li>骨架屏（Skeleton Screen）： 使用骨架屏技术，以页面整体的形式展示数据加载中的状态。骨架屏是一个页面的灰度版本，用于模拟页面的布局结构，让用户感知到页面正在加载数据。</li></ol><h2 id="16-无感登录"><a href="#16-无感登录" class="headerlink" title="16.无感登录"></a>16.无感登录</h2><blockquote><p>前端需要实现 Token 的自动刷新来避免用户在使用过程中因 Token 过期而需要重新登录的情况</p></blockquote><h3 id="1-使用-setInterval-定时刷新-Token"><a href="#1-使用-setInterval-定时刷新-Token" class="headerlink" title="1. 使用 setInterval 定时刷新 Token"></a>1. 使用 setInterval 定时刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>&#125;, <span class="hljs-number">59</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h3 id="2-使用-setTimeout-延时刷新-Token"><a href="#2-使用-setTimeout-延时刷新-Token" class="headerlink" title="2. 使用 setTimeout 延时刷新 Token"></a>2. 使用 setTimeout 延时刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>&#125;, tokenExpireTime - <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><h3 id="3-使用-axios-拦截器自动刷新-Token"><a href="#3-使用-axios-拦截器自动刷新-Token" class="headerlink" title="3. 使用 axios 拦截器自动刷新 Token"></a>3. 使用 axios 拦截器自动刷新 Token</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> api = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;&lt;http://example.com/api&gt;&#x27;</span>,<br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>,<br>&#125;)<br><br>api.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">config</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> tokenExpireTime = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;tokenExpireTime&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (tokenExpireTime &amp;&amp; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() &gt; tokenExpireTime) &#123;<br>      <span class="hljs-comment">// 向后端服务器发送请求获取新的Token</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> config<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> api<br></code></pre></td></tr></table></figure><h2 id="17-大文件上传"><a href="#17-大文件上传" class="headerlink" title="17.大文件上传"></a>17.大文件上传</h2><h3 id="文件切片"><a href="#文件切片" class="headerlink" title="文件切片"></a>文件切片</h3><blockquote><p>先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可</p></blockquote><ol><li>方法 1: 使用 FormData 和 XMLHttpRequest</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, file)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传进度</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> progress = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload Progress: <span class="hljs-subst">$&#123;progress&#125;</span>%`</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">send</span>(formData)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>方法 2: 使用 Fetch API</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, file)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;/upload&#x27;</span>, <span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传进度</span></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> progress = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Upload Progress: <span class="hljs-subst">$&#123;progress&#125;</span>%`</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      xhr.<span class="hljs-title function_">send</span>(formData)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><blockquote><p>在一些暂停&#x2F;恢复的上传场景下，需要在上一次的位置接着上传</p></blockquote><ol><li>方法 1: 使用 Blob 和 Slice</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fileInput&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;uploadFile()&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">uploadFile</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> fileInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;fileInput&#x27;</span>)</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> file = fileInput.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (file) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> chunkSize = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 每次上传的分片大小（1MB）</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">uploadChunk</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> chunk = file.<span class="hljs-title function_">slice</span>(start, start + chunkSize)</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><br><span class="language-javascript">        formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;file&#x27;</span>, chunk)</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/upload&#x27;</span>, &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">body</span>: formData,</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 处理上传完成的逻辑</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Upload complete&#x27;</span>, data)</span><br><span class="language-javascript">            start += chunkSize</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (start &lt; file.<span class="hljs-property">size</span>) &#123;</span><br><span class="language-javascript">              <span class="hljs-title function_">uploadChunk</span>() <span class="hljs-comment">// 继续上传下一分片</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Upload failed&#x27;</span>, error)</span><br><span class="language-javascript">          &#125;)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-title function_">uploadChunk</span>() <span class="hljs-comment">// 开始上传第一个分片</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字节二面-id2</title>
    <link href="/2024/01/22/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2-id2/"/>
    <url>/2024/01/22/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%BA%8C%E9%9D%A2-id2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-字节二面-id2"><a href="#🍭-字节二面-id2" class="headerlink" title="🍭 字节二面-id2"></a>🍭 字节二面-id2</h1><h2 id="1、说说-position-的属性，默认为什么属性"><a href="#1、说说-position-的属性，默认为什么属性" class="headerlink" title="1、说说 position 的属性，默认为什么属性"></a>1、说说 position 的属性，默认为什么属性</h2><blockquote><p>CSS position 属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。</p></blockquote><h3 id="定位类型"><a href="#定位类型" class="headerlink" title="定位类型"></a>定位类型</h3><ol><li>static(默认)<br>元素不会被定位，会出现在正常的文档流中 <br><br>此时 top, right, bottom, left 和 z-index 属性无效</li><li>relative(相对定位)<br>元素不会脱离文档流，但是会相对于其正常位置进行定位。 <br><br>此时 top, right, bottom, left 和 z-index 属性有效</li><li>absolute(绝对定位)<br>元素会被从文档流中移除，相对于其最近的一个非’static’的父元素进行定位。 <br><br>此时 top, right, bottom, left 和 z-index 属性有效</li><li>sticky(粘性定位)<br>元素根据正常文档流进行定位，然后相对于它的最近滚动祖先和最近块级祖先定位。 <br><br>此时 top, right, bottom, left 和 z-index 属性有效</li><li>fixed(固定定位)<br>元素会被从文档流中移除，相对于浏览器窗口进行定位。 <br><br>此时 top, right, bottom, left 和 z-index 属性有效</li></ol><h2 id="2、讲讲盒模型？为什么要分正常盒模型盒怪异盒模型？如果怎么怎么样用什么盒模型（具体忘了）"><a href="#2、讲讲盒模型？为什么要分正常盒模型盒怪异盒模型？如果怎么怎么样用什么盒模型（具体忘了）" class="headerlink" title="2、讲讲盒模型？为什么要分正常盒模型盒怪异盒模型？如果怎么怎么样用什么盒模型（具体忘了）"></a>2、讲讲盒模型？为什么要分正常盒模型盒怪异盒模型？如果怎么怎么样用什么盒模型（具体忘了）</h2><blockquote><p>盒模型是 CSS 中用于描述元素布局的概念，它将每个元素看作一个矩形的盒子，这个盒子由元素的内容(content)、内边距(padding)、边框(border)、外边距(margin)组成。</p></blockquote><h3 id="盒模型有两种主要的表现形式：正常盒模型和怪异盒模型。"><a href="#盒模型有两种主要的表现形式：正常盒模型和怪异盒模型。" class="headerlink" title="盒模型有两种主要的表现形式：正常盒模型和怪异盒模型。"></a>盒模型有两种主要的表现形式：正常盒模型和怪异盒模型。</h3><ol><li>正常盒模型(content-box)：width &#x3D; margin + border + padding + content</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 标准盒模型(默认值)\正常盒模型 */</span><br></code></pre></td></tr></table></figure><ol start="2"><li>怪异盒模型(border-box): width &#x3D; margin + content(包含 border 和 padding)</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* IE 盒模型\怪异盒模型 */</span><br></code></pre></td></tr></table></figure><h3 id="为什么要分正常盒模型和怪异盒模型："><a href="#为什么要分正常盒模型和怪异盒模型：" class="headerlink" title="为什么要分正常盒模型和怪异盒模型："></a>为什么要分正常盒模型和怪异盒模型：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">历史原因导致浏览器在盒模型的实现上存在差异。早期的 Internet Explorer<br>浏览器默认采用怪异盒模型，即 box-sizing:<br>border-box。而其他浏览器默认采用正常盒模型，即 box-sizing:<br>content-box。为了兼容不同浏览器和避免出现布局错误，CSS 盒模型属性 box-sizing<br>被引入，允许开发者选择使用哪一种盒模型。<br></code></pre></td></tr></table></figure><h2 id="3、local-Storage-和-cookie-的区别，个人信息保存在哪里？session-storage-呢？"><a href="#3、local-Storage-和-cookie-的区别，个人信息保存在哪里？session-storage-呢？" class="headerlink" title="3、local Storage 和 cookie 的区别，个人信息保存在哪里？session storage 呢？"></a>3、local Storage 和 cookie 的区别，个人信息保存在哪里？session storage 呢？</h2><blockquote><p>local Storage:Web Storage API 的一部分，用于在浏览器中存储键值对的数据。它提供了一个持久化存储解决方案，数据在浏览器关闭后仍然存在</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key，value)<span class="hljs-comment">//设置值</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key)<span class="hljs-comment">//获取值</span><br></code></pre></td></tr></table></figure><blockquote><p>cookie:是一种在客户端存储数据的机制，通过浏览器每次请求时将数据发送到服务器。Cookies 存储的数据受限于 4KB，因为每次请求都会携带 Cookies，增大了网络请求的负担。</p></blockquote><blockquote><p>session storage:Web Storage API 的一部分，用于在浏览器中存储键值对的数据。与 localStorage 不同的是，sessionStorage 存储的数据在会话结束时会被清除，关闭浏览器标签或窗口时清除。</p></blockquote><h3 id="共同的点和区别"><a href="#共同的点和区别" class="headerlink" title="共同的点和区别"></a>共同的点和区别</h3><ol><li>共同点<br>都是保存在浏览器端！</li><li>区别</li></ol><ol><li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递；存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。<br><br>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；<br><br>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；<br><br>cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；<br>localStorage 在所有同源窗口中都是共享的；<br><br>cookie 也是在所有同源窗口中都是共享的。</li></ol><h3 id="个人信息保存在哪里？-gt-session"><a href="#个人信息保存在哪里？-gt-session" class="headerlink" title="个人信息保存在哪里？-&gt; session"></a>个人信息保存在哪里？-&gt; session</h3><p>session 是存储服务器端，cookie 是存储在客户端，所以 session 的安全性比 cookie 高。获取 session 里的信息是通过存放在会话 cookie 里的 session id 获取的。而 session 是存放在服务器的内存中里，所以 session 里的数据不断增加会造成服务器的负担，所以会把很重要的信息存储在 session 中，而把一些次要东西存储在客户端的 cookie 里。<br>session 的信息是通过 sessionid 获取的，而 sessionid 是存放在会话 cookie 当中的，当浏览器关闭的时候会话 cookie 消失，所以 sessionid 也就消失了，但是 session 的信息还存在服务器端</p><h2 id="4、讲讲-hooks，useEffect-原理是什么？useCallback-为什么能提高性能渲染？必须要搭配-React-memo-使用吗？useMemo-呢？讲讲项目为什么要用这些钩子？想听听你自己对这些钩子的理解"><a href="#4、讲讲-hooks，useEffect-原理是什么？useCallback-为什么能提高性能渲染？必须要搭配-React-memo-使用吗？useMemo-呢？讲讲项目为什么要用这些钩子？想听听你自己对这些钩子的理解" class="headerlink" title="4、讲讲 hooks，useEffect 原理是什么？useCallback 为什么能提高性能渲染？必须要搭配 React.memo 使用吗？useMemo 呢？讲讲项目为什么要用这些钩子？想听听你自己对这些钩子的理解"></a>4、讲讲 hooks，useEffect 原理是什么？useCallback 为什么能提高性能渲染？必须要搭配 React.memo 使用吗？useMemo 呢？讲讲项目为什么要用这些钩子？想听听你自己对这些钩子的理解</h2><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><blockquote><p>useEffect 用于在函数组件中执行副作用操作，例如数据获取、订阅事件、手动操作 DOM 等。它接受两个参数：一个函数和一个依赖数组，用于指定在哪些依赖发生变化时执行副作用。</p></blockquote><ol><li>原理：useEffect 利用了 React 的生命周期钩子，它在组件渲染到屏幕上之后执行</li><li>使用：调用这个函数的时候他的第一个参数必须是一个函数，第二个参数可以不传也可以传递一个数组，当不传递的时候组件当中任何一个数据发生变化的时候 useEffect 这个钩子函数每次都会执行，当传递第二个参数数组的时候，数组中定义状态数据，当状态数据改变的时候再执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, [])<br></code></pre></td></tr></table></figure><h2 id="5、项目中用到了-Redux，讲讲-Redux-的原理。Redux-有哪三条原则？必须要用-Redux-吗？别的方法不行吗？useContext-useReducer。那和这个方法有什么区别？"><a href="#5、项目中用到了-Redux，讲讲-Redux-的原理。Redux-有哪三条原则？必须要用-Redux-吗？别的方法不行吗？useContext-useReducer。那和这个方法有什么区别？" class="headerlink" title="5、项目中用到了 Redux，讲讲 Redux 的原理。Redux 有哪三条原则？必须要用 Redux 吗？别的方法不行吗？useContext+useReducer。那和这个方法有什么区别？"></a>5、项目中用到了 Redux，讲讲 Redux 的原理。Redux 有哪三条原则？必须要用 Redux 吗？别的方法不行吗？useContext+useReducer。那和这个方法有什么区别？</h2><h2 id="6、讲讲受控组件和非受控组件"><a href="#6、讲讲受控组件和非受控组件" class="headerlink" title="6、讲讲受控组件和非受控组件"></a>6、讲讲受控组件和非受控组件</h2><blockquote><p>受控组件 是指其值受 React 的状态（state）控制的组件。例如，表单元素（input、textarea、select）的值是由 React 的状态控制的，这种组件就是受控组件。通过 setState()来更新。<br>非受控组件 是指其值不受 React 状态管理的组件。例如，表单元素（input、textarea、select）的值是由 DOM 元素本身控制的，这种组件就是非受控组件。通过 ref 来获取。</p></blockquote><h3 id="6-1-区别"><a href="#6-1-区别" class="headerlink" title="6.1 区别"></a>6.1 区别</h3><ol><li>受控组件</li></ol><ol><li>受控组件依赖于状态</li><li>受控组件的修改会实时映射到状态值上，此时可以对输入的内容进行校验</li><li>受控组件只有继承 React.Component 才会有状态</li><li>受控组件必须要在表单上使用 onChange 事件来绑定对应的事件</li></ol><ol start="2"><li>非受控组件<ol><li>非受控组件不受状态的控制</li><li>非受控组件获取数据就是相当于操作 DOM</li><li>非受控组件可以很容易和第三方组件结合，更容易同时集成 React 和非 React 代码</li></ol></li></ol><p><strong>总的来说：</strong></p><ol><li>共同点，都是指表单元素，或者表单组件</li><li>不同点，被 react 的 state 控制，就是受控组件。不会 state 控制，就是非受控。</li><li>受控组件的实现方式，就是设置 state，使用事件调用 setstate，更新数据和视图。</li><li>非受控组件，避开 state，使用 ref 等等方式，更新数据和视图。</li></ol><h3 id="6-2-选择受控组件还是非受控组件"><a href="#6-2-选择受控组件还是非受控组件" class="headerlink" title="6.2 选择受控组件还是非受控组件"></a>6.2 选择受控组件还是非受控组件</h3><p>1、受控组件使用场景：一般用在需要动态设置其初始值的情况。例如：某些 form 表单信息编辑时，input 表单元素需要初始显示服务器返回的某个值然后进行编辑。<br>2、非受控组件使用场景：一般用于无任何动态初始值信息的情况。例如：form 表单创建信息时，input 表单元素都没有初始值，需要用户输入的情况。</p><h2 id="7、函数式组件和类组件相比有什么优势？"><a href="#7、函数式组件和类组件相比有什么优势？" class="headerlink" title="7、函数式组件和类组件相比有什么优势？"></a>7、函数式组件和类组件相比有什么优势？</h2><ol><li>简洁性：函数式组件通常比类组件更为简洁。你不需要编写 class 关键字，也不需要定义 render 方法。这使得代码更易读、更紧凑。</li><li>使用 Hooks（如 useState、useEffect 等）可以让函数式组件拥有状态和生命周期管理的能力，消除了类组件中 this 和 bind 的一些繁琐操作，使得代码更具可维护性。<br>2.5 函数式组件相对于类组件有更好的性能，因为函数组件本身的实现更简单，React 对其进行了更有效的优化。</li><li>更容易测试：函数式组件通常更容易进行单元测试，因为它们是纯函数，输入和输出更容易确定。</li><li>未来趋势：随着 React 社区的发展，函数式组件和 Hooks 已经成为 React 的主流方式，并且 React 团队更加推荐使用函数式组件。未来的 React 版本可能会进一步强化函数式组件和 Hooks 的特性。</li></ol><h2 id="8、切片上传原理。如果用户上传文件过程中突然退出网页，上传的文件保存在哪里？如何暂停上传？"><a href="#8、切片上传原理。如果用户上传文件过程中突然退出网页，上传的文件保存在哪里？如何暂停上传？" class="headerlink" title="8、切片上传原理。如果用户上传文件过程中突然退出网页，上传的文件保存在哪里？如何暂停上传？"></a>8、切片上传原理。如果用户上传文件过程中突然退出网页，上传的文件保存在哪里？如何暂停上传？</h2><h3 id="8-1-切片上传原理"><a href="#8-1-切片上传原理" class="headerlink" title="8.1 切片上传原理"></a>8.1 切片上传原理</h3><p>文件切片： 将大文件切分成多个小块，每个小块都有唯一的标识符。<br>上传切片： 逐个上传这些小块，每个小块上传成功后，服务端保存它的标识符以及相关信息。<br>合并切片： 当所有切片都上传完毕后，服务端根据标识符将这些小块合并成完整的文件。</p><h2 id="9、手写：Promise-all-、多叉树的最大深度。用-typescript-定义-node-节点，除了迭代方法还有吗？"><a href="#9、手写：Promise-all-、多叉树的最大深度。用-typescript-定义-node-节点，除了迭代方法还有吗？" class="headerlink" title="9、手写：Promise.all()、多叉树的最大深度。用 typescript 定义 node 节点，除了迭代方法还有吗？"></a>9、手写：Promise.all()、多叉树的最大深度。用 typescript 定义 node 节点，除了迭代方法还有吗？</h2><h3 id="9-1-Promise-all"><a href="#9-1-Promise-all" class="headerlink" title="9.1 Promise.all()"></a>9.1 Promise.all()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">customPromiseAll</span>(<span class="hljs-params">promises</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(promises)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;promises must be an array&#x27;</span>))<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> results = []<br>    <span class="hljs-keyword">let</span> completedCount = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleCompletion</span> = (<span class="hljs-params">index, value</span>) =&gt; &#123;<br>      results[index] = value<br>      completedCount++<br><br>      <span class="hljs-keyword">if</span> (completedCount === promises.<span class="hljs-property">length</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(results)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promises.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i])<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-title function_">handleCompletion</span>(i, value))<br>        .<span class="hljs-title function_">catch</span>(reject)<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// Example usage:</span><br><span class="hljs-keyword">const</span> promise1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> promise2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> promise3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>)<br><br><span class="hljs-title function_">customPromiseAll</span>([promise1, promise2, promise3])<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(results))<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error))<br></code></pre></td></tr></table></figure><h3 id="9-2-多叉树的最大深度"><a href="#9-2-多叉树的最大深度" class="headerlink" title="9.2 多叉树的最大深度"></a>9.2 多叉树的最大深度</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// TypeScript定义多叉树的节点</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TreeNode</span>&lt;T&gt; &#123;<br>  <span class="hljs-attr">value</span>: T<br>  children?: <span class="hljs-title class_">TreeNode</span>&lt;T&gt;[]<br>&#125;<br><br><span class="hljs-comment">// 递归方法计算多叉树的最大深度</span><br><span class="hljs-keyword">function</span> maxDepth&lt;T&gt;(<span class="hljs-attr">node</span>: <span class="hljs-title class_">TreeNode</span>&lt;T&gt;): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">children</span> || node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-comment">// 叶子节点深度为1</span><br>  &#125;<br><br>  <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> node.<span class="hljs-property">children</span>) &#123;<br>    res = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(res, <span class="hljs-title function_">maxDepth</span>(child))<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10、反问。最快什么时候到岗"><a href="#10、反问。最快什么时候到岗" class="headerlink" title="10、反问。最快什么时候到岗"></a>10、反问。最快什么时候到岗</h2><p>作者：起个响亮的名字___<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/362f96d5495245379586bcae69ad5fed">https://www.nowcoder.com/feed/main/detail/362f96d5495245379586bcae69ad5fed</a><br>来源：牛客网</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview-js</title>
    <link href="/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/"/>
    <url>/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-js"><a href="#🍭-面试-js" class="headerlink" title="🍭 面试-js"></a>🍭 面试-js</h1><h2 id="1-字节题-2js"><a href="#1-字节题-2js" class="headerlink" title="1.字节题 2js"></a>1.字节题 2js</h2><h3 id="1-var"><a href="#1-var" class="headerlink" title="1.var"></a>1.var</h3><pre><code class="hljs">1.var声明的变量会挂载在window上，let和const不会2.var声明的变量会进行变量提升，let和const不会3.var声明的变量没有块级作用域，let和const有4.var声明的变量可以重复声明(覆盖)，let和const不可以</code></pre><h3 id="2-深拷贝和浅拷贝"><a href="#2-深拷贝和浅拷贝" class="headerlink" title="2.深拷贝和浅拷贝"></a>2.深拷贝和浅拷贝</h3><pre><code class="hljs">1.浅拷贝：arr = newArr1.5.浅拷贝：arr = newArr.slice()1.5.浅拷贝：arr = newArr.concat()1.5.浅拷贝：arr = [...newArr]2.深拷贝：arr = JSON.parse(JSON.stringify(newArr))//不支持函数，正则，undefined</code></pre><hr><pre><code class="hljs"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (source) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span> (source) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h2 id="2-知识点-js"><a href="#2-知识点-js" class="headerlink" title="2.知识点 js"></a>2.知识点 js</h2><h3 id="2-1-js-构成"><a href="#2-1-js-构成" class="headerlink" title="2.1 js 构成"></a>2.1 js 构成</h3><ol><li>ECMAScript：<br>定义：ECMAScript 是 JavaScript 的语言规范，规定了 JavaScript 的基本语法、数据类型、函数定义等<br>作用：提供了 JavaScript 的核心功能，确保不同浏览器和环境中都能保持一致的行为。ECMAScript 规范由 Ecma International 维护，目前最新的版本是 ES2022。</li><li>DOM<br>标准： W3C DOM 标准<br>定义： DOM 是一种表述和操作 HTML、XML 文档的方式。在 JavaScript 中，DOM 提供了一种结构化的表示，使程序可以动态地更新文档的内容、结构和样式。<br>作用： 允许 JavaScript 通过脚本动态地操作文档的内容，实现与用户的交互和动态改变页面。DOM 将文档表示为一个树状结构，每个节点代表文档中的一个元素、属性或文本。</li><li>BOM<br>标准： 各个浏览器厂商根据 DOM 在各自浏览器上的实现<br>定义： BOM 是 JavaScript 与浏览器交互的一部分，提供了访问和控制浏览器窗口、框架和其他浏览器特定功能的对象。<br>作用： 允许 JavaScript 与浏览器进行通信，获取和修改浏览器窗口的属性，弹出警告框、确认框等。BOM 不属于 ECMAScript 标准，因此它的实现可以因浏览器而异。<br>组成：BOM 是由 navigator、history、screen、location、document 五个对象组成的。</li></ol><h3 id="2-2-js-的内置对象"><a href="#2-2-js-的内置对象" class="headerlink" title="2.2 js 的内置对象"></a>2.2 js 的内置对象</h3><blockquote><p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象</p></blockquote><ol><li>值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</li><li>函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</li><li>基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</li><li>数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</li><li>字符串，用来表示和操作字符串的对象。例如 String、RegExp</li><li>可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。复制代码例如 Array</li><li>使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet</li><li>矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</li><li>结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</li><li>控制抽象对象例如 Promise、Generator 等</li><li>反射 例如 Reflect、Proxy</li><li>国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</li></ol><h3 id="2-3-操作数组的方法"><a href="#2-3-操作数组的方法" class="headerlink" title="2.3 操作数组的方法"></a>2.3 操作数组的方法</h3><p>at(),concat(),copyWithin(),every(),fill(),filter(),find(),findIndex(),flat(),forEach(),includes(),indexOf(),join(),keys(),lastIndexOf(),map(),pop(),push(),reduce(),reduceRight(),reverse(),shift(),slice(),some(),sort(),splice(),toString(),unshift(),values()</p><h4 id="可以改变原数组的方法"><a href="#可以改变原数组的方法" class="headerlink" title="可以改变原数组的方法"></a>可以改变原数组的方法</h4><p>copyWithin(),fill(),pop(),push(),reverse(),shift(),sort(),splice(),unshift()</p><h3 id="2-4-js-检测数据类型的方法"><a href="#2-4-js-检测数据类型的方法" class="headerlink" title="2.4 js 检测数据类型的方法"></a>2.4 js 检测数据类型的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. typeof</span><br><span class="hljs-comment">// 返回一个表示类型的字符串(基本数据类型)</span><br><span class="hljs-comment">// 对一些复杂类型（例如 null 和数组）的判断不够准确。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> val)<br><br><span class="hljs-comment">//2. instanceof</span><br><span class="hljs-comment">// 检测一个对象是否是某个构造函数的实例</span><br><span class="hljs-comment">// 不能检测基本数据类型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val <span class="hljs-keyword">instanceof</span> valObject)<br><br><span class="hljs-comment">//3. Object.prototype.toString.call()</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(val)<br>  <span class="hljs-comment">// .replace(/\[object\s(\w+)\]/)</span><br>  <span class="hljs-comment">// .toLowerCase()</span><br>&#125;<br><br><span class="hljs-comment">//4. constructor</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><span class="hljs-comment">// 基本可以检测基本数据类型和引用数据类型(如果没有重写原型的话)</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val.<span class="hljs-property">constructor</span> === valObject) <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><h3 id="2-5-闭包"><a href="#2-5-闭包" class="headerlink" title="2.5 闭包"></a>2.5 闭包</h3><h4 id="1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"><a href="#1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？" class="headerlink" title="1.为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"></a>1.为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">1.闭包的本质：闭包是由函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。<br>一个拥有外层函数对象所对应的活跃对象引用的函数对象就被称为闭包。<br>2.闭包的作用：可以读取函数内部的变量，让这些变量的值始终保持在内存中，不会在函数调用后被自动清除（私有化变量）<br>3.闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏<br>4.闭包的应用场景：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>1.函数作为返回值、参数传递<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2.闭包可以实现封装，防止变量被全局污染 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3.闭包可以实现JS的模<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.闭包可以缓存变量(数据私有化) <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5.防抖、节流、库的封装、柯里化、高阶函数<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-闭包的实现原理-AO-GO"><a href="#2-闭包的实现原理-AO-GO" class="headerlink" title="2.闭包的实现原理 + AO + GO"></a>2.闭包的实现原理 + AO + GO</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">1.当函数执行完毕后，其作用域链会被销毁，但是闭包的作用域链不会被销毁，因为闭包的作用域链是在函数执行完毕后创建的。<br>2.当函数执行完毕后，其活动对象也会被销毁，但是闭包的活动对象不会被销毁，因为闭包的活动对象是在函数执行完毕后创建的。<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">AO:</span>活动对象 Activation <span class="hljs-type">Object</span>:函数上下文<br><br><span class="hljs-symbol">GO:</span>全局对象 <span class="hljs-keyword">Global</span> <span class="hljs-type">Object</span> :全局上下文<br></code></pre></td></tr></table></figure><h4 id="3-闭包例子"><a href="#3-闭包例子" class="headerlink" title="3. 闭包例子"></a>3. 闭包例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">a</span>) &#123;<br>    count += a<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(a)<br>    &#125;,<br>    <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(-a)<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count<br>    &#125;,<br>  &#125;<br>  <span class="hljs-keyword">return</span> compute<br>&#125;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">makeCount</span>()<br>counter.<span class="hljs-title function_">compute</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">del</span>(<span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="2-6-js-内存泄漏和垃圾回收机制"><a href="#2-6-js-内存泄漏和垃圾回收机制" class="headerlink" title="2.6 js 内存泄漏和垃圾回收机制"></a>2.6 js 内存泄漏和垃圾回收机制</h3><blockquote><p><strong>内存泄漏</strong>是指程序在使用动态分配内存时，由于某种原因未能释放已经不再使用的内存，导致系统的可用内存逐渐减少，最终可能导致程序性能下降或崩溃。</p></blockquote><blockquote><p>为什么会发生内存泄漏：</p></blockquote><ol><li>引用未释放的对象： 对象被引用，但在后续的代码中没有被正确释放。</li><li>循环引用： 当两个或多个对象相互引用，形成一个循环引用时，即使这些对象没有被其他代码引用，它们也不会被垃圾回收。</li><li>未清理的定时器和事件监听器： 在页面关闭前未清理的定时器或事件监听器可能引发内存泄漏。</li><li>未释放的 DOM 引用： 对 DOM 元素的引用，如果没有被正确释放，可能导致内存泄漏。</li></ol><blockquote><p>导致内存泄漏的因素：</p></blockquote><ol><li>全局变量： 将对象或数据存储在全局变量中，而忘记在不需要时手动删除它们。</li><li>闭包： 在闭包中引用的变量不会被垃圾回收，直到闭包不存在。</li><li>不正确使用定时器： 未清理的定时器可能导致对对象的引用被保留。</li><li>未解绑事件监听器： 如果页面上的元素被销毁，但仍然保留有对其事件的引用，可能导致内存泄漏。</li></ol><blockquote><p>JavaScript 使用垃圾回收机制来自动管理内存。主要的垃圾回收算法有两种：</p></blockquote><ol><li>标记-清除算法：<ol><li>标记阶段： 垃圾回收器会从根对象开始遍历所有引用，标记所有能够访问到的对象。</li><li>清除阶段： 垃圾回收器会清除所有未被标记的对象，释放它们占用的内存。</li></ol></li><li>引用计数算法： 维护每个对象的引用计数，当引用计数为零时即可将其释放。<ol><li>优点：实时性强，一旦引用计数为零就可以立即释放内存。</li><li>缺点：无法解决循环引用的问题，不再被引用的对象，只有在垃圾回收器运行时才能被释放。</li></ol></li></ol><h3 id="2-7-js-事件委托"><a href="#2-7-js-事件委托" class="headerlink" title="2.7 js 事件委托"></a>2.7 js 事件委托</h3><blockquote><p><strong>事件委托</strong>利用事件冒泡的特性，将事件处理程序绑定在父元素上，触发执行效果。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 事件委托的好处：可以减少内存消耗，减少事件注册，提高性能</span><br><span class="hljs-comment">// 事件委托的缺点：事件委托的事件处理程序不能获取事件对象，因为事件处理程序是在另外一个元素上执行的</span><br><span class="hljs-comment">// 事件委托的应用场景：1.动态添加的元素 2.大量元素绑定同一事件</span><br><span class="hljs-comment">// 事件委托的实现：1.利用事件冒泡 2.判断事件源</span><br><span class="hljs-comment">// 事件委托的实现步骤：1.获取事件源 2.判断事件源 3.处理事件</span><br><span class="hljs-comment">// 事件委托的实现代码：</span><br><span class="hljs-comment">// 1.获取事件源</span><br><span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)<br><span class="hljs-comment">// 2.判断事件源</span><br>ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span><br>  <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span><br>  <span class="hljs-comment">// 3.处理事件</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerHTML</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件委托的优点："><a href="#事件委托的优点：" class="headerlink" title="事件委托的优点："></a>事件委托的优点：</h4><ol><li>性能优化： 减少事件处理程序的数量，尤其在大量子元素存在的情况下，可以显著提高性能。</li><li>动态元素： 对于动态生成的元素，通过委托可以避免为每个新元素都绑定事件处理程序。</li><li>代码简洁： 可以通过在父元素上绑定一个事件处理程序，减少冗余的代码。</li></ol><blockquote><p><strong>事件冒泡</strong>：事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 阻止事件冒泡</span><br>event.<span class="hljs-title function_">stopPropagation</span>()<br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,(),<span class="hljs-literal">true</span>)<span class="hljs-comment">//true表示捕获阶段，false表示冒泡阶段</span><br><br></code></pre></td></tr></table></figure><h3 id="2-8-js-数据类型"><a href="#2-8-js-数据类型" class="headerlink" title="2.8 js 数据类型"></a>2.8 js 数据类型</h3><blockquote><p>基本数据类型：Number、String、Boolean、Null、Undefined、Symbol</p></blockquote><blockquote><p>引用数据类型：Object、Array、Function、Date、RegExp、Error</p></blockquote><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>存储位置：<ol><li>基本数据类型： 存储在栈内存中。</li><li>引用数据类型： 存储在堆内存中，栈内存中保存的是引用。</li></ol></li><li>比较方式：<ol><li>基本数据类型： 比较的是值是否相等。</li><li>引用数据类型： 比较的是引用地址是否相等。</li></ol></li><li>传递方式：<ol><li>基本数据类型： 通过值传递（传递的是数据的副本）。</li><li>引用数据类型： 通过引用传递（传递的是内存地址）。</li></ol></li></ol><h3 id="2-9-js-原型和原型链"><a href="#2-9-js-原型和原型链" class="headerlink" title="2.9 js 原型和原型链"></a>2.9 js 原型和原型链</h3><h4 id="1-原型（Prototype）"><a href="#1-原型（Prototype）" class="headerlink" title="1.原型（Prototype）"></a>1.原型（Prototype）</h4><ol><li>定义： 每个 JavaScript 对象（除了 null）都有一个原型对象，它是一个指向另一个对象的引用。</li><li>构造函数的原型属性： 对象是通过构造函数创建的，每个构造函数都有一个特殊的属性叫做 prototype，这个属性指向该构造函数的原型对象。</li><li>实例的原型： 通过构造函数创建的对象（实例）会继承构造函数的原型对象。</li><li><strong>proto</strong>属性： 在浏览器环境中，每个对象都有一个 <strong>proto</strong> 属性，指向它的原型对象。</li></ol><h4 id="2-原型链（Prototype-Chain）"><a href="#2-原型链（Prototype-Chain）" class="headerlink" title="2.原型链（Prototype Chain）"></a>2.原型链（Prototype Chain）</h4><ol><li>定义： 当一个对象在查找属性或方法时，如果它自身没有找到，就会去它的原型对象中查找，如果原型对象中还有原型，就会一直往上查找，直到找到或者达到原型链的顶端（null）。</li><li>继承关系： 原型链实现了对象之间的继承关系，使得一个对象可以共享另一个对象的属性和方法。</li><li>Object.prototype： 所有对象的原型链的顶端是 Object.prototype。</li></ol><h3 id="2-10-js-的-new-操作符"><a href="#2-10-js-的-new-操作符" class="headerlink" title="2.10 js 的 new 操作符"></a>2.10 js 的 new 操作符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">1. 创建一个空对象，作为将要返回的对象实例 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2. 将这个空对象的原型，指向构造函数的prototype属性 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3. 将这个空对象赋值给函数内部的this关键字 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4. 开始执行构造函数内部的代码<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5. 返回新对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model</span>) &#123;<br>  <span class="hljs-comment">// 步骤 3：将构造函数的上下文绑定到新对象</span><br>  <span class="hljs-comment">// 步骤 4：执行构造函数代码</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model<br>&#125;<br><br><span class="hljs-comment">// 步骤 2：设置原型链</span><br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Driving a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.make&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">// 步骤 1：创建一个空对象</span><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>, <span class="hljs-string">&#x27;Camry&#x27;</span>)<br><br><span class="hljs-comment">// 步骤 5：返回新对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">make</span>) <span class="hljs-comment">// 输出 &#x27;Toyota&#x27;</span><br>myCar.<span class="hljs-title function_">drive</span>() <span class="hljs-comment">// 输出 &#x27;Driving a Toyota Camry&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2-11-js-继承和如何实现继承"><a href="#2-11-js-继承和如何实现继承" class="headerlink" title="2.11 js 继承和如何实现继承"></a>2.11 js 继承和如何实现继承</h3><h4 id="1-原型链继承（Prototype-Chain-Inheritance）"><a href="#1-原型链继承（Prototype-Chain-Inheritance）" class="headerlink" title="1.原型链继承（Prototype Chain Inheritance）"></a>1.原型链继承（Prototype Chain Inheritance）</h4><blockquote><p>原型链继承是通过将一个对象的原型指向另一个对象来实现的。子类的原型对象是父类的一个实例，从而继承了父类的属性和方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>子类共享父类的原型对象》父类新增原型方法&#x2F;原型属性，子类都能访问<br>》实例是子类的实例也是父类的实例</li></ol><p><strong>缺点</strong>：</p><ol><li>为子类新增属性和方法，不能在构造函数中</li><li>无法实现多继承</li><li>创建子类实例时，不能向父类构造函数传参数</li><li>原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！</li></ol><h4 id="2-借用构造函数继承（Constructor-Borrowing-Inheritance）"><a href="#2-借用构造函数继承（Constructor-Borrowing-Inheritance）" class="headerlink" title="2.借用构造函数继承（Constructor Borrowing Inheritance）"></a>2.借用构造函数继承（Constructor Borrowing Inheritance）</h4><blockquote><p>构造函数继承是通过在子类构造函数中调用父类构造函数来实现的，借助 call 或 apply。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">name</span>) <span class="hljs-comment">// John</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(childInstance.<span class="hljs-property">childName</span>) <span class="hljs-comment">// Child</span><br></code></pre></td></tr></table></figure><p><strong>优点</strong>：</p><ol><li>可以在子类构造函数中向父类构造函数传参</li><li>可以实现多继承(call 多个对象)</li><li>不需要修复构造函数指向</li></ol><p><strong>缺点</strong>：</p><ol><li>方法在构造函数中定义，无法复用</li><li>只能继承父类的实例属性，不能继承原型属性、方法</li><li>实例并不是父类的实例，而只是子类的实例</li></ol><h4 id="3-组合继承（Combination-Inheritance）"><a href="#3-组合继承（Combination-Inheritance）" class="headerlink" title="3.组合继承（Combination Inheritance）"></a>3.组合继承（Combination Inheritance）</h4><blockquote><p>组合继承结合了原型链继承和构造函数继承的优点，使用原型链继承实现方法的继承，使用构造函数继承实现实例属性的继承。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, childName</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>可以继承实例属性、方法，也可以继承原型属性、方法</li><li>可传参、可复用</li><li>实例既是子类的实例，也是父类的实例</li></ol><p><strong>缺点：</strong></p><ol><li>调用了两次父类构造函数，耗内存</li><li>需要修复构造函数指向</li></ol><h4 id="4-原型式继承（Prototype-Inheritance）"><a href="#4-原型式继承（Prototype-Inheritance）" class="headerlink" title="4.原型式继承（Prototype Inheritance）"></a>4.原型式继承（Prototype Inheritance）</h4><blockquote><p>原型式继承是通过复制现有对象的原型来创建新对象。它的基本思想是通过一个函数，将一个对象作为参数传入，然后返回一个新的对象，这个新对象的原型指向传入的对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>  <span class="hljs-attr">sayHello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent)<br>child.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br><br>child.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>简单易懂，不需要定义新的构造函数。</li><li>可以实现对象之间的共享，因为它们共享同一个原型。</li></ol><p><strong>缺点：</strong></p><ol start="3"><li>共享引用类型的属性，修改其中一个对象的属性会影响其他对象。</li><li>无法传递参数给构造函数，每个实例都共享相同的属性。</li></ol><h4 id="5-寄生式继承（Parasitic-Inheritance）"><a href="#5-寄生式继承（Parasitic-Inheritance）" class="headerlink" title="5.寄生式继承（Parasitic Inheritance）"></a>5.寄生式继承（Parasitic Inheritance）</h4><blockquote><p>寄生继承是在原型式继承的基础上进行的一种改进。它创建一个函数，该函数在内部以某种方式增强对象，然后返回这个对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">original</span>) &#123;<br>  <span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original)<br><br>  <span class="hljs-comment">// 在原对象的基础上增强</span><br>  child.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> child<br>&#125;<br><br><span class="hljs-keyword">const</span> parent = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">createChild</span>(parent)<br>child.<span class="hljs-property">childName</span> = <span class="hljs-string">&#x27;Child&#x27;</span><br><br>child.<span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// Hi, I am Child</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>可以在对象上增加一些额外的方法或属性。</li></ol><p><strong>缺点：</strong></p><ol><li>仍然存在引用类型共享的问题。</li></ol><h4 id="6-寄生组合式继承（Parasitic-Combination-Inheritance）"><a href="#6-寄生组合式继承（Parasitic-Combination-Inheritance）" class="headerlink" title="6.寄生组合式继承（Parasitic Combination Inheritance）"></a>6.寄生组合式继承（Parasitic Combination Inheritance）</h4><blockquote><p>寄生组合继承是一种结合了原型式继承和构造函数继承的方式，通过构造函数继承来继承属性，通过原型链继承来继承方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name, childName</span>) &#123;<br>  <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>&#125;<br><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Child</span><br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ol><li>避免了构造函数继承和原型链继承各自的缺点。</li><li>避免了重复调用构造函数。</li></ol><p><strong>缺点：</strong></p><ol><li>复杂，相对于其他继承方式更复杂，可能不够直观。</li></ol><h4 id="7-ES6-继承"><a href="#7-ES6-继承" class="headerlink" title="7.ES6 继承"></a>7.ES6 继承</h4><blockquote><p>ES6 引入了 class 语法，使得面向对象编程更加直观，但实际上仍然是基于原型链的继承。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name || <span class="hljs-string">&#x27;Parent&#x27;</span><br>  &#125;<br><br>  <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, I am &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, childName</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(name)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">childName</span> = childName || <span class="hljs-string">&#x27;Child&#x27;</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> childInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;John&#x27;</span>)<br>childInstance.<span class="hljs-title function_">sayHello</span>() <span class="hljs-comment">// Hello, I am John</span><br></code></pre></td></tr></table></figure><h3 id="2-12-js-设计原理"><a href="#2-12-js-设计原理" class="headerlink" title="2.12 js 设计原理"></a>2.12 js 设计原理</h3><blockquote><p>Js 引擎、运行上下文、调用栈、事件循环、回调。</p></blockquote><ol><li>Js 引擎：负责解析和执行 js 代码</li><li>运行上下文：js 代码执行的环境，分为全局上下文和函数上下文</li><li>调用栈：js 引擎在执行 js 代码时，会以栈的形式来管理函数的调用，栈底永远是全局上下文，栈顶是当前正在执行的函数上下文</li><li>事件循环：js 是单线程的，事件循环是 js 实现异步的一种机制</li><li>回调：回调是一种常用的异步编程方式，可以通过回调来实现异步编程</li></ol><h3 id="2-13-js-this-指向问题"><a href="#2-13-js-this-指向问题" class="headerlink" title="2.13 js this 指向问题"></a>2.13 js this 指向问题</h3><h4 id="1-全局对象、普通函数中的-this-指向-window"><a href="#1-全局对象、普通函数中的-this-指向-window" class="headerlink" title="1.全局对象、普通函数中的 this 指向 window"></a>1.全局对象、普通函数中的 this 指向 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1.全局对象中的this指向window</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window】</span><br><br><span class="hljs-comment">//2.普通函数中的this指向window</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window</span><br></code></pre></td></tr></table></figure><h4 id="2-构造函数中的-this-指向实例对象"><a href="#2-构造函数中的-this-指向实例对象" class="headerlink" title="2.构造函数中的 this 指向实例对象"></a>2.构造函数中的 this 指向实例对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//3.构造函数中的this指向实例对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-对象中的函数中的-this-指向上一级对象"><a href="#3-对象中的函数中的-this-指向上一级对象" class="headerlink" title="3.对象中的函数中的 this 指向上一级对象"></a>3.对象中的函数中的 this 指向上一级对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//4.对象中的函数中的this指向上一级对象</span><br><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,<br>  <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;,<br>&#125;<br><span class="hljs-keyword">let</span> obj2 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)<br>    &#125;,<br>  &#125;,<br>&#125;<br>obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span><br>obj2.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h4 id="4-箭头函数中的-this-指向-window"><a href="#4-箭头函数中的-this-指向-window" class="headerlink" title="4.箭头函数中的 this 指向 window"></a>4.箭头函数中的 this 指向 window</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//5.箭头函数中的this继承自上一级作用域</span><br><span class="hljs-keyword">let</span> obj3 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj3.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window undefined</span><br></code></pre></td></tr></table></figure><h4 id="5-call-x2F-apply-x2F-bind"><a href="#5-call-x2F-apply-x2F-bind" class="headerlink" title="5.call&#x2F;apply&#x2F;bind"></a>5.call&#x2F;apply&#x2F;bind</h4><blockquote><p>call&#x2F;apply&#x2F;bind 可以改变 this 指向，但是箭头函数的 this 无法改变</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span><br><span class="hljs-keyword">let</span> obj4 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj4) <span class="hljs-comment">// window undefined</span><br><br><span class="hljs-comment">//7.call/apply/bind可以改变this指向</span><br><span class="hljs-keyword">let</span> obj5 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// obj5</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj5.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(obj5) <span class="hljs-comment">// obj5 1</span><br></code></pre></td></tr></table></figure><h4 id="6-事件中的-this-指向触发事件的元素"><a href="#6-事件中的-this-指向触发事件的元素" class="headerlink" title="6.事件中的 this 指向触发事件的元素"></a>6.事件中的 this 指向触发事件的元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//8.事件中的this指向触发事件的元素</span><br><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>)<br>btn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// btn</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-匿名函数中的-this-指向-window"><a href="#7-匿名函数中的-this-指向-window" class="headerlink" title="7.匿名函数中的 this 指向 window"></a>7.匿名函数中的 this 指向 window</h4><blockquote><p>匿名函数执行环境具有全局性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//9.匿名函数中的this指向window</span><br><span class="hljs-keyword">let</span> obj6 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// obj6.b</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 2</span><br>      ;(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>      &#125;)()<br>    &#125;,<br>  &#125;,<br>&#125;<br>obj6.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj6.b 2 window undefined</span><br></code></pre></td></tr></table></figure><h3 id="2-14-script-标签的-defer-和-async-属性"><a href="#2-14-script-标签的-defer-和-async-属性" class="headerlink" title="2.14 script 标签的 defer 和 async 属性"></a>2.14 script 标签的 defer 和 async 属性</h3><blockquote><p>script 是会阻碍 HTML 解析的，只有下载好并执行完脚本才会继续解析 HTML</p></blockquote><h4 id="1-defer"><a href="#1-defer" class="headerlink" title="1. defer"></a>1. defer</h4><blockquote><p>defer 属性告诉浏览器不要等待脚本，浏览器会继续处理 HTML，构建 DOM。该脚本“在后台”加载，然后在文档解析完成后，DOMContentLoaded 事件触发前执行。脚本会按照在 HTML 中出现的顺序执行。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特点:</strong></p><ol><li>defer 脚本会按照在 HTML 中出现的顺序执行。</li><li>defer 脚本会在 DOMContentLoaded 事件触发前执行。</li></ol><h4 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h4><blockquote><p>async 表示脚本在下载完成后立即异步执行，不会等待其他脚本，也不会阻塞文档的解析。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>特点:</strong></p><ol><li>async 不保证脚本的执行顺序，谁先下载完成谁先执行。</li><li>async 脚本的执行时机是在下载完成后立即执行，不会等待其他脚本或文档解析。</li></ol><img src="/2024/01/21/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-js/js-2_13.png" class title="This is an test image"><h3 id="2-15-setTimeout-和-setInterval-的区别"><a href="#2-15-setTimeout-和-setInterval-的区别" class="headerlink" title="2.15 setTimeout 和 setInterval 的区别"></a>2.15 setTimeout 和 setInterval 的区别</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><ol><li>作用： setTimeout 用于在指定的延迟时间后执行一次指定的函数。</li><li>语法： setTimeout(callback, delay)，其中 callback 是要执行的函数，delay 是延迟的毫秒数。</li><li>执行次数： 只执行一次。</li><li>返回值：返回值 timeoutID 是一个正整数，表示定时器的编号。这个值可以传递给 clearTimeout()来取消该定时器。</li><li>取消： 可以使用 clearTimeout 来取消计划中的执行。<br><strong>最小延迟时间：</strong> setTimeout 的最小延迟时间是 4 毫秒，如果指定的延迟时间小于 4 毫秒，那么会被自动调整为 4 毫秒。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will be executed once after 2000 milliseconds.&#x27;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// 取消执行</span><br><span class="hljs-built_in">clearTimeout</span>(timeoutId)<br></code></pre></td></tr></table></figure><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><ol><li>作用： setInterval 用于每隔一定的时间重复执行指定的函数。</li><li>语法： setInterval(callback, delay)，其中 callback 是要执行的函数，delay 是每次执行之间的间隔时间。</li><li>执行次数： 重复执行，直到被取消。</li><li>返回值：此返回值 intervalID 是一个非零数值，用来标识通过 setInterval()创建的计时器，这个值可以用来作为 clearInterval()的参数来清除对应的计时器 。</li><li>取消： 可以使用 clearInterval 来取消重复执行。<br><strong>最小延迟时间：</strong> setInterval 的最小延迟时间是 4 毫秒，如果指定的延迟时间小于 4 毫秒，那么会被自动调整为 4 毫秒。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> intervalId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;This will be executed every 2000 milliseconds.&#x27;</span>)<br>&#125;, <span class="hljs-number">2000</span>)<br><br><span class="hljs-comment">// 取消重复执行</span><br><span class="hljs-built_in">clearInterval</span>(intervalId)<br></code></pre></td></tr></table></figure><h3 id="2-16-es6-的新特性"><a href="#2-16-es6-的新特性" class="headerlink" title="2.16 es6 的新特性"></a>2.16 es6 的新特性</h3><h4 id="1-新增了-let-和-const-命令，用来声明变量。"><a href="#1-新增了-let-和-const-命令，用来声明变量。" class="headerlink" title="1. 新增了 let 和 const 命令，用来声明变量。"></a>1. 新增了 let 和 const 命令，用来声明变量。</h4><ol><li>不能重复声明</li><li>不存在变量提升</li><li>暂时性死区</li><li>块级作用域</li></ol><h4 id="2-新增了箭头函数"><a href="#2-新增了箭头函数" class="headerlink" title="2. 新增了箭头函数"></a>2. 新增了箭头函数</h4><ol><li>箭头函数没有自己的 this，它的 this 继承于上一级作用域的 this</li><li>箭头函数没有自己的 arguments，它的 arguments 继承于上一级作用域的 arguments</li><li>箭头函数不能作为构造函数，不能使用 new</li><li>箭头函数没有原型属性</li></ol><h4 id="3-新增了模板字符串"><a href="#3-新增了模板字符串" class="headerlink" title="3. 新增了模板字符串"></a>3. 新增了模板字符串</h4><blockquote><p>模板字符串使用反引号（&#96;）包裹，支持多行字符串和变量插值</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;World&#x27;</span><br><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span><br></code></pre></td></tr></table></figure><h4 id="4-新增了解构赋值"><a href="#4-新增了解构赋值" class="headerlink" title="4. 新增了解构赋值"></a>4. 新增了解构赋值</h4><blockquote><p>可以通过解构赋值语法从数组或对象中提取值并赋给变量。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-keyword">const</span> &#123; a, b &#125; = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="5-新增了-Promise"><a href="#5-新增了-Promise" class="headerlink" title="5. 新增了 Promise"></a>5. 新增了 Promise</h4><h4 id="6-新增默认参数值"><a href="#6-新增默认参数值" class="headerlink" title="6. 新增默认参数值"></a>6. 新增默认参数值</h4><blockquote><p>函数参数可以设置默认值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y = <span class="hljs-number">2</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> x * y<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-新增了-class"><a href="#7-新增了-class" class="headerlink" title="7. 新增了 class"></a>7. 新增了 class</h4><blockquote><p>ES6 引入了类和继承的概念，更接近传统面向对象的语法。</p></blockquote><h4 id="8-新增了模块化"><a href="#8-新增了模块化" class="headerlink" title="8. 新增了模块化"></a>8. 新增了模块化</h4><blockquote><p>ES6 引入了模块系统，通过 import 和 export 关键字实现模块的导入和导出。</p></blockquote><h4 id="9-新增了-Set-和-Map"><a href="#9-新增了-Set-和-Map" class="headerlink" title="9. 新增了 Set 和 Map"></a>9. 新增了 Set 和 Map</h4><blockquote><p>ES6 引入了 Set 和 Map 两种新的数据结构，Set 类似于数组，但是成员的值都是唯一的，没有重复的值。Map 类似于对象，但是键可以是任意类型的。</p></blockquote><h4 id="10-新增了-Symbol"><a href="#10-新增了-Symbol" class="headerlink" title="10. 新增了 Symbol"></a>10. 新增了 Symbol</h4><blockquote><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></blockquote><ol><li>使用场景：Symbol 值可以作为对象属性的标识符，可以防止属性名的冲突。</li><li>Symbol 特点</li></ol><ol><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 值不能与其他数据进行运算</li><li>Symbol 定义的对象属性不能使用 for…in 循环遍历，但是可以使用 Reflect.ownKeys 来获对象的所有键名</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//创建 Symbol</span><br><span class="hljs-keyword">let</span> s1 = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1, <span class="hljs-keyword">typeof</span> s1)<br><br><span class="hljs-comment">//添加标识的 Symbol</span><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-keyword">let</span> s2_2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s2 === s2_2) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">//使用 Symbol for 定义</span><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-keyword">let</span> s3_2 = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">&#x27;scorpios&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3 === s3_2) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="11-新增了-Proxy"><a href="#11-新增了-Proxy" class="headerlink" title="11. 新增了 Proxy"></a>11. 新增了 Proxy</h4><h4 id="12-迭代器和生成器"><a href="#12-迭代器和生成器" class="headerlink" title="12. 迭代器和生成器"></a>12. 迭代器和生成器</h4><h3 id="2-17-call、apply、bind-的区别"><a href="#2-17-call、apply、bind-的区别" class="headerlink" title="2.17 call、apply、bind 的区别"></a>2.17 call、apply、bind 的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span><br><span class="hljs-keyword">let</span> obj4 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">// window undefined</span><br><br><span class="hljs-comment">//7.function中的call/apply/bind可以改变this指向</span><br><span class="hljs-comment">//call:&#123;&#125;,改变this指向，立即执行</span><br><span class="hljs-comment">//apply:[],改变this指向，立即执行</span><br><span class="hljs-comment">//bind:返回一个新的函数,改变this指向，不会立即执行</span><br><span class="hljs-comment">//this都指向第一个参数</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span><br>&#125;<br>foo.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &#123;a:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-18-深拷贝和浅拷贝"><a href="#2-18-深拷贝和浅拷贝" class="headerlink" title="2.18 深拷贝和浅拷贝"></a>2.18 深拷贝和浅拷贝</h3><pre><code class="hljs">1.浅拷贝：arr = newArr1.5.浅拷贝：arr = newArr.slice()1.5.浅拷贝：arr = newArr.concat()1.5.浅拷贝：arr = [...newArr]2.深拷贝：arr = JSON.parse(JSON.stringify(newArr))//不支持函数，正则，undefined</code></pre><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 深拷贝递归</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>    <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        target[key] = <span class="hljs-title function_">deepClone</span>(source[key])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        target[key] = source[key]<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br><br><span class="hljs-comment">// 深拷贝迭代</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source !== <span class="hljs-string">&#x27;object&#x27;</span>) <span class="hljs-keyword">return</span> source<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source) ? [] : &#123;&#125;<br>  <span class="hljs-keyword">const</span> stack = [[source, target]]<br>  <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> [source, target] = stack.<span class="hljs-title function_">pop</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> source) &#123;<br>      <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source[key] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>          target[key] = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(source[key]) ? [] : &#123;&#125;<br>          stack.<span class="hljs-title function_">push</span>([source[key], target[key]])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          target[key] = source[key]<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> target<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-19-js-的事件循环"><a href="#2-19-js-的事件循环" class="headerlink" title="2.19 js 的事件循环"></a>2.19 js 的事件循环</h3><blockquote><p>它是一个在 JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环。</p></blockquote><h4 id="1-执行栈（Call-Stack）："><a href="#1-执行栈（Call-Stack）：" class="headerlink" title="1.执行栈（Call Stack）："></a>1.执行栈（Call Stack）：</h4><ol><li>JavaScript 是单线程执行的，所有的代码都执行在一个主线程上，这个主线程拥有一个执行栈（Call Stack）来记录执行的上下文。</li><li>函数调用会将执行上下文推入执行栈，函数执行完毕后将其从栈中弹出。</li></ol><h4 id="任务队列（Task-Queue）："><a href="#任务队列（Task-Queue）：" class="headerlink" title="任务队列（Task Queue）："></a>任务队列（Task Queue）：</h4><ol><li>任务队列用于存储异步任务的回调函数。</li><li>当异步任务完成时，其回调函数会被放入任务队列中等待执行。</li></ol><h4 id="事件循环（Event-Loop）："><a href="#事件循环（Event-Loop）：" class="headerlink" title="事件循环（Event Loop）："></a>事件循环（Event Loop）：</h4><p>事件循环执行过程：</p><ol><li>执行当前宏任务的全部同步代码，将它们推入执行栈。</li><li>执行栈为空时，检查微任务队列，依次执行所有微任务。</li><li>微任务执行完成后，检查是否有宏任务需要执行，如果有，执行宏任务的同步代码。</li><li>重复上述过程</li></ol><h4 id="宏任务和微任务队列（Microtask-Queue）："><a href="#宏任务和微任务队列（Microtask-Queue）：" class="headerlink" title="宏任务和微任务队列（Microtask Queue）："></a>宏任务和微任务队列（Microtask Queue）：</h4><blockquote><p>宏任务： script( 整体代码)、setTimeout、setInterval、I&#x2F;O、UI 交互事件、setImmediate(Node.js 环境)</p></blockquote><blockquote><p>微任务： Promise、MutaionObserver、process.nextTick(Node.js 环境)；</p></blockquote><ol><li>在事件循环中，微任务队列用于存储微任务。</li><li>微任务会在当前宏任务执行结束后、下一个宏任务开始之前执行。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Start&#x27;</span>)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Timeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Promise&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;End&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上述代码中，首先输出 ‘Start’，然后执行同步代码，接着将 setTimeout 和 Promise 的回调函数分别放入宏任务队列和微任务队列。最后输出 ‘End’。当执行栈为空时，事件循环开始执行微任务队列，输出 ‘Promise’，然后执行宏任务队列，输出 ‘Timeout’。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字节一面-id1</title>
    <link href="/2024/01/20/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2-id1/"/>
    <url>/2024/01/20/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2-id1/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-字节一面-id1"><a href="#🍭-字节一面-id1" class="headerlink" title="🍭 字节一面-id1"></a>🍭 字节一面-id1</h1><h2 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h2><p>…略</p><h2 id="2、CSS-实现一个圆"><a href="#2、CSS-实现一个圆" class="headerlink" title="2、CSS 实现一个圆"></a>2、CSS 实现一个圆</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>普通函数<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.circle</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;circle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3、让元素垂直居中和水平居中的方法"><a href="#3、让元素垂直居中和水平居中的方法" class="headerlink" title="3、让元素垂直居中和水平居中的方法"></a>3、让元素垂直居中和水平居中的方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 块初始 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.exapmle</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;exapmle&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-1-flex"><a href="#3-1-flex" class="headerlink" title="3.1 flex"></a>3.1 flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.flex+margin */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.flex */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-行内元素"><a href="#3-2-行内元素" class="headerlink" title="3.2 行内元素"></a>3.2 行内元素</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.行内元素 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span>: &#123;<br>  <span class="hljs-attribute">line-height</span>: $parentHeigth;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-绝对定位"><a href="#3-3-绝对定位" class="headerlink" title="3.3 绝对定位"></a>3.3 绝对定位</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br><span class="hljs-comment">/* 2.绝对定位 */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleHeight);<br>  <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - $exapmleWeight);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-grid"><a href="#4-grid" class="headerlink" title="4.grid"></a>4.grid</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.grid */</span><br><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  justify-self: center;<br>  <span class="hljs-attribute">align-self</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-table"><a href="#5-table" class="headerlink" title="5.table"></a>5.table</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">display</span>: table;<br>&#125;<br><span class="hljs-selector-class">.exapmle</span> &#123;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4、讲讲-flex-属性"><a href="#4、讲讲-flex-属性" class="headerlink" title="4、讲讲 flex 属性"></a>4、讲讲 flex 属性</h2><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><pre><code class="hljs">1.flex-direction /2.flex-wrap /3.flex-flow /4.justify-content /5.align-items /6.align-content</code></pre><h3 id="4-1-flex-direction"><a href="#4-1-flex-direction" class="headerlink" title="4.1 flex-direction"></a>4.1 flex-direction</h3><blockquote><p>属性决定主轴方向，默认横向 row</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-flex-wrap"><a href="#4-2-flex-wrap" class="headerlink" title="4.2 flex-wrap"></a>4.2 flex-wrap</h3><blockquote><p>flex 元素单行显示还是多行显示。若允许换行，这个属性允许你控制元素的堆叠方向。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-flex-flow"><a href="#4-3-flex-flow" class="headerlink" title="4.3 flex-flow"></a>4.3 flex-flow</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-justify-content"><a href="#4-4-justify-content" class="headerlink" title="4.4 justify-content"></a>4.4 justify-content</h3><blockquote><p>定义了元素在弹性容器主轴上的对齐方式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around<br>    | space-evenly;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-align-items"><a href="#4-5-align-items" class="headerlink" title="4.5 align-items"></a>4.5 align-items</h3><blockquote><p>元素在弹性容器交叉轴上的对齐方式</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">stretch(默认值):如果被排列的项目未设置高度（宽度）或设置为auto，项目将占满整个容器的高度（宽度）</span><br><span class="hljs-comment">baseline：项目的第一行文字的基线对齐</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="4-6-align-content"><a href="#4-6-align-content" class="headerlink" title="4.6 align-content"></a>4.6 align-content</h3><blockquote><p>定义了多跟轴线的对齐方式，如果只有一根轴线则属性不起作用</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | stretch | space-between |<br>    space-around;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">stretch(默认值):如果被排列的项目未设置高度（宽度）或设置为auto，项目将占满整个容器的高度（宽度）</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="5、H5-中的块元素和行内块元素"><a href="#5、H5-中的块元素和行内块元素" class="headerlink" title="5、H5 中的块元素和行内块元素"></a>5、H5 中的块元素和行内块元素</h2><h3 id="5-1-行内元素"><a href="#5-1-行内元素" class="headerlink" title="5.1 行内元素"></a>5.1 行内元素</h3><pre><code class="hljs">常用标签：span、a、img、input、buttonH5 新增标签：video、audio、canvas(1)设置宽高无效(2)对 margin 仅设置左右方向有效，上下无效；padding 设置上下左右都有效，即会撑大空间(3)不会自动进行换行</code></pre><h3 id="5-2-块元素"><a href="#5-2-块元素" class="headerlink" title="5.2 块元素"></a>5.2 块元素</h3><pre><code class="hljs">常用标签：div、p、h1~h6、ul、li、dl、dt、ddH5 新增标签：section、article、aside、header、footer、nav、figure、figcaption(1)默认宽度为父元素的宽度(2)可以设置宽高(3)可以设置 margin 和 padding(4)可以自动换行</code></pre><h3 id="5-3-行内块元素"><a href="#5-3-行内块元素" class="headerlink" title="5.3 行内块元素"></a>5.3 行内块元素</h3><pre><code class="hljs">(1)默认宽度为内容的宽度(2)可以设置宽高(3)可以设置 margin 和 padding(4)不会自动换行</code></pre><h2 id="6、js-数据类型、判断数据类型的方法，call、apply、bind-方法、为什么不使用-toString-而是-Object-prototype-toString"><a href="#6、js-数据类型、判断数据类型的方法，call、apply、bind-方法、为什么不使用-toString-而是-Object-prototype-toString" class="headerlink" title="6、js 数据类型、判断数据类型的方法，call、apply、bind 方法、为什么不使用 toString 而是 Object.prototype.toString()"></a>6、js 数据类型、判断数据类型的方法，call、apply、bind 方法、为什么不使用 toString 而是 Object.prototype.toString()</h2><h3 id="6-1-js-数据类型："><a href="#6-1-js-数据类型：" class="headerlink" title="6.1 js 数据类型："></a>6.1 js 数据类型：</h3><pre><code class="hljs">基本数据类型：Number、String、Boolean、Null、Undefined、Symbol引用数据类型：Object、Array、Function、Date、RegExp、Error</code></pre><h3 id="6-2-判断数据类型的方法"><a href="#6-2-判断数据类型的方法" class="headerlink" title="6.2 判断数据类型的方法"></a>6.2 判断数据类型的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//1. typeof</span><br><span class="hljs-comment">// 返回一个表示类型的字符串</span><br><span class="hljs-comment">// 对一些复杂类型（例如 null 和数组）的判断不够准确。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> val)<br><br><span class="hljs-comment">//2. instanceof</span><br><span class="hljs-comment">// 检测一个对象是否是某个构造函数的实例</span><br><span class="hljs-comment">// 不能检测基本数据类型</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val <span class="hljs-keyword">instanceof</span> valObject)<br><br><span class="hljs-comment">//3. Object.prototype.toString.call()</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span><br>    .<span class="hljs-title function_">call</span>(val)<br>    .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\[object\s(\w+)\]/</span>)<br>    .<span class="hljs-title function_">toLowerCase</span>()<br>&#125;<br><br><span class="hljs-comment">//4. constructor</span><br><span class="hljs-comment">// 返回一个表示对象的字符串</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> val.<span class="hljs-property">constructor</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-3-call、apply、bind-方法"><a href="#6-3-call、apply、bind-方法" class="headerlink" title="6.3 call、apply、bind 方法"></a>6.3 call、apply、bind 方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span><br><span class="hljs-keyword">let</span> obj4 = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span><br>    &#125;,<br>  &#125;,<br>&#125;<br>obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">// window undefined</span><br><br><span class="hljs-comment">//7.function中的call/apply/bind可以改变this指向</span><br><span class="hljs-comment">//call:&#123;&#125;,改变this指向，立即执行</span><br><span class="hljs-comment">//apply:[],改变this指向，立即执行</span><br><span class="hljs-comment">//bind:返回一个新的函数,改变this指向，不会立即执行</span><br><span class="hljs-comment">//this都指向第一个参数</span><br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span><br>&#125;<br>foo.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &#123;a:1&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-4-为什么不使用-toString-而是-Object-prototype-toString"><a href="#6-4-为什么不使用-toString-而是-Object-prototype-toString" class="headerlink" title="6.4 为什么不使用 toString 而是 Object.prototype.toString()"></a>6.4 为什么不使用 toString 而是 Object.prototype.toString()</h3><ol><li><p>直接使用数据本身去调用 toString。是无法调用到 Object.prototype.toString 的。而且，在数组上被重写之后的 toString 方法，作用也不再是返回对象类型了。而是打印数组内容。</p></li><li><p>Object.prototype.toString.call() 可以确保调用的是 Object 上的原始方法，而不会受到其他可能存在的覆盖的影响。</p></li></ol><h2 id="7、let、const、var，暂时性死区，先-console-log-输出变量再声明-和-如果先使用一个函数，再使用-var-声明，分别会报什么错误"><a href="#7、let、const、var，暂时性死区，先-console-log-输出变量再声明-和-如果先使用一个函数，再使用-var-声明，分别会报什么错误" class="headerlink" title="7、let、const、var，暂时性死区，先 console.log 输出变量再声明 和 如果先使用一个函数，再使用 var 声明，分别会报什么错误"></a>7、let、const、var，暂时性死区，先 console.log 输出变量再声明 和 如果先使用一个函数，再使用 var 声明，分别会报什么错误</h2><h3 id="let、const、var"><a href="#let、const、var" class="headerlink" title="let、const、var"></a>let、const、var</h3><ol><li><p>var：<br>具有函数作用域。<br>会进行变量提升（hoisting）。<br>可以重复声明同名变量。<br>没有块级作用域，存在变量提升。</p></li><li><p>let：<br>具有块级作用域。<br>不会进行变量提升。<br>不允许重复声明同名变量。<br>存在“暂时性死区”。</p></li><li><p>const：<br>具有块级作用域。<br>不会进行变量提升。<br>不允许重复声明同名变量。<br>声明后不能再被赋值。</p></li></ol><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><pre><code class="hljs">在块级作用域内，使用 let 或 const 声明变量之前，该变量都是不可用的。也就是说，在变量声明之前，该变量都是不可用的，这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</code></pre><h3 id="先-console-log-输出变量再声明"><a href="#先-console-log-输出变量再声明" class="headerlink" title="先 console.log 输出变量再声明"></a>先 console.log 输出变量再声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a) <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">5</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b) <span class="hljs-comment">// ReferenceError: b is not defined</span><br><span class="hljs-keyword">let</span> b<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c) <span class="hljs-comment">// ReferenceError: c is not defined</span><br><span class="hljs-keyword">const</span> c = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h3 id="如果先使用一个函数，再使用-var-声明，分别会报什么错误"><a href="#如果先使用一个函数，再使用-var-声明，分别会报什么错误" class="headerlink" title="如果先使用一个函数，再使用 var 声明，分别会报什么错误"></a>如果先使用一个函数，再使用 var 声明，分别会报什么错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//对于 var，函数声明会被提升到作用域的顶部，因此先使用函数再声明变量不会报错。</span><br><span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 输出：Hello from foo!</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from foo!&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//对于 let 和 const，函数声明不会被提升到作用域的顶部，因此先使用函数再声明变量会报错。</span><br><span class="hljs-title function_">f</span>() <span class="hljs-comment">// ReferenceErro: Cannot access &#x27;f&#x27; before initialization</span><br><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from bar!&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//函数声明会被提升到作用域的顶部。</span><br><span class="hljs-title function_">bar</span>() <span class="hljs-comment">// 不会报错，输出：Hello from bar!</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello from bar!&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8、Promise-的方法、async-await、Generator-函数，什么函数能被作为-Generator-函数"><a href="#8、Promise-的方法、async-await、Generator-函数，什么函数能被作为-Generator-函数" class="headerlink" title="8、Promise 的方法、async await、Generator 函数，什么函数能被作为 Generator 函数"></a>8、Promise 的方法、async await、Generator 函数，什么函数能被作为 Generator 函数</h2><h3 id="8-1-Promise-的方法"><a href="#8-1-Promise-的方法" class="headerlink" title="8.1 Promise 的方法"></a>8.1 Promise 的方法</h3><ol><li>Promise.resolve(value)：返回一个已解析的 Promise 对象，解析的值为给定的值。</li><li>Promise.reject(reason)：返回一个已拒绝的 Promise 对象，拒绝的原因为给定的值。</li><li>Promise.all(iterable)：返回一个 Promise，该 Promise 在可迭代对象中所有的 Promise 已完成（resolved）或有一个 Promise 已拒绝（rejected）时才会被完成或拒绝。</li><li>Promise.race(iterable)：返回一个 Promise，该 Promise 在可迭代对象中有一个 Promise 已完成或有一个 Promise 已拒绝时即会完成或拒绝。</li><li>then(onFulfilled, onRejected)：用于处理 Promise 的完成（resolved）和拒绝（rejected）两种情况。</li><li>catch(onRejected)：用于处理 Promise 的拒绝（rejected）情况。</li></ol><h3 id="8-2-async-await"><a href="#8-2-async-await" class="headerlink" title="8.2 async await"></a>8.2 async await</h3><blockquote><p>async 函数是一个返回 Promise 的函数。在 async 函数内部，可以使用 await 关键字来等待一个 Promise 对象解析，并将其结果返回。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">myAsyncFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> somePromise <span class="hljs-comment">// 等待 Promise 解析</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-3-Generator-函数"><a href="#8-3-Generator-函数" class="headerlink" title="8.3 Generator 函数"></a>8.3 Generator 函数</h3><blockquote><p>Generator 函数是一种特殊类型的函数，使用 function* 声明。它通过 yield 关键字来控制函数的执行流程，可以暂停和恢复函数的执行。Generator 函数返回的是一个迭代器对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGeneratorFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-title function_">myGeneratorFunction</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>) <span class="hljs-comment">// 输出：1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>) <span class="hljs-comment">// 输出：2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(generator.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>) <span class="hljs-comment">// 输出：3</span><br></code></pre></td></tr></table></figure><h3 id="8-4-什么函数能被作为-Generator-函数"><a href="#8-4-什么函数能被作为-Generator-函数" class="headerlink" title="8.4 什么函数能被作为 Generator 函数"></a>8.4 什么函数能被作为 Generator 函数</h3><blockquote><p>函数前面带有 function* 关键字的即为 Generator 函数。除此之外，任何具有迭代器协议的对象都可以被认为是可作为 Generator 函数的。迭代器协议要求对象包含一个特殊的方法 Symbol.iterator，该方法返回一个具有 next() 方法的迭代器对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可作为 Generator 函数的函数</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">myGeneratorFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">// 可作为 Generator 函数的对象</span><br><span class="hljs-keyword">const</span> myObject = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: <span class="hljs-keyword">function</span>* () &#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span><br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9、箭头函数与普通函数的区别，不能做构造函数，那说说使用-new-关键字的原理"><a href="#9、箭头函数与普通函数的区别，不能做构造函数，那说说使用-new-关键字的原理" class="headerlink" title="9、箭头函数与普通函数的区别，不能做构造函数，那说说使用 new 关键字的原理"></a>9、箭头函数与普通函数的区别，不能做构造函数，那说说使用 new 关键字的原理</h2><h3 id="9-1-箭头函数与普通函数的区别"><a href="#9-1-箭头函数与普通函数的区别" class="headerlink" title="9.1 箭头函数与普通函数的区别"></a>9.1 箭头函数与普通函数的区别</h3><ol><li>语法形式：<br>普通函数：function 函数名(参数 1, 参数 2, …) { 函数体 }<br>箭头函数：(参数 1, 参数 2, …) &#x3D;&gt; { 函数体 }</li><li>this 指向：<br>普通函数：this 指向调用它的对象<br>箭头函数：没有自己的 this，它继承自外围作用域的 this</li><li>arguments 对象：<br>普通函数：arguments 对象包含了函数调用时传递的所有参数<br>箭头函数：arguments 对象不可用</li><li>new 关键字：<br>普通函数：可以使用 new 关键字调用，返回一个新的对象<br>箭头函数：不能使用 new 关键字调用，否则会抛出错误</li><li>原型：<br>普通函数：拥有原型对象<br>箭头函数：没有原型对象</li><li>作为构造函数：<br>普通函数：可以使用 new 关键字调用，返回一个新的对象<br>箭头函数：不能使用 new 关键字调用，否则会抛出错误</li><li>箭头函数不能用作 Generator 函数，不能使用 yeild 关键字</li></ol><h3 id="9-2-new-关键字的原理"><a href="#9-2-new-关键字的原理" class="headerlink" title="9.2 new 关键字的原理"></a>9.2 new 关键字的原理</h3><ol><li>创建一个新对象： 创建一个新的空对象，作为构造函数的实例。</li><li>将新对象的__proto__指向构造函数的原型对象： 将新对象的原型链连接到构造函数的 prototype 对象上。</li><li>将构造函数的 this 绑定到新对象： 在构造函数内部，this 指向新创建的对象。</li><li>执行构造函数的代码： 执行构造函数内部的代码，对新对象进行初始化。</li><li>返回新对象： 如果构造函数内部没有显式返回一个对象，则返回新创建的对象。如果有显式返回一个对象，则返回该对象。</li></ol><h3 id="9-3-new-关键字的实现"><a href="#9-3-new-关键字的实现" class="headerlink" title="9.3 new 关键字的实现"></a>9.3 new 关键字的实现</h3><blockquote><p>使用箭头函数时，由于箭头函数没有自己的 this，无法通过 new 关键字创建新对象，因此箭头函数不能用作构造函数。如果尝试使用 new 调用箭头函数，会抛出一个 TypeError</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">MyArrowFunction</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-number">42</span><br>&#125;<br><br><span class="hljs-comment">// 下面的代码会抛出 TypeError: MyArrowFunction is not a constructor</span><br><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyArrowFunction</span>()<br></code></pre></td></tr></table></figure><h2 id="10、React-生命周期函数"><a href="#10、React-生命周期函数" class="headerlink" title="10、React 生命周期函数"></a>10、React 生命周期函数</h2><blockquote><p>React 的生命周期可以分为三个阶段：<strong>挂载阶段（Mounting）</strong>、<strong>更新阶段（Updating）</strong>、<strong>卸载阶段（Unmounting）</strong>。以下是 React 类组件中常用的生命周期方法：</p></blockquote><h3 id="旧版生命周期"><a href="#旧版生命周期" class="headerlink" title="旧版生命周期"></a>旧版生命周期</h3><img src="/2024/01/20/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2-id1/old_lifecycle.png" class><h3 id="新版生命周期"><a href="#新版生命周期" class="headerlink" title="新版生命周期"></a>新版生命周期</h3><img src="/2024/01/20/%E9%9D%A2%E8%AF%95%E5%AE%9E%E6%88%98/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2-id1/new_lifecycle.png" class><h3 id="挂载阶段（Mounting）："><a href="#挂载阶段（Mounting）：" class="headerlink" title="挂载阶段（Mounting）："></a>挂载阶段（Mounting）：</h3><ol><li>**constructor()**：<ul><li>在组件被创建时调用。</li><li>初始化组件的状态（state）和绑定事件处理函数。</li></ul></li><li>**static getDerivedStateFromProps(props, state)**：<ul><li>在组件创建时和更新时调用。</li><li>用于派生状态（根据 props 更新 state）。</li></ul></li><li>**render()**：<ul><li>渲染组件的 UI。</li></ul></li><li>**componentDidMount()**：<ul><li>在组件挂载后调用。</li><li>可以进行异步操作、订阅数据、更新状态等。</li></ul></li></ol><h3 id="更新阶段（Updating）："><a href="#更新阶段（Updating）：" class="headerlink" title="更新阶段（Updating）："></a>更新阶段（Updating）：</h3><ol><li>**static getDerivedStateFromProps(props, state)**：<ul><li>在组件创建时和更新时调用。</li><li>用于派生状态（根据 props 更新 state）。</li></ul></li><li>**shouldComponentUpdate(nextProps, nextState)**：<ul><li>在组件接收到新的 props 或 state 时调用。</li><li>用于决定是否重新渲染组件，默认返回 <code>true</code>。</li></ul></li><li>**render()**：<ul><li>渲染组件的 UI。</li></ul></li><li>**getSnapshotBeforeUpdate(prevProps, prevState)**：<ul><li>在组件更新前调用。</li><li>返回值将作为第三个参数传递给 <code>componentDidUpdate</code>。</li></ul></li><li>**componentDidUpdate(prevProps, prevState, snapshot)**：<ul><li>在组件更新后调用。</li><li>可以进行异步操作、订阅数据、更新状态等。</li></ul></li></ol><h3 id="卸载阶段（Unmounting）："><a href="#卸载阶段（Unmounting）：" class="headerlink" title="卸载阶段（Unmounting）："></a>卸载阶段（Unmounting）：</h3><ol><li>**componentWillUnmount()**：<ul><li>在组件被卸载和销毁前调用。</li><li>用于清理工作，如取消订阅、清除定时器等。</li></ul></li></ol><h3 id="错误处理阶段："><a href="#错误处理阶段：" class="headerlink" title="错误处理阶段："></a>错误处理阶段：</h3><ol><li>**static getDerivedStateFromError(error)**：<ul><li>在渲染阶段后，抛出错误后调用。</li><li>用于更新 state 以显示错误信息。</li></ul></li><li>**componentDidCatch(error, info)**：<ul><li>在组件的子组件抛出错误后调用。</li><li>用于记录错误信息、上报错误等。</li></ul></li></ol><h2 id="11、为什么要使用-hooks，除了复用一些数据状态的逻辑，还有其他原因码吗"><a href="#11、为什么要使用-hooks，除了复用一些数据状态的逻辑，还有其他原因码吗" class="headerlink" title="11、为什么要使用 hooks，除了复用一些数据状态的逻辑，还有其他原因码吗"></a>11、为什么要使用 hooks，除了复用一些数据状态的逻辑，还有其他原因码吗</h2><blockquote><p>Hooks 是 React 16.8 的新增特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p></blockquote><h3 id="1-更容易复用代码"><a href="#1-更容易复用代码" class="headerlink" title="1. 更容易复用代码"></a>1. 更容易复用代码</h3><blockquote><p>通过自定义 hooks 来复用状态，从而解决了类组件有些时候难以复用逻辑的问题</p></blockquote><h3 id="2-清爽的代码风格-代码量更少"><a href="#2-清爽的代码风格-代码量更少" class="headerlink" title="2.清爽的代码风格+代码量更少"></a>2.清爽的代码风格+代码量更少</h3><blockquote><p>函数式编程风格，函数式组件代码量更少</p></blockquote><h3 id="3-更容易理解-可读性更好"><a href="#3-更容易理解-可读性更好" class="headerlink" title="3.更容易理解,可读性更好"></a>3.更容易理解,可读性更好</h3><blockquote><p>通过 React Hooks 可以将功能代码聚合，方便阅读维护</p></blockquote><h3 id="4-组件树层级变浅"><a href="#4-组件树层级变浅" class="headerlink" title="4.组件树层级变浅"></a>4.组件树层级变浅</h3><blockquote><p>通过 React Hooks 可以将功能代码聚合，减少组件层级</p></blockquote><h3 id="5-Hooks-更符合未来的发展趋势"><a href="#5-Hooks-更符合未来的发展趋势" class="headerlink" title="5.Hooks 更符合未来的发展趋势"></a>5.Hooks 更符合未来的发展趋势</h3><blockquote><p>React 团队在文档中明确表示，将主要关注 Hooks 的发展和优化，未来的新特性可能更倾向于 Hooks 而非类组件。</p></blockquote><h2 id="12、代码：给一个数组的版本号排序"><a href="#12、代码：给一个数组的版本号排序" class="headerlink" title="12、代码：给一个数组的版本号排序"></a>12、代码：给一个数组的版本号排序</h2><h2 id="12、反问"><a href="#12、反问" class="headerlink" title="12、反问"></a>12、反问</h2><p>作者：起个响亮的名字___<br>链接：<a href="https://www.nowcoder.com/feed/main/detail/eced28a9179e49d092f9cb0d04bb9546?sourceSSR=users">https://www.nowcoder.com/feed/main/detail/eced28a9179e49d092f9cb0d04bb9546?sourceSSR=users</a><br>来源：牛客网</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview3-js高频底层问题</title>
    <link href="/2024/01/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview3-js%E9%AB%98%E9%A2%91%E5%BA%95%E5%B1%82%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/20/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview3-js%E9%AB%98%E9%A2%91%E5%BA%95%E5%B1%82%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-3-js-高频底层问题"><a href="#🍭-面试-3-js-高频底层问题" class="headerlink" title="🍭 面试 3-js 高频底层问题"></a>🍭 面试 3-js 高频底层问题</h1><h2 id="1-各场景下-this-的指向"><a href="#1-各场景下-this-的指向" class="headerlink" title="1.各场景下 this 的指向"></a>1.各场景下 this 的指向</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>普通函数<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//1.this指向window</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//2.普通函数中的this指向window</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//3.构造函数中的this指向实例对象</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>() <span class="hljs-comment">// Foo &#123;&#125;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//4.对象中的函数中的this指向上一级对象</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;obj&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj2 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// obj</span></span><br><span class="language-javascript">      obj2.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// 2</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//5.箭头函数中的this指向window</span></span><br><span class="language-javascript">      <span class="hljs-comment">//因为箭头函数没有作用域，所以this指向window</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj3 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span></span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj3.<span class="hljs-property">b</span>.<span class="hljs-title function_">foo</span>() <span class="hljs-comment">// window undefined</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//6.箭头函数的call/apply/bind无法改变this指向</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> obj4 = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">b</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// window</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// undefined</span></span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      obj4.<span class="hljs-property">b</span>.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> &#125;) <span class="hljs-comment">// window undefined</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">//7.function中的call/apply/bind可以改变this指向</span></span><br><span class="language-javascript">      <span class="hljs-comment">//call:&#123;&#125;,改变this指向，立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//apply:[],改变this指向，立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//bind:返回一个新的函数,改变this指向，不会立即执行</span></span><br><span class="language-javascript">      <span class="hljs-comment">//this都指向第一个参数</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>) <span class="hljs-comment">// 1</span></span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">      foo.<span class="hljs-title function_">call</span>(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;) <span class="hljs-comment">// &#123;a:1&#125;</span></span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2.闭包"></a>2.闭包</h2><h3 id="2-1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"><a href="#2-1-为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？" class="headerlink" title="2.1 为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？"></a>2.1 为什么要用闭包？闭包有什么作用？闭包的缺点是什么？闭包的应用场景有哪些？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">1.闭包的本质：闭包是由函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。<br>一个拥有外层函数对象所对应的活跃对象引用的函数对象就被称为闭包。<br>2.闭包的作用：可以读取函数内部的变量，让这些变量的值始终保持在内存中，不会在函数调用后被自动清除（私有化变量）<br>3.闭包的缺点：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏<br>4.闭包的应用场景：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>1.函数作为返回值、参数传递<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>2.闭包可以实现封装，防止变量被全局污染 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>3.闭包可以实现JS的模<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.闭包可以缓存变量(数据私有化) <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>5.防抖、节流、库的封装、柯里化、高阶函数<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-闭包的实现原理-AO-GO"><a href="#2-2-闭包的实现原理-AO-GO" class="headerlink" title="2.2 闭包的实现原理 + AO + GO"></a>2.2 闭包的实现原理 + AO + GO</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">1.当函数执行完毕后，其作用域链会被销毁，但是闭包的作用域链不会被销毁，因为闭包的作用域链是在函数执行完毕后创建的。<br>2.当函数执行完毕后，其活动对象也会被销毁，但是闭包的活动对象不会被销毁，因为闭包的活动对象是在函数执行完毕后创建的。<br></code></pre></td></tr></table></figure><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">AO:</span>活动对象 Activation <span class="hljs-type">Object</span>:函数上下文<br><br><span class="hljs-symbol">GO:</span>全局对象 <span class="hljs-keyword">Global</span> <span class="hljs-type">Object</span> :全局上下文<br></code></pre></td></tr></table></figure><h3 id="2-3-闭包例子"><a href="#2-3-闭包例子" class="headerlink" title="2.3 闭包例子"></a>2.3 闭包例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCount</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compute</span>(<span class="hljs-params">a</span>) &#123;<br>    count += a<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">add</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(a)<br>    &#125;,<br>    <span class="hljs-attr">del</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) &#123;<br>      <span class="hljs-title function_">compute</span>(-a)<br>    &#125;,<br>    <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> count<br>    &#125;,<br>  &#125;<br>  <span class="hljs-keyword">return</span> compute<br>&#125;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">makeCount</span>()<br>counter.<span class="hljs-title function_">compute</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>)<br>counter.<span class="hljs-title function_">del</span>(<span class="hljs-number">5</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">getCount</span>()) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h2 id="3-原生-js-实现事件委托"><a href="#3-原生-js-实现事件委托" class="headerlink" title="3.原生 js 实现事件委托"></a>3.原生 js 实现事件委托</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>事件委托<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托含义和原理：利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的好处：可以减少内存消耗，减少事件注册，提高性能</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的缺点：事件委托的事件处理程序不能获取事件对象，因为事件处理程序是在另外一个元素上执行的</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的应用场景：1.动态添加的元素 2.大量元素绑定同一事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现：1.利用事件冒泡 2.判断事件源</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现步骤：1.获取事件源 2.判断事件源 3.处理事件</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 事件委托的实现代码：</span></span><br><span class="language-javascript">      <span class="hljs-comment">// 1.获取事件源</span></span><br><span class="language-javascript">      <span class="hljs-keyword">var</span> ul = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;ul&#x27;</span>)</span><br><span class="language-javascript">      <span class="hljs-comment">// 2.判断事件源</span></span><br><span class="language-javascript">      ul.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        e = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span></span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> target = e.<span class="hljs-property">target</span> || e.<span class="hljs-property">srcElement</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 3.处理事件</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">innerHTML</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-new-操作符做了什么"><a href="#4-new-操作符做了什么" class="headerlink" title="4.new 操作符做了什么"></a>4.new 操作符做了什么</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">1.创建一个空对象，作为将要返回的对象实例<br>2.将这个空对象的原型，指向构造函数的prototype属性<br>3.将这个空对象赋值给函数内部的this关键字 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>4.开始执行构造函数内部的代码 5.返回新对象<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">make, model</span>) &#123;<br>  <span class="hljs-comment">// 步骤 3：将构造函数的上下文绑定到新对象</span><br>  <span class="hljs-comment">// 步骤 4：执行构造函数代码</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">make</span> = make<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span> = model<br>&#125;<br><br><span class="hljs-comment">// 步骤 2：设置原型链</span><br><span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">drive</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Driving a <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.make&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model&#125;</span>`</span>)<br>&#125;<br><br><span class="hljs-comment">// 步骤 1：创建一个空对象</span><br><span class="hljs-keyword">const</span> myCar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(<span class="hljs-string">&#x27;Toyota&#x27;</span>, <span class="hljs-string">&#x27;Camry&#x27;</span>)<br><br><span class="hljs-comment">// 步骤 5：返回新对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myCar.<span class="hljs-property">make</span>) <span class="hljs-comment">// 输出 &#x27;Toyota&#x27;</span><br>myCar.<span class="hljs-title function_">drive</span>() <span class="hljs-comment">// 输出 &#x27;Driving a Toyota Camry&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nginx部署</title>
    <link href="/2023/12/22/%E6%8A%80%E6%9C%AF/nginx%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/12/22/%E6%8A%80%E6%9C%AF/nginx%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-nginx-部署"><a href="#🍭-nginx-部署" class="headerlink" title="🍭 nginx 部署"></a>🍭 nginx 部署</h1><h2 id="1-购买服务器"><a href="#1-购买服务器" class="headerlink" title="1.购买服务器"></a>1.购买服务器</h2><h2 id="2-开放安全组端口-22-和-80"><a href="#2-开放安全组端口-22-和-80" class="headerlink" title="2.开放安全组端口 22 和 80"></a>2.开放安全组端口 22 和 80</h2><h2 id="3-远程连接服务器-安装-nginx"><a href="#3-远程连接服务器-安装-nginx" class="headerlink" title="3.远程连接服务器,安装 nginx"></a>3.远程连接服务器,安装 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.安装nginx</span><br>yum install nginx<br><span class="hljs-comment"># 2.启动nginx</span><br>systemctl start nginx<br><span class="hljs-comment"># 3.查看nginx状态</span><br>systemctl status nginx<br><span class="hljs-comment"># 4.关闭防火墙</span><br>systemctl stop firewalld<br><span class="hljs-comment"># 5.reload nginx</span><br>nginx -s reload<br><span class="hljs-comment"># 6.kill 占用80端口的进程</span><br>lsof -i:80<br><span class="hljs-built_in">kill</span> -9 pid<br></code></pre></td></tr></table></figure><h2 id="4-配置-nginx"><a href="#4-配置-nginx" class="headerlink" title="4.配置 nginx"></a>4.配置 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.进入nginx配置文件</span><br><span class="hljs-built_in">cd</span> /etc/nginx<br><span class="hljs-comment"># 2.查看conf.d目录下的配置文件</span><br>vim nginx.conf<br></code></pre></td></tr></table></figure><h3 id="1-配置反向代理"><a href="#1-配置反向代理" class="headerlink" title="1.配置反向代理"></a>1.配置反向代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.在http中添加server</span><br>server &#123;<br>    listen       80; <span class="hljs-comment">#端口</span><br>    server_name  localhost; <span class="hljs-comment">#域名(公网ip)</span><br>    location / &#123;<br>        proxy_pass http:// <span class="hljs-comment">#反向代理地址(项目文件);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-transmit-通过-SFPT-连接服务器"><a href="#5-transmit-通过-SFPT-连接服务器" class="headerlink" title="5.transmit 通过 SFPT 连接服务器"></a>5.transmit 通过 SFPT 连接服务器</h2><pre><code class="hljs">网址：公网ip端口：22用户名：root密码：自己设置的密码</code></pre><h3 id="5-1-上传项目文件到服务器"><a href="#5-1-上传项目文件到服务器" class="headerlink" title="5.1.上传项目文件到服务器"></a>5.1.上传项目文件到服务器</h3><pre><code class="hljs">将项目文件放置到nginx配置的反向代理地址location / &#123;    proxy_pass http:// #反向代理地址(项目文件);&#125;</code></pre><h2 id="6-重启-nginx"><a href="#6-重启-nginx" class="headerlink" title="6.重启 nginx"></a>6.重启 nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.重启nginx</span><br>nginx -s reload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vite3+vue基础配置</title>
    <link href="/2023/12/19/vue/vite3-vue%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/19/vue/vite3-vue%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-vite3-vue-基础配置"><a href="#🍭-vite3-vue-基础配置" class="headerlink" title="🍭 vite3+vue 基础配置"></a>🍭 vite3+vue 基础配置</h1><h2 id="1-配置-scss-x2F-less-css编译"><a href="#1-配置-scss-x2F-less-css编译" class="headerlink" title="1.配置 scss&#x2F;less css编译"></a>1.配置 scss&#x2F;less css编译</h2><blockquote><p>1.安装依赖</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs zsh">npm i -D sass sass-loader less less-loader<br></code></pre></td></tr></table></figure><blockquote><p>2.配置 vite.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-comment">// 配置scss/less</span><br>  <span class="hljs-attr">css</span>: &#123;<br>    <span class="hljs-attr">preprocessorOptions</span>: &#123;<br>      <span class="hljs-attr">scss</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;@/assets/scss/variables.scss&quot;;`</span>,<br>      &#125;,<br>      <span class="hljs-attr">less</span>: &#123;<br>        <span class="hljs-attr">additionalData</span>: <span class="hljs-string">`@import &quot;@/assets/less/variables.less&quot;;`</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-配置-alias-路径"><a href="#2-配置-alias-路径" class="headerlink" title="2.配置 alias 路径"></a>2.配置 alias 路径</h2><blockquote><p>1.配置 vite.config.js</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-comment">//配置alias</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview2</title>
    <link href="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview2/"/>
    <url>/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview2/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-2"><a href="#🍭-面试-2" class="headerlink" title="🍭 面试 2"></a>🍭 面试 2</h1><h2 id="大厂"><a href="#大厂" class="headerlink" title="大厂"></a>大厂</h2><h3 id="0-https-www-baidu-com-80-abc-d-1-e"><a href="#0-https-www-baidu-com-80-abc-d-1-e" class="headerlink" title="0.https://www.baidu.com:80/abc?d=1#e"></a>0.<a href="https://www.baidu.com:80/abc?d=1#e">https://www.baidu.com:80/abc?d=1#e</a></h3><pre><code class="hljs">1. https: 协议 http和tcp的结合之间加了一层SSL或TSL安全层2. www.baidu.com 域名;www:三级域名 baidu:二级域名 com:顶级域名3. 80 端口号4. / 路径5. ? 后面是查询参数6. # 后面是锚点</code></pre><h3 id="1-在浏览器输入-url-到页面展示发生了什么"><a href="#1-在浏览器输入-url-到页面展示发生了什么" class="headerlink" title="1.在浏览器输入 url 到页面展示发生了什么"></a>1.在浏览器输入 url 到页面展示发生了什么</h3><pre><code class="hljs">1.浏览器根据DNS服务器得到域名的IP地址2.向这个IP的机器发送http请求3.服务器收到、处理并返回http请求(三次握手)4.浏览器得到返回内容5.浏览器解析渲染页面6.连接结束(四次挥手)</code></pre><h3 id="2-渲染页面"><a href="#2-渲染页面" class="headerlink" title="2.渲染页面"></a>2.渲染页面</h3><pre><code class="hljs">1.根据HTML结构生成DOM Tree2.根据CSS生成CSSOM3.将DOM和CSSOM整合形成RenderTree4.根据RenderTree开始渲染和展示5.遇到&lt;script&gt;时，会执行并阻塞渲染；遇到&lt;link&gt;不会阻塞渲染；遇到&lt;style&gt;会阻塞渲染；遇到&lt;img&gt;会阻塞渲染6.计算布局信息7.将RenderTree渲染到屏幕上</code></pre><h4 id="2-1-https-www-baidu-com-与-https-www-baidu-com-的区别"><a href="#2-1-https-www-baidu-com-与-https-www-baidu-com-的区别" class="headerlink" title="2.1 https://www.baidu.com/ 与 https://www.baidu.com 的区别"></a>2.1 <a href="https://www.baidu.com/">https://www.baidu.com/</a> 与 <a href="https://www.baidu.com/">https://www.baidu.com</a> 的区别</h4><pre><code class="hljs">1.前者会发送请求，后者不会2.前者会刷新页面，后者不会</code></pre><h3 id="3-浏览器性能优化"><a href="#3-浏览器性能优化" class="headerlink" title="3.浏览器性能优化"></a>3.浏览器性能优化</h3><pre><code class="hljs">a.加载页面    1.减少http请求(合并文件、雪碧图/精灵图、使用base64)    2.减小资源体积(压缩代码、压缩图片)    3.使用CDN(第三方资源库)    4.SSR(服务端渲染)    5.懒加载(图片懒加载、下拉加载更多)    6.app/小程序(分包加载)b.页面渲染    1.减少DOM操作(合并DOM、缓存DOM查询结果)    2.减少重绘和回流(使用transform替代top、left等)    3.使用requestAnimationFrame代替setTimeout    4.使用Web Worker    5.使用虚拟DOM</code></pre><h3 id="4-图片懒加载"><a href="#4-图片懒加载" class="headerlink" title="4.图片懒加载"></a>4.图片懒加载</h3><pre><code class="hljs">1.图片懒加载的原理    1.图片不设置src属性，而是设置一个自定义属性，比如data-src    2.当图片进入可视区域时，再把自定义属性的值赋值给src2.图片懒加载的优点    1.减少http请求，提升页面加载速度    2.节省服务器的带宽    3.节省浏览器的内存3.图片懒加载的缺点    1.增加了代码复杂度    2.用户体验不好，用户可能会看到一张一张图片的显示</code></pre><h4 id="4-1-图片懒加载的实现"><a href="#4-1-图片懒加载的实现" class="headerlink" title="4.1 图片懒加载的实现"></a>4.1 图片懒加载的实现</h4><pre><code class="hljs"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default1.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default2.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target2.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;default3.jpg&quot;</span> <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;http://www.xxx.com/target3.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;img&#x27;</span>); <span class="hljs-comment">// 获取所有图片imgs=[img,img,img]</span><br><span class="hljs-keyword">var</span> num = imgs.<span class="hljs-property">length</span>; <span class="hljs-comment">// 图片的数量</span><br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器</span><br><span class="hljs-title function_">lazyload</span>(); <span class="hljs-comment">// 首次加载别忘了显示图片</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, lazyload); <span class="hljs-comment">// 监听滚动事件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyload</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> viewHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">// 可视区域的高度</span><br>    <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span>; <span class="hljs-comment">// 滚动条距离顶部的高度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = count; i &lt; num; i++) &#123; <span class="hljs-comment">// 从计数器的值开始，遍历每个图片</span><br>        <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-property">offsetTop</span> &lt; viewHeight + scrollTop) &#123; <span class="hljs-comment">// 图片进入可视区域</span><br>            <span class="hljs-keyword">if</span> (imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>) !== <span class="hljs-string">&#x27;default.jpg&#x27;</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果图片已经加载过，则跳过</span><br>            imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>); <span class="hljs-comment">// 设置图片src为data-src(加载图片)</span><br>            count++; <span class="hljs-comment">// 计数器累加</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>interview1-css</title>
    <link href="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/"/>
    <url>/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-面试-css"><a href="#🍭-面试-css" class="headerlink" title="🍭 面试-css"></a>🍭 面试-css</h1><h2 id="1-字节题-1css"><a href="#1-字节题-1css" class="headerlink" title="1. 字节题 1css"></a>1. 字节题 1css</h2><h3 id="1-盒居中"><a href="#1-盒居中" class="headerlink" title="1.盒居中"></a>1.盒居中</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>居中<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">margin</span>: auto;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-padding-与-margin"><a href="#2-padding-与-margin" class="headerlink" title="2.padding 与 margin"></a>2.padding 与 margin</h3><pre><code class="hljs">1.padding作用于元素内容，会撑大元素大小2.margin作用于元素外部，不会撑大元素大小</code></pre><h3 id="3-vw-和百分比"><a href="#3-vw-和百分比" class="headerlink" title="3.vw 和百分比"></a>3.vw 和百分比</h3><pre><code class="hljs">1.vw是相对于视口的宽度2.百分比会继承父元素的宽度，vw不会</code></pre><h3 id="4-行内元素与块级元素"><a href="#4-行内元素与块级元素" class="headerlink" title="4.行内元素与块级元素"></a>4.行内元素与块级元素</h3><pre><code class="hljs">1.行内元素不换行，行内元素不可以设置大小，行内元素大小由内容决定2.块级元素换行，块级元素可以设置大小，块级元素大小由父元素决定</code></pre><h3 id="5-使谷歌浏览器字体（清晰，更小）"><a href="#5-使谷歌浏览器字体（清晰，更小）" class="headerlink" title="5.使谷歌浏览器字体（清晰，更小）"></a>5.使谷歌浏览器字体（清晰，更小）</h3><pre><code class="hljs">1.清晰：-webkit-font-smoothing: antialiased;2.更小：-webkit-text-size-adjust: 50%; // scale(0.5)</code></pre><h2 id="2-知识点"><a href="#2-知识点" class="headerlink" title="2.知识点"></a>2.知识点</h2><h3 id="2-1-css-盒模型"><a href="#2-1-css-盒模型" class="headerlink" title="2.1 css 盒模型"></a>2.1 css 盒模型</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">HTML中的每个元素都可以看作一个盒子，<br>这个盒子由元素的内容(content)、内边距(padding)、边框(border)、外边距(margin)组成。<br></code></pre></td></tr></table></figure><blockquote><p>盒模型分为两种：标准盒模型和 IE 盒模型。</p></blockquote><p>1.<strong>标准盒模型</strong>：width &#x3D; margin + border + padding + content</p><p>2.<strong>IE 盒模型</strong>：width &#x3D; margin + content(包含 border 和 padding)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-selector-class">.box</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> solid red;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br>    <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* IE 盒模型 */</span><br>    <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 标准盒模型(默认值) */</span><br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h3 id="2-2-css-选择器"><a href="#2-2-css-选择器" class="headerlink" title="2.2 css 选择器"></a>2.2 css 选择器</h3><blockquote><p>css 选择器分为五种：标签选择器、类&#x2F;伪类&#x2F;属性选择器、id 选择器、通配符选择器、行内样式、!important</p></blockquote><p>优先级：!important &gt; 行内样式 &gt; id 选择器 &gt; 类&#x2F;伪类&#x2F;属性选择器 &gt; 标签选择器 &gt; 通配符选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-comment">/* 标签选择器 */</span><br>  <span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 类选择器 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 伪类选择器 */</span><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 属性选择器 */</span><br><span class="hljs-selector-class">.box</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&#x27;text&#x27;</span>]</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* id选择器 */</span><br><span class="hljs-selector-id">#box</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 通配符选择器 */</span><br>* &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-comment">/* 行内样式 */</span><br>&lt;<span class="hljs-selector-tag">div</span> style=&quot;<span class="hljs-attribute">color</span>: red<span class="hljs-string">&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">  /* !important */</span><br><span class="hljs-string">  .box &#123;</span><br><span class="hljs-string">  color: red !important;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-隐藏元素的方法"><a href="#2-3-隐藏元素的方法" class="headerlink" title="2.3 隐藏元素的方法"></a>2.3 隐藏元素的方法</h3><blockquote><p>1.display:none 2.visibility:hidden 3.opacity:0 4.position:absolute;left:-9999px 5.transform:scale(0) 6.clip-path:polygon(0 0,0 0,0 0,0 0)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 1.display:none */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">display</span>: none;<br>&#125;<br><span class="hljs-comment">/* 2.visibility:hidden */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">visibility</span>: hidden;<br>&#125;<br><span class="hljs-comment">/* 3.opacity:0 */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* 4.position:absolute;left:-9999px */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">9999px</span>;<br>&#125;<br><span class="hljs-comment">/* 5.transform:scale(0) */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">/* 6.clip-path:polygon(0 0,0 0,0 0,0 0) */</span><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-px-和-rem-的区别"><a href="#2-4-px-和-rem-的区别" class="headerlink" title="2.4 px 和 rem 的区别"></a>2.4 px 和 rem 的区别</h3><blockquote><p>px 是相对长度单位，像素 px 是相对于显示器屏幕分辨率而言的</p></blockquote><blockquote><p>rem 是 CSS3 新增的一个相对单位,rem 相对于根元素 html 的 font-size 大小来计算的</p></blockquote><h3 id="2-5-重绘和重排的区别"><a href="#2-5-重绘和重排的区别" class="headerlink" title="2.5 重绘和重排的区别"></a>2.5 重绘和重排的区别</h3><blockquote><p>重绘 repaint：当盒子的颜色发生改变，那么浏览器将使用保存的位图，只需要对屏幕重新进行绘制，这个过程称为重绘(某些元素的外观被改变)</p></blockquote><blockquote><p>重排(回流)reflow：当盒子的位置、大小以及其他属性发生改变，浏览器需要重新计算元素的几何属性，其他元素的几何属性和位置也会因此受到影响，浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树，这个过程称为重排(重新生成布局，重新排列元素)</p></blockquote><p><strong>重绘不一定会引发重排，重排一定会引发重绘</strong></p><h4 id="浏览器页面渲染过程"><a href="#浏览器页面渲染过程" class="headerlink" title="浏览器页面渲染过程"></a>浏览器页面渲染过程</h4><pre><code class="hljs">1.HTML 被 HTML 解析器解析成 DOM 树；2.CSS  被 CSS 解析器解析成 CSSOM 树；3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；5.将布局绘制(paint)在屏幕上，显示出整个页面。</code></pre><img src="/2023/11/23/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/interview-css/reflow.png" class title="This is an test image"><h3 id="2-6-css-哪些属性可以继承，哪些不可以"><a href="#2-6-css-哪些属性可以继承，哪些不可以" class="headerlink" title="2.6 css 哪些属性可以继承，哪些不可以"></a>2.6 css 哪些属性可以继承，哪些不可以</h3><ol><li>字体系列的属性可以继承，如：font-family、font-size、font-weight、font-style 等</li><li>文本系列的属性可以继承，如：text-indent、text-align、line-height、word-spacing、letter-spacing、text-transform、color 等</li><li>元素可见性相关属性可以继承，如：visibility 和 cursor</li><li>表格布局属性可以继承，如：border-collapse</li><li>列表属性可以继承，如：list-style、list-style-type、list-style-position、list-style-image</li><li>元素尺寸相关属性不可以继承，如：width、height、margin、padding、border、top、right、bottom、left、position、overflow、display、float、clear、min-width、min-height、max-width、max-height、z-index、vertical-align</li></ol><h3 id="2-7-预处理器"><a href="#2-7-预处理器" class="headerlink" title="2.7 预处理器"></a>2.7 预处理器</h3><p>预处理器添加了一些例如变量、嵌套、混合、导入、函数。</p><blockquote><p>less<br>sass</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS基础内容总结</title>
    <link href="/2022/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%934/"/>
    <url>/2022/09/28/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%934/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H5C3知识总结</title>
    <link href="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/"/>
    <url>/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-H5C3知识总结"><a href="#🍭-H5C3知识总结" class="headerlink" title="🍭 H5C3知识总结"></a>🍭 H5C3知识总结</h1><h2 id="HTML新增样式"><a href="#HTML新增样式" class="headerlink" title="HTML新增样式"></a>HTML新增样式</h2><h2 id="1，语义化标签"><a href="#1，语义化标签" class="headerlink" title="1，语义化标签"></a>1，语义化标签</h2><pre><code class="hljs">1.&lt;header&gt;&lt;/header&gt;  2.&lt;nav&gt;&lt;/nav&gt;  3.&lt;article&gt;&lt;/article&gt;   4&lt;section&gt;&lt;/section&gt;  5.&lt;aside&gt;&lt;/aside&gt; 6.&lt;footer&gt;&lt;/footer&gt;</code></pre><hr><h2 id="2-video标签"><a href="#2-video标签" class="headerlink" title="2.video标签"></a>2.video标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">‘文件地址’</span> <span class="hljs-attr">...</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">autoplay</td><td align="center">autoplay</td><td align="center">视频就绪自动播放 （谷歌浏览器需要添加muted来解 决自动播放问题）</td></tr><tr><td align="center">controls</td><td align="center">controls</td><td align="center">向用户显示播放控件</td></tr><tr><td align="center">width</td><td align="center">pixels（像素）</td><td align="center">设置播放器宽度</td></tr><tr><td align="center">height</td><td align="center">pixels（像素）</td><td align="center">设置播放器高度</td></tr><tr><td align="center">loop</td><td align="center">loop</td><td align="center">播放完是否继续播放该视频，循环播放</td></tr><tr><td align="center">preload</td><td align="center">auto（预先加载视频） none（不应加载视频）</td><td align="center">规定是否预加载视频（如果有了autoplay就忽略该属性）</td></tr><tr><td align="center">src</td><td align="center">url</td><td align="center">视频urt地址</td></tr><tr><td align="center">poster</td><td align="center">Imgurl</td><td align="center">加载等待的画面图片</td></tr><tr><td align="center">muted</td><td align="center">muted</td><td align="center">静音播放</td></tr></tbody></table><hr><h2 id="3-audio标签"><a href="#3-audio标签" class="headerlink" title="3.audio标签"></a>3.audio标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">‘文件地址’</span> <span class="hljs-attr">...</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其他属性：</p><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">autoplay</td><td align="center">autoplay</td><td align="center">如果出现该属性，则音频在就绪后马上播放。</td></tr><tr><td align="center">controls</td><td align="center">controls</td><td align="center">如果出现该属性，则向用户显示控件，比如播放按钮。</td></tr><tr><td align="center">loop</td><td align="center">loop</td><td align="center">如果出现该属性，则每当音频结束时重新开始播放。</td></tr><tr><td align="center">src</td><td align="center">url</td><td align="center">要播放的音频的URL。</td></tr></tbody></table><hr><h2 id="4-input类型"><a href="#4-input类型" class="headerlink" title="4.input类型"></a>4.input类型</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;...&#x27;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.type类属性：</p><table><thead><tr><th align="center">type值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">type&#x3D;”email”</td><td align="center">限制用户输入必须为Email类型</td></tr><tr><td align="center">type&#x3D;”url</td><td align="center">限制用户输入必须为URL类型</td></tr><tr><td align="center">type&#x3D;”date”</td><td align="center">限制用户输入必须为日期类型</td></tr><tr><td align="center">type&#x3D;”time”</td><td align="center">限制用户输入必须为时间类型</td></tr><tr><td align="center">type&#x3D;”month”</td><td align="center">限制用户输入必须为月类型</td></tr><tr><td align="center">type&#x3D;”week”</td><td align="center">限制用户输入必须为周类型</td></tr><tr><td align="center">type&#x3D;”number”</td><td align="center">限制用户输入必须为数字类型</td></tr><tr><td align="center">type&#x3D;”tel”</td><td align="center">手机号码</td></tr><tr><td align="center">type&#x3D;”search”</td><td align="center">搜索框</td></tr><tr><td align="center">type&#x3D;”color”</td><td align="center">生成一个颜色选择表单</td></tr></tbody></table><p>2.input表单属性</p><table><thead><tr><th align="center">属性</th><th align="center">属性值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">required</td><td align="center">required</td><td align="center">表单拥有该属性表示其内容不能为空</td></tr><tr><td align="center">placeholder</td><td align="center">提示文本</td><td align="center">表单的提示信息，存在默认值将不显示</td></tr><tr><td align="center">autofocus</td><td align="center">autofocus</td><td align="center">自动聚焦属性， 页面加载完成自动聚焦到指定表单</td></tr><tr><td align="center">autocomplete</td><td align="center">off&#x2F;on</td><td align="center">当用户在字段开始键入时， 浏览器基于之前键入过的值， 应该显示出在字段中填写的选项。默认已经打开，如 autocomplete&#x3D;”on”关闭autocomplete&#x3D;”off”需要放在表单内，同时加上 name 属性，同时成功提交</td></tr><tr><td align="center">multiple</td><td align="center">multiple</td><td align="center">可以多选文件提交</td></tr></tbody></table><hr><h2 id="CSS内容"><a href="#CSS内容" class="headerlink" title="CSS内容"></a>CSS内容</h2><h2 id="CSS新增选择器"><a href="#CSS新增选择器" class="headerlink" title="CSS新增选择器"></a>CSS新增选择器</h2><h4 id="1-属性选择器"><a href="#1-属性选择器" class="headerlink" title="1.属性选择器"></a>1.属性选择器</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">input[value]   <span class="hljs-comment">&lt;!-- input类里并包含value的input --&gt;</span><br>div[class^=?]  <span class="hljs-comment">&lt;!-- 选择div里class属性开头是？的div --&gt;</span><br>Div[class*=?]  <span class="hljs-comment">&lt;!-- 选择div里class属性包含？的div  --&gt;</span><br>input[value]   <span class="hljs-comment">&lt;!-- input类里并包含value的input --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-结构伪类选择器"><a href="#2-结构伪类选择器" class="headerlink" title="2.结构伪类选择器"></a>2.结构伪类选择器</h4><blockquote><p>选择父元素第n个子元素</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ul li : first-child     <span class="hljs-comment">&lt;!-- 选择ul li 第一个孩子 --&gt;</span><br>ul li : last-child      <span class="hljs-comment">&lt;!-- 选择ul li 最后一个孩子 --&gt;</span><br>ul li : nth-child(n)    <span class="hljs-comment">&lt;!-- 选择ul li 第n个孩子 --&gt;</span><br>ul li : nth-child(even) <span class="hljs-comment">&lt;!-- 偶数 --&gt;</span><br>ul li : nth-child(odd)  <span class="hljs-comment">&lt;!-- 奇数 --&gt;</span><br>ul li : nth-child(n)    <span class="hljs-comment">&lt;!-- 选择ul li 从1-n孩子 --&gt;</span><br><br>element：First-of-type   <span class="hljs-comment">&lt;!-- 选择第一个元素 --&gt;</span><br>element：Second-of-type  <span class="hljs-comment">&lt;!-- 选择第二个元素 --&gt;</span><br>element：Nth-of-type(n)  <span class="hljs-comment">&lt;!-- 选择第n个元素 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-伪元素选择器-行内元素"><a href="#3-伪元素选择器-行内元素" class="headerlink" title="3.伪元素选择器 (行内元素)"></a>3.伪元素选择器 (行内元素)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">1.E::before&#123;content:&#125;   <span class="hljs-comment">&lt;!-- 在元素内部的前面插入内容 --&gt;</span><br>2.E::after&#123;content:&#125;    <span class="hljs-comment">&lt;!-- 在元素内部的后面插入内容 --&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>伪元素清除浮动（尾部阻隔）</p></blockquote><img src="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/tailclear.png" class title="This is an test image"><blockquote><p>伪元素清除浮动（头部阻隔）</p></blockquote><img src="/2022/09/27/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%933/headclear.png" class title="This is an test image"><hr><h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><p>1.不撑开盒子大小</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Box-sizing:border-box<br></code></pre></td></tr></table></figure><p>2.模糊函数  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Filter:blur(?px)<br></code></pre></td></tr></table></figure><p>3.calc函数  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">width:calc(100% - 80px)  <span class="hljs-comment">&lt;!-- 比父盒子100% 小 80px --&gt;</span><br></code></pre></td></tr></table></figure><p>4.过渡 (谁做过渡给谁+) ，(多个属性，隔开)，(all属性全变)</p><pre><code class="hljs">transition：要过渡的属性 花费时间 运动曲线 何时开始；1.属性：想要变化的 css 属性，宽度高度 背景颜色 内外边距都可以。 如果想要所有的属性都变化过渡，写一个all 就可以。2.花费时间：单位是秒（必须写单位） 比如 0.5s 3.运动曲线：默认是 ease （可以省略）4.何时开始：单位是秒（必须写单位） 可以设置延迟触发时间 默认是 Os（可以省略）</code></pre><hr><h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><mark>注意：一般稳定的服务器都是需要收费的。比如：阿里云</mark><blockquote><p>这里给大家推荐一个免费的远程服务器(免费空间) <a href="http://free.3v.do/">http://free.3v.do/</a></p></blockquote><p>1.去免费空间网站注册账号。<br>2.记录下主机名、用户名、密码、域名。<br>3.利用cutftp软件上传网站到远程服务器。<br>4.在浏览器中输入域名，即可访问我们的网站了。</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
    
    
    
    <tags>
      
      <tag>H5C3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS知识总结</title>
    <link href="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/"/>
    <url>/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-CSS内容总结"><a href="#🍭-CSS内容总结" class="headerlink" title="🍭 CSS内容总结"></a>🍭 CSS内容总结</h1><h2 id="1-给定标签类型"><a href="#1-给定标签类型" class="headerlink" title="1.给定标签类型"></a>1.给定标签类型</h2><h4 id="1-1-class类型-（可以调用多次）"><a href="#1-1-class类型-（可以调用多次）" class="headerlink" title="1.1 .class类型   （可以调用多次）"></a>1.1 .class类型   （可以调用多次）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        .red &#123; color=”red”;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><mark>注释：class里可以有多个类名，必须以空格隔开class&#x3D;“first second third”</mark><br><strong>example:</strong><br><font color="red">red</font></p><h4 id="1-2-id类型-只能调用一次）"><a href="#1-2-id类型-只能调用一次）" class="headerlink" title="1.2 #id类型      (只能调用一次）"></a>1.2 #id类型      (只能调用一次）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>        #red &#123; color=”red”;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong><br><font color="red">red</font></p><h4 id="1-3-通配符类型-所有都调用）"><a href="#1-3-通配符类型-所有都调用）" class="headerlink" title="1.3 * 通配符类型  (所有都调用）"></a>1.3 * 通配符类型  (所有都调用）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br>  * &#123;color=”red”;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”red”</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>red<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong><br><font color="red">red</font><br><font color="red">red</font><br><font color="red">red</font></p><hr><h2 id="2-文字样式"><a href="#2-文字样式" class="headerlink" title="2.文字样式"></a>2.文字样式</h2><h4 id="1-Color（文字颜色）"><a href="#1-Color（文字颜色）" class="headerlink" title="1.Color（文字颜色）:"></a>1.Color（文字颜色）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">color: “red”/“#ff0000”/“rgb(255,0,0)”/“rgb(100%,0,0)”;<br></code></pre></td></tr></table></figure><h4 id="2-Background（背景颜色）"><a href="#2-Background（背景颜色）" class="headerlink" title="2. Background（背景颜色）:"></a>2. Background（背景颜色）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background: “red”/“#ff0000”/“rgb(255,0,0)”/“rgb(100%,0,0)”/rgba(100%,0,0,0.3);<br></code></pre></td></tr></table></figure><h4 id="3-font-size（字体大小）"><a href="#3-font-size（字体大小）" class="headerlink" title="3. font-size（字体大小）:"></a>3. font-size（字体大小）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-size: 18px；  //(18像素)<br></code></pre></td></tr></table></figure><h4 id="4-font-family（字体类型）"><a href="#4-font-family（字体类型）" class="headerlink" title="4.font-family（字体类型）:"></a>4.font-family（字体类型）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-family: &quot;icomoon&quot;;    //icomoon字体<br></code></pre></td></tr></table></figure><h4 id="5-font-weight（字体粗细）"><a href="#5-font-weight（字体粗细）" class="headerlink" title="5.font-weight（字体粗细）:"></a>5.font-weight（字体粗细）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-weight:  “normal（400）/bold（700）;”   //(不跟单位)<br></code></pre></td></tr></table></figure><h4 id="6-font-style-（字体样式）"><a href="#6-font-style-（字体样式）" class="headerlink" title="6.font-style （字体样式）:"></a>6.font-style （字体样式）:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font-style:  “italic（斜体）/normal（正常）;”<br></code></pre></td></tr></table></figure><h4 id="7-复合属性："><a href="#7-复合属性：" class="headerlink" title="7.复合属性："></a>7.复合属性：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">font: font-style font-weight font-size/line-height/font-family;<br><span class="hljs-comment">&lt;!-- font-size 和 font-family 不能少 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="8-行高"><a href="#8-行高" class="headerlink" title="8. 行高:"></a>8. 行高:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">line-height= ?px  ;<br><span class="hljs-comment">&lt;!-- 当行高等于总高度则文字垂直居中 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="9-文字位置"><a href="#9-文字位置" class="headerlink" title="9. 文字位置:"></a>9. 文字位置:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">text-align: center  / left  /  right  ;  <br></code></pre></td></tr></table></figure><h4 id="10-划线位置"><a href="#10-划线位置" class="headerlink" title="10.划线位置:"></a>10.划线位置:</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Text-decoration : underline(下划线) / line-through(贯穿线) / overline(上划线) / none  ;<br></code></pre></td></tr></table></figure><h3 id="11-首行缩进"><a href="#11-首行缩进" class="headerlink" title="11.首行缩进:"></a>11.首行缩进:</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Text-indent: 10px / 2em  ;  <br></code></pre></td></tr></table></figure><h4 id="12-文字阴影："><a href="#12-文字阴影：" class="headerlink" title="12.文字阴影："></a>12.文字阴影：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">text-shadow：  h-shadow   v-shadow  blur   spread  color  insert;<br></code></pre></td></tr></table></figure><hr><h2 id="3-行-x2F-块-元素"><a href="#3-行-x2F-块-元素" class="headerlink" title="3.行&#x2F;块 元素"></a>3.行&#x2F;块 元素</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs HTML">display: block;  <span class="hljs-comment">&lt;!--把行内元素改成块级元素--&gt;</span><br>display：inline；<span class="hljs-comment">&lt;!--把块级元素改成行内元素--&gt;</span><br>display：inline-block；<span class="hljs-comment">&lt;!--行内块元素--&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="4-背景元素"><a href="#4-背景元素" class="headerlink" title="4.背景元素"></a>4.背景元素</h2><h4 id="4-1背景颜色"><a href="#4-1背景颜色" class="headerlink" title="4.1背景颜色"></a>4.1背景颜色</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-color:  transparent(透明) /  red红）  /...;<br></code></pre></td></tr></table></figure><h4 id="4-2背景图片"><a href="#4-2背景图片" class="headerlink" title="4.2背景图片"></a>4.2背景图片</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-image: none (空)/ url(url)  （图片地址）;<br></code></pre></td></tr></table></figure><h4 id="4-3背景图片铺方式"><a href="#4-3背景图片铺方式" class="headerlink" title="4.3背景图片铺方式"></a>4.3背景图片铺方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background-repeat: no-repeat(不平铺)/ repeat（平铺）/repeat-x（水平平铺）;<br></code></pre></td></tr></table></figure><h4 id="4-4背景图片位置"><a href="#4-4背景图片位置" class="headerlink" title="4.4背景图片位置"></a>4.4背景图片位置</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">backrgound-position:x y;  <br>x , y = center top left right(方位词)  <br></code></pre></td></tr></table></figure><h4 id="4-5背景颜色透明度"><a href="#4-5背景颜色透明度" class="headerlink" title="4.5背景颜色透明度"></a>4.5背景颜色透明度</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background: rgba(r,g,b,a) ; <span class="hljs-comment">&lt;!-- a取值0-1 --&gt;</span><br>opcity: .5  <span class="hljs-comment">&lt;!-- opcity透明度 --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-6背景移动方式"><a href="#4-6背景移动方式" class="headerlink" title="4.6背景移动方式"></a>4.6背景移动方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Background-attachment : scroll / fixed;<br></code></pre></td></tr></table></figure><h4 id="4-7css背景属性整合写法"><a href="#4-7css背景属性整合写法" class="headerlink" title="4.7css背景属性整合写法"></a>4.7css背景属性整合写法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">background:  color   url(url)  no-repeat  fixed  center  top;<br></code></pre></td></tr></table></figure><hr><h2 id="5-css三大特性（层叠性，继承性，优先级）"><a href="#5-css三大特性（层叠性，继承性，优先级）" class="headerlink" title="5.css三大特性（层叠性，继承性，优先级）"></a>5.css三大特性（层叠性，继承性，优先级）</h2><pre><code class="hljs">层叠性: 样式冲突覆盖  继承性: 子继承父  优先级: 权重</code></pre><p><mark>权重大小</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/css%E6%9D%83%E9%87%8D.png" class title="This is an test image"><p><mark>注意:复合选择器有权重叠加问题</mark></p><hr><h2 id="6-css书写顺序"><a href="#6-css书写顺序" class="headerlink" title="6.css书写顺序"></a>6.css书写顺序</h2><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/css%E4%B9%A6%E5%86%99%E9%A1%BA%E5%BA%8F.png" class title="This is an test image"><hr><h2 id="7-选择器"><a href="#7-选择器" class="headerlink" title="7.选择器"></a>7.选择器</h2><h4 id="7-1-后代选择器："><a href="#7-1-后代选择器：" class="headerlink" title="7.1 后代选择器："></a>7.1 后代选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ol li &#123; color: pink;&#125;  <span class="hljs-comment">&lt;!--改变ol下li中文字颜色--&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-2-子选择器："><a href="#7-2-子选择器：" class="headerlink" title="7.2 子选择器："></a>7.2 子选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">ol&gt;li&#123;&#125;  <span class="hljs-comment">&lt;!-- 只改变ol下一级li --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-3-并集选择器："><a href="#7-3-并集选择器：" class="headerlink" title="7.3 并集选择器："></a>7.3 并集选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">div,p&#123;&#125;  <span class="hljs-comment">&lt;!-- 改变div和p --&gt;</span><br></code></pre></td></tr></table></figure><h4 id="7-4-伪类选择器："><a href="#7-4-伪类选择器：" class="headerlink" title="7.4 伪类选择器："></a>7.4 伪类选择器：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">a:link&#123;color: &#125;      // (未访问链接）  <br>a:visited&#123;color: &#125;   //（访问过的链接）<br>a:hover&#123;color:&#125;      //（鼠标经过的链接）  <br>a:active&#123;color:&#125;     //（鼠标按下未弹起的链接）<br></code></pre></td></tr></table></figure><mark>注意：1.按照顺序写伪类选择器       2.链接要单独指定样式</mark><h4 id="7-5-focus伪类选择器"><a href="#7-5-focus伪类选择器" class="headerlink" title="7.5 focus伪类选择器"></a>7.5 focus伪类选择器</h4><p>选取焦点的表单元素谁获得光标谁改变样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Input :focus&#123;&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-盒子"><a href="#8-盒子" class="headerlink" title="8.盒子"></a>8.盒子</h2><h4 id="8-1-border边框设置"><a href="#8-1-border边框设置" class="headerlink" title="8.1 border边框设置"></a>8.1 border边框设置</h4><p>8.1.1边框粗细</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-width: ?;<br></code></pre></td></tr></table></figure><p>8.1.2边框样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-style: solid(实线) | dashed(虚线) | dotted(点线);<br></code></pre></td></tr></table></figure><p>8.1.3边框颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-color: ?;<br></code></pre></td></tr></table></figure><p>8.1.4复合属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">boeder(border-top/border-bottom/..)  : width   style   color ;<br></code></pre></td></tr></table></figure><p>8.1.5边框重合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-collapse:collapse;<br></code></pre></td></tr></table></figure><h4 id="8-2-padding-内边距"><a href="#8-2-padding-内边距" class="headerlink" title="8.2 padding 内边距"></a>8.2 padding 内边距</h4><pre><code class="hljs">padding-top / padding-left / padding-right / padding-bottom: ;</code></pre><p>复合属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">padding: top right left bottom; <br></code></pre></td></tr></table></figure><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/padding.png" class title="This is an test image"><h4 id="8-3-margin外边距"><a href="#8-3-margin外边距" class="headerlink" title="8.3 margin外边距"></a>8.3 margin外边距</h4><pre><code class="hljs">margin-top / margin-left / margin-right / margin-bottom;</code></pre><p>复合属性:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">margin: top right left bottom; <br></code></pre></td></tr></table></figure><h4 id="8-4-盒子阴影"><a href="#8-4-盒子阴影" class="headerlink" title="8.4 盒子阴影"></a>8.4 盒子阴影</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Box-shadow:  h-shadow  v-shadow blur   spread  color  insert;<br></code></pre></td></tr></table></figure><p><mark>详细内容</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/box-shadow.png" class title="This is an test image"><h4 id="8-5-图形圆角边框"><a href="#8-5-图形圆角边框" class="headerlink" title="8.5 图形圆角边框"></a>8.5 图形圆角边框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">border-radius：10px  (圆角矩形）/  50%（宽度高度一半）<br>border-radius：10px 20px 30px 40px(左上，右上，右下，左下)<br></code></pre></td></tr></table></figure><h2 id="9-浮动"><a href="#9-浮动" class="headerlink" title="9.浮动"></a>9.浮动</h2><h4 id="9-1-浮动属性"><a href="#9-1-浮动属性" class="headerlink" title="9.1 浮动属性"></a>9.1 浮动属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">float : none / left / right;<br></code></pre></td></tr></table></figure><h4 id="9-2清除浮动"><a href="#9-2清除浮动" class="headerlink" title="9.2清除浮动"></a>9.2清除浮动</h4><pre><code class="hljs">1&gt; clear : 属性值(left / right / both) 2&gt; 父级添加overflow ： hidden3&gt; 父级添加 ：after 伪元素   ：after &#123;content:””; display:block;height:0  ;  clear : both; visibility : hidden;</code></pre><p><mark>推荐语法css</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/clearfloat.png" class title="This is an test image"><h2 id="10-定位"><a href="#10-定位" class="headerlink" title="10.定位"></a>10.定位</h2><p><mark>1.定位&#x3D;定位模式+边偏移</mark><br><mark>2.定位元素必须添加top&#x2F;left&#x2F;right&#x2F;bottom 值</mark><br><mark>子绝父相：绝对定位不占格子，父只能用相对定位</mark></p><h4 id="10-1-定位属性"><a href="#10-1-定位属性" class="headerlink" title="10.1 定位属性"></a>10.1 定位属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs HTML">&#123;<br>    position:relative / <br>             static(无定位) / <br>             relative(以自己原来的位置移动) / <br>             absolute(没父元素或父元素无定位,以浏览器为准定位,高级浮动) / <br>             fixed(页面内固定不动)  (在浏览器可视窗口）/ <br>             Sticky(粘性定位 = 绝对定位+相对定位)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-2-绝对定位盒子居中语法"><a href="#10-2-绝对定位盒子居中语法" class="headerlink" title="10.2 绝对定位盒子居中语法"></a>10.2 绝对定位盒子居中语法</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">left:50%(父容器一半) <br>margin-left:-50%(盒子宽度一半)<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">transform:translate(-50%,-50%)<br></code></pre></td></tr></table></figure><p><mark>定位属性详细介绍</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/position.png" class title="This is an test image"><h2 id="11-元素的显示与隐藏"><a href="#11-元素的显示与隐藏" class="headerlink" title="11.元素的显示与隐藏"></a>11.元素的显示与隐藏</h2><h4 id="11-1-display属性"><a href="#11-1-display属性" class="headerlink" title="11.1 display属性"></a>11.1 display属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">display:none(隐藏不占位子) / block (转换为块元素/显示元素);<br></code></pre></td></tr></table></figure><h4 id="11-2-visibility属性"><a href="#11-2-visibility属性" class="headerlink" title="11.2 visibility属性"></a>11.2 visibility属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Visibility:visible(元素显示) / hidden(元素隐藏，占位子);<br></code></pre></td></tr></table></figure><h4 id="11-3-Overflow（溢出）属性"><a href="#11-3-Overflow（溢出）属性" class="headerlink" title="11.3 Overflow（溢出）属性"></a>11.3 Overflow（溢出）属性</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs HTML">overflow: visible(默认属性，溢出显示)   <br>overflow: hidden(慎用溢出隐藏)<br>Overflow: scroll(滚动条显示)    <br>overflow: auto (在需要的时候添加滚动条)<br></code></pre></td></tr></table></figure><h2 id="12-精灵图和字体图标"><a href="#12-精灵图和字体图标" class="headerlink" title="12.精灵图和字体图标"></a>12.精灵图和字体图标</h2><h4 id="12-1-精灵图"><a href="#12-1-精灵图" class="headerlink" title="12.1 精灵图"></a>12.1 精灵图</h4><p>目的：把每个小图整合成一个大图减少访问次数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Background:url(?.img) no-repeat -?(x方向)px -?(y方向)px ;<br></code></pre></td></tr></table></figure><h4 id="12-2-字体图标"><a href="#12-2-字体图标" class="headerlink" title="12.2 字体图标"></a>12.2 字体图标</h4><p><mark>字体图标资源网址</mark></p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/icomoon.png" class title="This is an test image"><p><mark>方法步骤：</mark><br>1.下载所需字体图标<br>2.把下载的font文件夹移动到对应目录下<br>3.在css里引入声明 如下图</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/font-family.png" class title="This is an test image"><p>4.生效代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-keyword">@font-face</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;icomoon&#x27;</span>;</span><br><span class="language-css">  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?53gexo&#x27;</span>);</span><br><span class="language-css">  <span class="hljs-attribute">src</span>:  <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.eot?53gexo#iefix&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.ttf?53gexo&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;truetype&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.woff?53gexo&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>),</span><br><span class="language-css">    <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;fonts/icomoon.svg?53gexo#icomoon&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;svg&#x27;</span>);</span><br><span class="language-css">  <span class="hljs-attribute">font-weight</span>: normal;</span><br><span class="language-css">  <span class="hljs-attribute">font-style</span>: normal;</span><br><span class="language-css">  <span class="hljs-attribute">font-display</span>: block;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">Font-family</span>:’icomoon’</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>[]<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="13-css小三角形案例"><a href="#13-css小三角形案例" class="headerlink" title="13.css小三角形案例"></a>13.css小三角形案例</h2><h4 id="13-1-等腰直角"><a href="#13-1-等腰直角" class="headerlink" title="13.1 等腰直角"></a>13.1 等腰直角</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML">.box&#123;<br>    width: 0;<br>    height: 0;<br>    margin: 100px auto;<br>    border: 50px solid transparent;<br>    border-top-color:pink ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="13-2-30-x2F-x2F-60-x2F-90三角形"><a href="#13-2-30-x2F-x2F-60-x2F-90三角形" class="headerlink" title="13.2 30&#x2F;&#x2F;60&#x2F;90三角形"></a>13.2 30&#x2F;&#x2F;60&#x2F;90三角形</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/sanjiaoxing.png" class title="This is an test image"><h2 id="14-用户界面样式"><a href="#14-用户界面样式" class="headerlink" title="14.用户界面样式"></a>14.用户界面样式</h2><h4 id="14-1-鼠标样式"><a href="#14-1-鼠标样式" class="headerlink" title="14.1 鼠标样式"></a>14.1 鼠标样式</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/cursor.png" class title="This is an test image"><h4 id="14-2-表单轮廓"><a href="#14-2-表单轮廓" class="headerlink" title="14.2 表单轮廓"></a>14.2 表单轮廓</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">Input &#123;outline:none;&#125;<br>Textarea &#123;resize:none&#125;<br></code></pre></td></tr></table></figure><h4 id="14-3-vertical-align"><a href="#14-3-vertical-align" class="headerlink" title="14.3 vertical-align:"></a>14.3 vertical-align:</h4><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/vertical.png" class title="This is an test image"><h4 id="14-4-文字溢出显示"><a href="#14-4-文字溢出显示" class="headerlink" title="14.4 文字溢出显示"></a>14.4 文字溢出显示</h4><p>单行文字</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/one.png" class title="This is an test image"><p>多行文字</p><img src="/2022/09/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932/two.png" class title="This is an test image"><p><mark>多行文字溢出显示后台做更简单</mark></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML内容总结</title>
    <link href="/2022/09/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931/"/>
    <url>/2022/09/14/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-HTML内容总结"><a href="#🍭-HTML内容总结" class="headerlink" title="🍭 HTML内容总结"></a>🍭 HTML内容总结</h1><h2 id="1-基础元素："><a href="#1-基础元素：" class="headerlink" title="1.基础元素："></a>1.基础元素：</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML">1.1 <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>斜体字<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br>1.2 <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>加强粗体<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>1.3 <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>粗体<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span><br>1.4 <span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>下划线<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br>1.5 <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>1.6 <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>1.7 <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>三级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>1.8 <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>四级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>1.9 <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>五级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>1.10 <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span>   <br>1.11 回车  <span class="hljs-tag">&lt;/<span class="hljs-name">br</span>&gt;</span>   <br>1.12 空格   &amp;nbps<br>1.13 小于号 &amp;lt<br>1.14 大于号 &amp;gt<br></code></pre></td></tr></table></figure><p><strong>example</strong>:</p><p>1.1 <em>斜体字</em><br>1.2 <strong>加强粗体</strong><br>1.3 <b>粗体</b><br>1.4 <u>下划线</u><br>1.5 </p><h1>一级标题</h1><br>1.6 <h2>二级标题</h2><br>1.7 <h3>三级标题</h3><br>1.8 <h4>四级标题</h4><br>1.9 <h5>五级标题</h5><br>1.10 <h6>六级标题</h6><p></p><hr><h3 id="1-2-图片-x2F-链接-x2F-注释"><a href="#1-2-图片-x2F-链接-x2F-注释" class="headerlink" title="1.2 图片&#x2F;链接&#x2F;注释"></a>1.2 图片&#x2F;链接&#x2F;注释</h3><p>1.图片设置: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">”图片地址”alt</span>=<span class="hljs-string">”未显示图片是提示文字”title</span>=<span class="hljs-string">”鼠标上显示”width</span>=<span class="hljs-string">？</span> <span class="hljs-attr">height</span>=<span class="hljs-string">？</span>  <span class="hljs-attr">border</span>=<span class="hljs-string">？（边框宽度）</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.超链接设置: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">”链接地址”</span> <span class="hljs-attr">title</span>=<span class="hljs-string">”鼠标放置时出现字”</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank（将在新标签页中打开。如果你希望在当前页面打开，忽略这个属性即可“_self”。）&quot;</span>&gt;</span>链接文字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML">2.1 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”#”</span>&gt;</span>空链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.2 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”....html”</span>&gt;</span>链接到同一文件夹下的文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.3 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”....zip”</span>&gt;</span>下载的文件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>2.4 锚点链接<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">”#id”</span>&gt;</span>目标标签<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”id”</span>&gt;</span>目标<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.注释:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-comment">&lt;!-- 我在注释内！ --&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-1列表"><a href="#3-1列表" class="headerlink" title="3.1列表"></a>3.1列表</h2><p>3.1 排在一行内的无序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      <br>    豆浆<br>    油条<br>    豆汁<br>    焦圈<br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:</p><ul>          豆浆    油条    豆汁    焦圈</ul><hr><p>3.2 每个单独一行的无序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>豆浆<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>油条<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>豆汁<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>焦圈<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:  </p><ul>  <li>豆浆</li>  <li>油条</li>  <li>豆汁</li>  <li>焦圈</li></ul><hr><p>3.3 有序列表:  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>沿着条路走到头<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>右转<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>直行穿过第一个十字路口<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>在第三个十字路口处左转<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>继续走 300 米，学校就在你的右手边<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example</strong>:   </p><ol>    <li>沿着条路走到头</li>    <li>右转</li>    <li>直行穿过第一个十字路口</li>    <li>在第三个十字路口处左转</li>    <li>继续走 300 米，学校就在你的右手边</li></ol><hr><h2 id="4-标签-基础标签"><a href="#4-标签-基础标签" class="headerlink" title="4 标签 (基础标签)"></a>4 标签 (基础标签)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML">4.1 <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  块元素（大盒子）  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>4.2 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  行内元素（小盒子）  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="5-表格"><a href="#5-表格" class="headerlink" title="5 表格"></a>5 表格</h2><p>5.1 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>  <span class="hljs-attr">align</span>(<span class="hljs-attr">页面对齐方式</span>) = <span class="hljs-string">“left”/”right”/”center”/</span>    <span class="hljs-attr">Border</span>(<span class="hljs-attr">边框大小</span>)  = <span class="hljs-string">1</span>   <span class="hljs-attr">Cellpadding</span>(<span class="hljs-attr">字和边框的距离大小</span>) =<span class="hljs-string">1</span>    <span class="hljs-attr">Cellspacing</span>(<span class="hljs-attr">单元格之间距离</span>) =<span class="hljs-string">0</span>     <span class="hljs-attr">Width</span>(<span class="hljs-attr">宽度</span>&gt;</span>表格容器)=？<br></code></pre></td></tr></table></figure><p>5.2 一行表格：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>表头单元格(加粗)<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>每行的小格<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>5.3 合并单元格：</p><pre><code class="hljs">rolspan跨行合并(最上一个单元格写)   colspan跨列合并（最左一个单元格写）</code></pre><p>5.4 代码展示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span> = <span class="hljs-string">1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><table border="1">    <tr>        <th>姓名</th>        <th>年龄</th>    </tr>    <tr>        <td>张三</td>        <td>18</td>    </tr></table><hr><h2 id="6-表单"><a href="#6-表单" class="headerlink" title="6.表单"></a>6.表单</h2><p>6.1 表单域：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">”url(传递信息的地址)”</span> <span class="hljs-attr">method</span>=<span class="hljs-string">”post/get”</span> <span class="hljs-attr">name</span>=<span class="hljs-string">”name”</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>6.2 表单元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">”text(文本）/password（密码框）/radio（单选按钮）/checkbox（多选按钮）”</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">”表单id”(相同name才能实现单选)</span>   <span class="hljs-attr">value</span>=<span class="hljs-string">”方框内的文字提示”</span>   <span class="hljs-attr">checked</span>=<span class="hljs-string">“checked”（单选/多选自动选择）</span> </span><br><span class="hljs-tag"><span class="hljs-attr">Maxlength</span>=<span class="hljs-string">“”最长字符</span>&gt;</span>   <br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><p>6.2.1 type&#x3D;”text”<br><input type="text" name="fist" value="请输入"></p><p>6.2.2 type&#x3D;”password”<br><input type="password" name="second" value></p><p>6.2.3 type&#x3D;”radio”<br><input type="radio" name="third" value="check">男<br><input type="radio" name="third" value="check">女</p><p>6.2.4 type&#x3D;”checkbox”<br><input type="checkbox" name="fourth" value="check" checked="checked"><br><input type="checkbox" name="fourth" value="check"></p><p>6.3 label标签 </p><pre><code class="hljs">label标签点击标签自动定位到input里</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">”text”</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><p><label for="text">…</label><input type="text" id="text"></p><p>6.4select 下拉表单元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">select</span>=<span class="hljs-string">”selected”(默认选择)</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>example:</strong></p><select>    <option select="”selected”(默认选择)">0</option>    <option>1</option>    <option>2</option>    <option>3</option>    <option>4</option></select><p>6.5textare 文本域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">textare</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textare</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><h2 id="7-head容器中内容"><a href="#7-head容器中内容" class="headerlink" title="7.head容器中内容"></a>7.head容器中内容</h2><p>7.1 设置utf-8格式 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span> = <span class="hljs-string">“utf-8”</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7.2网页标题：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>7.3设置主语言：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span> = <span class="hljs-string">“zh-CN”</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown语法</title>
    <link href="/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="🍭-Markdown语法示例"><a href="#🍭-Markdown语法示例" class="headerlink" title="🍭 Markdown语法示例"></a>🍭 Markdown语法示例</h1><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题[ # ]"></a>1.标题[ # ]</h2><pre><code class="hljs"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p><em>example:</em></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="2-强调-或-包围"><a href="#2-强调-或-包围" class="headerlink" title="2.强调[ ** 或 __ 包围 ]"></a>2.强调[ ** 或 __ 包围 ]</h2><pre><code class="hljs">**强调字体**__强调字体__</code></pre><p><em>example:</em><br><strong>强调字体</strong><br><strong>强调字体</strong></p><hr><h2 id="3-斜体-或-包围"><a href="#3-斜体-或-包围" class="headerlink" title="3.斜体 [ * 或 _ 包围 ]"></a>3.斜体 [ * 或 _ 包围 ]</h2><pre><code class="hljs">*斜体字体*_斜体字体_</code></pre><p><em>example:</em><br><em>斜体字体</em><br><em>斜体字体</em></p><hr><h2 id="4-删除线-包围"><a href="#4-删除线-包围" class="headerlink" title="4.删除线 [ ~~包围 ]"></a>4.删除线 [ ~~包围 ]</h2><pre><code class="hljs">~~删除的文字~~</code></pre><p><em>example:</em><br><del>删除的文字</del></p><hr><h2 id="5-高亮-x3D-x3D-包围"><a href="#5-高亮-x3D-x3D-包围" class="headerlink" title="5.高亮  [ &#x3D;&#x3D; 包围 ]"></a>5.高亮  [ &#x3D;&#x3D; 包围 ]</h2><pre><code class="hljs">==高亮字体==&lt;mark&gt;高亮字体&lt;/mark&gt;</code></pre><p><em>example:</em><br>&#x3D;&#x3D;高亮字体&#x3D;&#x3D;<br><mark>高亮字体</mark></p><hr><h2 id="6-代码行-96-包围"><a href="#6-代码行-96-包围" class="headerlink" title="6.代码行 [ &#96; 包围 ]"></a>6.代码行 [ &#96; 包围 ]</h2><pre><code class="hljs">`print(&#39;a&#39;)`</code></pre><p><em>example:</em><br><code>printf(&#39;a&#39;)</code></p><hr><h2 id="7-代码块-‘’’-包围"><a href="#7-代码块-‘’’-包围" class="headerlink" title="7.代码块 [ ‘’’ 包围 ]"></a>7.代码块 [ ‘’’ 包围 ]</h2><p><em>example:</em></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-built_in">int</span> mian() &#123;<br>    printf（“Hello, world!\n<span class="hljs-string">&quot;）;</span><br><span class="hljs-string">    retrun O;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><hr><h2 id="8-引用-gt-并且-gt-gt-前置"><a href="#8-引用-gt-并且-gt-gt-前置" class="headerlink" title="8.引用 [ &gt; 并且 &gt; &gt; 前置]"></a>8.引用 [ &gt; 并且 &gt; &gt; 前置]</h2><pre><code class="hljs">&gt; 一级引用&gt; &gt; 二级引用</code></pre><p><em>example:</em></p><blockquote><p>一级引用</p><blockquote><p>二级引用</p></blockquote></blockquote><hr><h2 id="9-无序列表-或-或-前置"><a href="#9-无序列表-或-或-前置" class="headerlink" title="9.无序列表[ - 或 + 或 * 前置]"></a>9.无序列表[ - 或 + 或 * 前置]</h2><pre><code class="hljs">- 无序列表+ 无序列表* 无序列表</code></pre><p><em>example:</em></p><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><hr><h2 id="10-有序列表-数字-前置"><a href="#10-有序列表-数字-前置" class="headerlink" title="10.有序列表 [ 数字 + . 前置 ]"></a>10.有序列表 [ 数字 + . 前置 ]</h2><pre><code class="hljs">1. 有序列表2. 有序列表3. 有序列表</code></pre><p><em>example:</em></p><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><hr><h2 id="11-注释-后置"><a href="#11-注释-后置" class="headerlink" title="11. 注释 [ [^] 后置]"></a>11. 注释 [ [^] 后置]</h2><pre><code class="hljs">这是注释&lt;sup id=&quot;fnref:1&quot; class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--rounded&quot; aria-label=&quot;注释的解释&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;</code></pre><p><em>example:</em><br>这是注释<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="注释的解释">[1]</span></a></sup></p><hr><h2 id="12-链接-常用-“-”-“-”-分别包围文本与链接"><a href="#12-链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="12. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>12. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h2><pre><code class="hljs">[正文](链接)</code></pre><hr><h2 id="13-任务列表-“-”-空格-前置"><a href="#13-任务列表-“-”-空格-前置" class="headerlink" title="13.任务列表 [“- [ ]” + 空格 前置]"></a>13.任务列表 [“- [ ]” + 空格 前置]</h2><pre><code class="hljs">&quot;- [ ] 刷B站&quot;&quot;- [ ] 写代码&quot;&quot;- [x] 起床&quot;</code></pre><p><em>example:</em></p><ul><li><input disabled type="checkbox"> 刷B站</li><li><input disabled type="checkbox"> 写代码</li><li><input checked disabled type="checkbox"> 起床</li></ul><hr><h2 id="14-表格-用-“-”-绘制表格边框"><a href="#14-表格-用-“-”-绘制表格边框" class="headerlink" title="14.表格 [用 “|” 绘制表格边框]"></a>14.表格 [用 “|” 绘制表格边框]</h2><pre><code class="hljs">学号|姓名|年龄:---|:---:|---:  (引号的位置代表着 左对齐, 居中, 右对齐)1|b|242|b|25</code></pre><p><em>example:</em></p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">b</td><td align="right">24</td></tr><tr><td align="left">2</td><td align="center">b</td><td align="right">25</td></tr></tbody></table><hr><h2 id="15-图片-“-图片-图片地址-”"><a href="#15-图片-“-图片-图片地址-”" class="headerlink" title="15.图片 [ “! [图片] (图片地址)” ]"></a>15.图片 [ “! [图片] (图片地址)” ]</h2><pre><code class="hljs">&#123;% asset_img example.png This is an test image %&#125;</code></pre><p><em>example:</em></p><img src="/2022/09/13/markdown%E6%80%BB%E7%BB%93/markdown%E8%AF%AD%E6%B3%95/example.png" class title="This is an test image"><hr><h2 id="16-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#16-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="16.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>16.分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h2><pre><code class="hljs">***---___</code></pre><p><em>example:</em></p><ol><li></li></ol><hr><ol start="2"><li></li></ol><hr><ol start="3"><li></li></ol><hr><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><p><strong>不断总结markdown实用语法</strong><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>注释的解释<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:1" class="footnote-text"><span>注释的解释<br><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section></p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <url>/2022/09/12/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>hello world</p><h2 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h2><hr><h2 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h2><hr><p>end结束</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/12/hello-world/"/>
    <url>/2022/09/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
